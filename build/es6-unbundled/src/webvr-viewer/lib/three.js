(function(o,_){'object'===typeof exports&&'undefined'!==typeof module?_(exports):'function'===typeof define&&define.amd?define(['exports'],_):_(o.THREE=o.THREE||{})})(this,function(o){'use strict';function _(wo,Co,Do,Uo){this._x=wo||0,this._y=Co||0,this._z=Do||0,this._w=Uo===void 0?1:Uo}function E(wo,Co,Do){this.x=wo||0,this.y=Co||0,this.z=Do||0}function S(){this.elements=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),0<arguments.length&&console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.')}function M(){}function T(wo,Co){this.x=wo||0,this.y=Co||0}function L(wo,Co,Do,Uo,No,Io,zo,Fo,Bo,Oo){Object.defineProperty(this,'id',{value:pi++}),this.uuid=ci.generateUUID(),this.name='',this.image=wo===void 0?L.DEFAULT_IMAGE:wo,this.mipmaps=[],this.mapping=Co===void 0?L.DEFAULT_MAPPING:Co,this.wrapS=Do===void 0?ia:Do,this.wrapT=Uo===void 0?ia:Uo,this.magFilter=No===void 0?da:No,this.minFilter=Io===void 0?pa:Io,this.anisotropy=Bo===void 0?1:Bo,this.format=zo===void 0?La:zo,this.type=Fo===void 0?ua:Fo,this.offset=new T(0,0),this.repeat=new T(1,1),this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=Oo===void 0?ei:Oo,this.version=0,this.onUpdate=null}function A(wo,Co,Do,Uo,No,Io,zo,Fo,Bo,Oo){wo=wo===void 0?[]:wo,Co=Co===void 0?Qr:Co,L.call(this,wo,Co,Do,Uo,No,Io,zo,Fo,Bo,Oo),this.flipY=!1}function R(){this.seq=[],this.map={}}function P(wo,Co,Do){var Uo=wo[0];if(0>=Uo||0<Uo)return wo;var No=Co*Do,Io=fi[No];if(void 0===Io&&(Io=new Float32Array(No),fi[No]=Io),0!==Co){Uo.toArray(Io,0);for(var zo=1,Fo=0;zo!==Co;++zo)Fo+=Do,wo[zo].toArray(Io,Fo)}return Io}function C(wo,Co){var Do=gi[Co];Do===void 0&&(Do=new Int32Array(Co),gi[Co]=Do);for(var Uo=0;Uo!==Co;++Uo)Do[Uo]=wo.allocTextureUnit();return Do}function D(wo,Co){wo.uniform1f(this.addr,Co)}function U(wo,Co){wo.uniform1i(this.addr,Co)}function N(wo,Co){Co.x===void 0?wo.uniform2fv(this.addr,Co):wo.uniform2f(this.addr,Co.x,Co.y)}function I(wo,Co){Co.x===void 0?Co.r===void 0?wo.uniform3fv(this.addr,Co):wo.uniform3f(this.addr,Co.r,Co.g,Co.b):wo.uniform3f(this.addr,Co.x,Co.y,Co.z)}function F(wo,Co){Co.x===void 0?wo.uniform4fv(this.addr,Co):wo.uniform4f(this.addr,Co.x,Co.y,Co.z,Co.w)}function B(wo,Co){wo.uniformMatrix2fv(this.addr,!1,Co.elements||Co)}function O(wo,Co){wo.uniformMatrix3fv(this.addr,!1,Co.elements||Co)}function G(wo,Co){wo.uniformMatrix4fv(this.addr,!1,Co.elements||Co)}function V(wo,Co,Do){var Uo=Do.allocTextureUnit();wo.uniform1i(this.addr,Uo),Do.setTexture2D(Co||ui,Uo)}function H(wo,Co,Do){var Uo=Do.allocTextureUnit();wo.uniform1i(this.addr,Uo),Do.setTextureCube(Co||mi,Uo)}function W(wo,Co){wo.uniform2iv(this.addr,Co)}function X(wo,Co){wo.uniform3iv(this.addr,Co)}function Y(wo,Co){wo.uniform4iv(this.addr,Co)}function Z(wo){return 5126===wo?D:35664===wo?N:35665===wo?I:35666===wo?F:35674===wo?B:35675===wo?O:35676===wo?G:35678===wo?V:35680===wo?H:5124===wo||35670===wo?U:35667===wo||35671===wo?W:35668===wo||35672===wo?X:35669===wo||35673===wo?Y:void 0}function Q(wo,Co){wo.uniform1fv(this.addr,Co)}function J(wo,Co){wo.uniform1iv(this.addr,Co)}function K(wo,Co){wo.uniform2fv(this.addr,P(Co,this.size,2))}function $(wo,Co){wo.uniform3fv(this.addr,P(Co,this.size,3))}function ee(wo,Co){wo.uniform4fv(this.addr,P(Co,this.size,4))}function re(wo,Co){wo.uniformMatrix2fv(this.addr,!1,P(Co,this.size,4))}function ie(wo,Co){wo.uniformMatrix3fv(this.addr,!1,P(Co,this.size,9))}function ne(wo,Co){wo.uniformMatrix4fv(this.addr,!1,P(Co,this.size,16))}function oe(wo,Co,Do){var Uo=Co.length,No=C(Do,Uo);wo.uniform1iv(this.addr,No);for(var Io=0;Io!==Uo;++Io)Do.setTexture2D(Co[Io]||ui,No[Io])}function se(wo,Co,Do){var Uo=Co.length,No=C(Do,Uo);wo.uniform1iv(this.addr,No);for(var Io=0;Io!==Uo;++Io)Do.setTextureCube(Co[Io]||mi,No[Io])}function le(wo){return 5126===wo?Q:35664===wo?K:35665===wo?$:35666===wo?ee:35674===wo?re:35675===wo?ie:35676===wo?ne:35678===wo?oe:35680===wo?se:5124===wo||35670===wo?J:35667===wo||35671===wo?W:35668===wo||35672===wo?X:35669===wo||35673===wo?Y:void 0}function pe(wo,Co,Do){this.id=wo,this.addr=Do,this.setValue=Z(Co.type)}function ue(wo,Co,Do){this.id=wo,this.addr=Do,this.size=Co.size,this.setValue=le(Co.type)}function fe(wo){this.id=wo,R.call(this)}function ge(wo,Co){wo.seq.push(Co),wo.map[Co.id]=Co}function he(wo,Co,Do){var Uo=wo.name,No=Uo.length;for(hi.lastIndex=0;;){var Io=hi.exec(Uo),zo=hi.lastIndex,Fo=Io[1],Bo=']'===Io[2],Oo=Io[3];if(Bo&&(Fo|=0),void 0===Oo||'['===Oo&&zo+2===No){ge(Do,void 0===Oo?new pe(Fo,wo,Co):new ue(Fo,wo,Co));break}else{var Go=Do.map,Vo=Go[Fo];void 0===Vo&&(Vo=new fe(Fo),ge(Do,Vo)),Do=Vo}}}function xe(wo,Co,Do){R.call(this),this.renderer=Do;for(var Uo=wo.getProgramParameter(Co,wo.ACTIVE_UNIFORMS),No=0;No<Uo;++No){var Io=wo.getActiveUniform(Co,No),zo=Io.name,Fo=wo.getUniformLocation(Co,zo);he(Io,Fo,this)}}function _e(wo,Co,Do,Uo){this.x=wo||0,this.y=Co||0,this.z=Do||0,this.w=Uo===void 0?1:Uo}function ve(wo,Co,Do){return void 0===Co&&void 0===Do?this.set(wo):this.setRGB(wo,Co,Do)}function ye(wo,Co){this.min=wo===void 0?new T(+Infinity,+Infinity):wo,this.max=Co===void 0?new T(-Infinity,-Infinity):Co}function Ee(wo,Co){function Do(){var Wo=new Float32Array([-1,-1,0,0,1,-1,1,0,1,1,1,1,-1,1,0,1]),Xo=new Uint16Array([0,1,2,0,2,3]);zo=No.createBuffer(),Fo=No.createBuffer(),No.bindBuffer(No.ARRAY_BUFFER,zo),No.bufferData(No.ARRAY_BUFFER,Wo,No.STATIC_DRAW),No.bindBuffer(No.ELEMENT_ARRAY_BUFFER,Fo),No.bufferData(No.ELEMENT_ARRAY_BUFFER,Xo,No.STATIC_DRAW),Ho=No.createTexture(),ko=No.createTexture(),Io.bindTexture(No.TEXTURE_2D,Ho),No.texImage2D(No.TEXTURE_2D,0,No.RGB,16,16,0,No.RGB,No.UNSIGNED_BYTE,null),No.texParameteri(No.TEXTURE_2D,No.TEXTURE_WRAP_S,No.CLAMP_TO_EDGE),No.texParameteri(No.TEXTURE_2D,No.TEXTURE_WRAP_T,No.CLAMP_TO_EDGE),No.texParameteri(No.TEXTURE_2D,No.TEXTURE_MAG_FILTER,No.NEAREST),No.texParameteri(No.TEXTURE_2D,No.TEXTURE_MIN_FILTER,No.NEAREST),Io.bindTexture(No.TEXTURE_2D,ko),No.texImage2D(No.TEXTURE_2D,0,No.RGBA,16,16,0,No.RGBA,No.UNSIGNED_BYTE,null),No.texParameteri(No.TEXTURE_2D,No.TEXTURE_WRAP_S,No.CLAMP_TO_EDGE),No.texParameteri(No.TEXTURE_2D,No.TEXTURE_WRAP_T,No.CLAMP_TO_EDGE),No.texParameteri(No.TEXTURE_2D,No.TEXTURE_MAG_FILTER,No.NEAREST),No.texParameteri(No.TEXTURE_2D,No.TEXTURE_MIN_FILTER,No.NEAREST),Bo={vertexShader:['uniform lowp int renderType;','uniform vec3 screenPosition;','uniform vec2 scale;','uniform float rotation;','uniform sampler2D occlusionMap;','attribute vec2 position;','attribute vec2 uv;','varying vec2 vUV;','varying float vVisibility;','void main() {','vUV = uv;','vec2 pos = position;','if ( renderType == 2 ) {','vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );','visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );','visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );','visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );','visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );','visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );','visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );','visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );','visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );','vVisibility =        visibility.r / 9.0;','vVisibility *= 1.0 - visibility.g / 9.0;','vVisibility *=       visibility.b / 9.0;','vVisibility *= 1.0 - visibility.a / 9.0;','pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;','pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;','}','gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );','}'].join('\n'),fragmentShader:['uniform lowp int renderType;','uniform sampler2D map;','uniform float opacity;','uniform vec3 color;','varying vec2 vUV;','varying float vVisibility;','void main() {','if ( renderType == 0 ) {','gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );','} else if ( renderType == 1 ) {','gl_FragColor = texture2D( map, vUV );','} else {','vec4 texture = texture2D( map, vUV );','texture.a *= opacity * vVisibility;','gl_FragColor = texture;','gl_FragColor.rgb *= color;','}','}'].join('\n')},Oo=Uo(Bo),Go={vertex:No.getAttribLocation(Oo,'position'),uv:No.getAttribLocation(Oo,'uv')},Vo={renderType:No.getUniformLocation(Oo,'renderType'),map:No.getUniformLocation(Oo,'map'),occlusionMap:No.getUniformLocation(Oo,'occlusionMap'),opacity:No.getUniformLocation(Oo,'opacity'),color:No.getUniformLocation(Oo,'color'),scale:No.getUniformLocation(Oo,'scale'),rotation:No.getUniformLocation(Oo,'rotation'),screenPosition:No.getUniformLocation(Oo,'screenPosition')}}function Uo(Wo){var Xo=No.createProgram(),Yo=No.createShader(No.FRAGMENT_SHADER),jo=No.createShader(No.VERTEX_SHADER),qo='precision '+wo.getPrecision()+' float;\n';return No.shaderSource(Yo,qo+Wo.fragmentShader),No.shaderSource(jo,qo+Wo.vertexShader),No.compileShader(Yo),No.compileShader(jo),No.attachShader(Xo,Yo),No.attachShader(Xo,jo),No.linkProgram(Xo),Xo}var No=wo.context,Io=wo.state,zo,Fo,Bo,Oo,Go,Vo,Ho,ko;this.render=function(Wo,Xo,Yo){if(0!==Co.length){var jo=new E,qo=Yo.w/Yo.z,Zo=0.5*Yo.z,Qo=0.5*Yo.w,Jo=16/Yo.w,Ko=new T(Jo*qo,Jo),$o=new E(1,1,0),es=new T(1,1),ts=new ye;ts.min.set(Yo.x,Yo.y),ts.max.set(Yo.x+(Yo.z-16),Yo.y+(Yo.w-16)),void 0===Oo&&Do(),No.useProgram(Oo),Io.initAttributes(),Io.enableAttribute(Go.vertex),Io.enableAttribute(Go.uv),Io.disableUnusedAttributes(),No.uniform1i(Vo.occlusionMap,0),No.uniform1i(Vo.map,1),No.bindBuffer(No.ARRAY_BUFFER,zo),No.vertexAttribPointer(Go.vertex,2,No.FLOAT,!1,16,0),No.vertexAttribPointer(Go.uv,2,No.FLOAT,!1,16,8),No.bindBuffer(No.ELEMENT_ARRAY_BUFFER,Fo),Io.disable(No.CULL_FACE),Io.setDepthWrite(!1);for(var rs=0,as=Co.length;rs<as;rs++){Jo=16/Yo.w,Ko.set(Jo*qo,Jo);var is=Co[rs];if(jo.set(is.matrixWorld.elements[12],is.matrixWorld.elements[13],is.matrixWorld.elements[14]),jo.applyMatrix4(Xo.matrixWorldInverse),jo.applyMatrix4(Xo.projectionMatrix),$o.copy(jo),es.x=Yo.x+$o.x*Zo+Zo-8,es.y=Yo.y+$o.y*Qo+Qo-8,!0===ts.containsPoint(es)){Io.activeTexture(No.TEXTURE0),Io.bindTexture(No.TEXTURE_2D,null),Io.activeTexture(No.TEXTURE1),Io.bindTexture(No.TEXTURE_2D,Ho),No.copyTexImage2D(No.TEXTURE_2D,0,No.RGB,es.x,es.y,16,16,0),No.uniform1i(Vo.renderType,0),No.uniform2f(Vo.scale,Ko.x,Ko.y),No.uniform3f(Vo.screenPosition,$o.x,$o.y,$o.z),Io.disable(No.BLEND),Io.enable(No.DEPTH_TEST),No.drawElements(No.TRIANGLES,6,No.UNSIGNED_SHORT,0),Io.activeTexture(No.TEXTURE0),Io.bindTexture(No.TEXTURE_2D,ko),No.copyTexImage2D(No.TEXTURE_2D,0,No.RGBA,es.x,es.y,16,16,0),No.uniform1i(Vo.renderType,1),Io.disable(No.DEPTH_TEST),Io.activeTexture(No.TEXTURE1),Io.bindTexture(No.TEXTURE_2D,Ho),No.drawElements(No.TRIANGLES,6,No.UNSIGNED_SHORT,0),is.positionScreen.copy($o),is.customUpdateCallback?is.customUpdateCallback(is):is.updateLensFlares(),No.uniform1i(Vo.renderType,2),Io.enable(No.BLEND);for(var ns=0,os=is.lensFlares.length,ss;ns<os;ns++)ss=is.lensFlares[ns],1e-3<ss.opacity&&1e-3<ss.scale&&($o.x=ss.x,$o.y=ss.y,$o.z=ss.z,Jo=ss.size*ss.scale/Yo.w,Ko.x=Jo*qo,Ko.y=Jo,No.uniform3f(Vo.screenPosition,$o.x,$o.y,$o.z),No.uniform2f(Vo.scale,Ko.x,Ko.y),No.uniform1f(Vo.rotation,ss.rotation),No.uniform1f(Vo.opacity,ss.opacity),No.uniform3f(Vo.color,ss.color.r,ss.color.g,ss.color.b),Io.setBlending(ss.blending,ss.blendEquation,ss.blendSrc,ss.blendDst),wo.setTexture2D(ss.texture,1),No.drawElements(No.TRIANGLES,6,No.UNSIGNED_SHORT,0))}}Io.enable(No.CULL_FACE),Io.enable(No.DEPTH_TEST),Io.setDepthWrite(!0),wo.resetGLState()}}}function Se(wo,Co){function Do(){var Yo=new Float32Array([-0.5,-0.5,0,0,0.5,-0.5,1,0,0.5,0.5,1,1,-0.5,0.5,0,1]),jo=new Uint16Array([0,1,2,0,2,3]);Fo=Io.createBuffer(),Bo=Io.createBuffer(),Io.bindBuffer(Io.ARRAY_BUFFER,Fo),Io.bufferData(Io.ARRAY_BUFFER,Yo,Io.STATIC_DRAW),Io.bindBuffer(Io.ELEMENT_ARRAY_BUFFER,Bo),Io.bufferData(Io.ELEMENT_ARRAY_BUFFER,jo,Io.STATIC_DRAW),Oo=Uo(),Go={position:Io.getAttribLocation(Oo,'position'),uv:Io.getAttribLocation(Oo,'uv')},Vo={uvOffset:Io.getUniformLocation(Oo,'uvOffset'),uvScale:Io.getUniformLocation(Oo,'uvScale'),rotation:Io.getUniformLocation(Oo,'rotation'),scale:Io.getUniformLocation(Oo,'scale'),color:Io.getUniformLocation(Oo,'color'),map:Io.getUniformLocation(Oo,'map'),opacity:Io.getUniformLocation(Oo,'opacity'),modelViewMatrix:Io.getUniformLocation(Oo,'modelViewMatrix'),projectionMatrix:Io.getUniformLocation(Oo,'projectionMatrix'),fogType:Io.getUniformLocation(Oo,'fogType'),fogDensity:Io.getUniformLocation(Oo,'fogDensity'),fogNear:Io.getUniformLocation(Oo,'fogNear'),fogFar:Io.getUniformLocation(Oo,'fogFar'),fogColor:Io.getUniformLocation(Oo,'fogColor'),alphaTest:Io.getUniformLocation(Oo,'alphaTest')};var qo=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');qo.width=8,qo.height=8;var Zo=qo.getContext('2d');Zo.fillStyle='white',Zo.fillRect(0,0,8,8),Ho=new L(qo),Ho.needsUpdate=!0}function Uo(){var Yo=Io.createProgram(),jo=Io.createShader(Io.VERTEX_SHADER),qo=Io.createShader(Io.FRAGMENT_SHADER);return Io.shaderSource(jo,['precision '+wo.getPrecision()+' float;','uniform mat4 modelViewMatrix;','uniform mat4 projectionMatrix;','uniform float rotation;','uniform vec2 scale;','uniform vec2 uvOffset;','uniform vec2 uvScale;','attribute vec2 position;','attribute vec2 uv;','varying vec2 vUV;','void main() {','vUV = uvOffset + uv * uvScale;','vec2 alignedPosition = position * scale;','vec2 rotatedPosition;','rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;','rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;','vec4 finalPosition;','finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );','finalPosition.xy += rotatedPosition;','finalPosition = projectionMatrix * finalPosition;','gl_Position = finalPosition;','}'].join('\n')),Io.shaderSource(qo,['precision '+wo.getPrecision()+' float;','uniform vec3 color;','uniform sampler2D map;','uniform float opacity;','uniform int fogType;','uniform vec3 fogColor;','uniform float fogDensity;','uniform float fogNear;','uniform float fogFar;','uniform float alphaTest;','varying vec2 vUV;','void main() {','vec4 texture = texture2D( map, vUV );','if ( texture.a < alphaTest ) discard;','gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );','if ( fogType > 0 ) {','float depth = gl_FragCoord.z / gl_FragCoord.w;','float fogFactor = 0.0;','if ( fogType == 1 ) {','fogFactor = smoothstep( fogNear, fogFar, depth );','} else {','const float LOG2 = 1.442695;','fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );','fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );','}','gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );','}','}'].join('\n')),Io.compileShader(jo),Io.compileShader(qo),Io.attachShader(Yo,jo),Io.attachShader(Yo,qo),Io.linkProgram(Yo),Yo}function No(Yo,jo){return Yo.renderOrder===jo.renderOrder?Yo.z===jo.z?jo.id-Yo.id:jo.z-Yo.z:Yo.renderOrder-jo.renderOrder}var Io=wo.context,zo=wo.state,Fo,Bo,Oo,Go,Vo,Ho,ko=new E,Wo=new _,Xo=new E;this.render=function(Yo,jo){if(0!==Co.length){void 0===Oo&&Do(),Io.useProgram(Oo),zo.initAttributes(),zo.enableAttribute(Go.position),zo.enableAttribute(Go.uv),zo.disableUnusedAttributes(),zo.disable(Io.CULL_FACE),zo.enable(Io.BLEND),Io.bindBuffer(Io.ARRAY_BUFFER,Fo),Io.vertexAttribPointer(Go.position,2,Io.FLOAT,!1,16,0),Io.vertexAttribPointer(Go.uv,2,Io.FLOAT,!1,16,8),Io.bindBuffer(Io.ELEMENT_ARRAY_BUFFER,Bo),Io.uniformMatrix4fv(Vo.projectionMatrix,!1,jo.projectionMatrix.elements),zo.activeTexture(Io.TEXTURE0),Io.uniform1i(Vo.map,0);var qo=0,Zo=0,Qo=Yo.fog;Qo?(Io.uniform3f(Vo.fogColor,Qo.color.r,Qo.color.g,Qo.color.b),Qo.isFog?(Io.uniform1f(Vo.fogNear,Qo.near),Io.uniform1f(Vo.fogFar,Qo.far),Io.uniform1i(Vo.fogType,1),qo=1,Zo=1):Qo.isFogExp2&&(Io.uniform1f(Vo.fogDensity,Qo.density),Io.uniform1i(Vo.fogType,2),qo=2,Zo=2)):(Io.uniform1i(Vo.fogType,0),qo=0,Zo=0);for(var Jo=0,Ko=Co.length,$o;Jo<Ko;Jo++)$o=Co[Jo],$o.modelViewMatrix.multiplyMatrices(jo.matrixWorldInverse,$o.matrixWorld),$o.z=-$o.modelViewMatrix.elements[14];Co.sort(No);for(var es=[],Jo=0,Ko=Co.length;Jo<Ko;Jo++){var $o=Co[Jo],ts=$o.material;if(!1!==ts.visible){Io.uniform1f(Vo.alphaTest,ts.alphaTest),Io.uniformMatrix4fv(Vo.modelViewMatrix,!1,$o.modelViewMatrix.elements),$o.matrixWorld.decompose(ko,Wo,Xo),es[0]=Xo.x,es[1]=Xo.y;var rs=0;Yo.fog&&ts.fog&&(rs=Zo),qo!==rs&&(Io.uniform1i(Vo.fogType,rs),qo=rs),null===ts.map?(Io.uniform2f(Vo.uvOffset,0,0),Io.uniform2f(Vo.uvScale,1,1)):(Io.uniform2f(Vo.uvOffset,ts.map.offset.x,ts.map.offset.y),Io.uniform2f(Vo.uvScale,ts.map.repeat.x,ts.map.repeat.y)),Io.uniform1f(Vo.opacity,ts.opacity),Io.uniform3f(Vo.color,ts.color.r,ts.color.g,ts.color.b),Io.uniform1f(Vo.rotation,ts.rotation),Io.uniform2fv(Vo.scale,es),zo.setBlending(ts.blending,ts.blendEquation,ts.blendSrc,ts.blendDst),zo.setDepthTest(ts.depthTest),zo.setDepthWrite(ts.depthWrite),ts.map?wo.setTexture2D(ts.map,0):wo.setTexture2D(Ho,0),Io.drawElements(Io.TRIANGLES,6,Io.UNSIGNED_SHORT,0)}}zo.enable(Io.CULL_FACE),wo.resetGLState()}}}function Me(wo,Co,Do){this.uuid=ci.generateUUID(),this.width=wo,this.height=Co,this.scissor=new _e(0,0,wo,Co),this.scissorTest=!1,this.viewport=new _e(0,0,wo,Co),Do=Do||{},Do.minFilter===void 0&&(Do.minFilter=da),this.texture=new L(void 0,void 0,Do.wrapS,Do.wrapT,Do.magFilter,Do.minFilter,Do.format,Do.type,Do.anisotropy,Do.encoding),this.depthBuffer=!(Do.depthBuffer!==void 0)||Do.depthBuffer,this.stencilBuffer=!(Do.stencilBuffer!==void 0)||Do.stencilBuffer,this.depthTexture=Do.depthTexture===void 0?null:Do.depthTexture}function Te(){Object.defineProperty(this,'id',{value:Mo++}),this.uuid=ci.generateUUID(),this.name='',this.type='Material',this.fog=!0,this.lights=!0,this.blending=ur,this.side=ar,this.shading=sr,this.vertexColors=lr,this.opacity=1,this.transparent=!1,this.blendSrc=Lr,this.blendDst=Ar,this.blendEquation=xr,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=zr,this.depthTest=!0,this.depthWrite=!0,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.alphaTest=0,this.premultipliedAlpha=!1,this.overdraw=0,this.visible=!0,this._needsUpdate=!0}function Le(wo){Te.call(this),this.type='ShaderMaterial',this.defines={},this.uniforms={},this.vertexShader='void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}',this.fragmentShader='void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}',this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,wo!==void 0&&(wo.attributes!==void 0&&console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.'),this.setValues(wo))}function Ae(wo){Te.call(this),this.type='MeshDepthMaterial',this.depthPacking=li,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.setValues(wo)}function Re(wo,Co){this.min=wo===void 0?new E(+Infinity,+Infinity,+Infinity):wo,this.max=Co===void 0?new E(-Infinity,-Infinity,-Infinity):Co}function Pe(wo,Co){this.center=wo===void 0?new E:wo,this.radius=Co===void 0?0:Co}function we(){this.elements=new Float32Array([1,0,0,0,1,0,0,0,1]),0<arguments.length&&console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.')}function Ce(wo,Co){this.normal=wo===void 0?new E(1,0,0):wo,this.constant=Co===void 0?0:Co}function De(wo,Co,Do,Uo,No,Io){this.planes=[wo===void 0?new Ce:wo,Co===void 0?new Ce:Co,Do===void 0?new Ce:Do,Uo===void 0?new Ce:Uo,No===void 0?new Ce:No,Io===void 0?new Ce:Io]}function Ue(wo,Co,Do,Uo){function No(cs,ps,us,ms){var fs=cs.geometry,gs=null,hs=Zo,xs=cs.customDepthMaterial;if(us&&(hs=Qo,xs=cs.customDistanceMaterial),!xs){var _s=!1;ps.morphTargets&&(fs&&fs.isBufferGeometry?_s=fs.morphAttributes&&fs.morphAttributes.position&&0<fs.morphAttributes.position.length:fs&&fs.isGeometry&&(_s=fs.morphTargets&&0<fs.morphTargets.length));var vs=cs.isSkinnedMesh&&ps.skinning,ys=0;_s&&(ys|=Yo),vs&&(ys|=jo),gs=hs[ys]}else gs=xs;if(wo.localClippingEnabled&&!0===ps.clipShadows&&0!==ps.clippingPlanes.length){var Es=gs.uuid,bs=ps.uuid,Ss=Jo[Es];void 0===Ss&&(Ss={},Jo[Es]=Ss);var Ms=Ss[bs];void 0===Ms&&(Ms=gs.clone(),Ss[bs]=Ms),gs=Ms}gs.visible=ps.visible,gs.wireframe=ps.wireframe;var Ts=ps.side;return ds.renderSingleSided&&Ts==nr&&(Ts=ar),ds.renderReverseSided&&(Ts===ar?Ts=ir:Ts===ir&&(Ts=ar)),gs.side=Ts,gs.clipShadows=ps.clipShadows,gs.clippingPlanes=ps.clippingPlanes,gs.wireframeLinewidth=ps.wireframeLinewidth,gs.linewidth=ps.linewidth,us&&void 0!==gs.uniforms.lightPos&&gs.uniforms.lightPos.value.copy(ms),gs}function Io(cs,ps,us){if(!1!==cs.visible){var ms=0!==(cs.layers.mask&ps.layers.mask);if(ms&&(cs.isMesh||cs.isLine||cs.isPoints)&&cs.castShadow&&(!1===cs.frustumCulled||!0===Bo.intersectsObject(cs))){var fs=cs.material;!0===fs.visible&&(cs.modelViewMatrix.multiplyMatrices(us.matrixWorldInverse,cs.matrixWorld),Xo.push(cs))}for(var gs=cs.children,hs=0,xs=gs.length;hs<xs;hs++)Io(gs[hs],ps,us)}}var zo=wo.context,Fo=wo.state,Bo=new De,Oo=new S,Go=Co.shadows,Vo=new T,Ho=new T(Uo.maxTextureSize,Uo.maxTextureSize),ko=new E,Wo=new E,Xo=[],Yo=1,jo=2,Zo=[,,,,],Qo=[,,,,],Jo={},Ko=[new E(1,0,0),new E(-1,0,0),new E(0,0,1),new E(0,0,-1),new E(0,1,0),new E(0,-1,0)],$o=[new E(0,1,0),new E(0,1,0),new E(0,1,0),new E(0,1,0),new E(0,0,1),new E(0,0,-1)],es=[new _e,new _e,new _e,new _e,new _e,new _e],ts=new Ae;ts.depthPacking=di,ts.clipping=!0;for(var rs=So.distanceRGBA,as=xi.clone(rs.uniforms),is=0;is!==(Yo|jo)+1;++is){var ns=0!==(is&Yo),os=0!==(is&jo),ss=ts.clone();ss.morphTargets=ns,ss.skinning=os,Zo[is]=ss;var ls=new Le({defines:{USE_SHADOWMAP:''},uniforms:as,vertexShader:rs.vertexShader,fragmentShader:rs.fragmentShader,morphTargets:ns,skinning:os,clipping:!0});Qo[is]=ls}var ds=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=tr,this.renderReverseSided=!0,this.renderSingleSided=!0,this.render=function(cs,ps){if(!1!==ds.enabled&&(!1!==ds.autoUpdate||!1!==ds.needsUpdate)&&0!==Go.length){Fo.buffers.color.setClear(1,1,1,1),Fo.disable(zo.BLEND),Fo.setDepthTest(!0),Fo.setScissorTest(!1);for(var fs=0,gs=Go.length,us,ms;fs<gs;fs++){var hs=Go[fs],xs=hs.shadow;if(void 0===xs){console.warn('THREE.WebGLShadowMap:',hs,'has no shadow.');continue}var _s=xs.camera;if(Vo.copy(xs.mapSize),Vo.min(Ho),hs&&hs.isPointLight){us=6,ms=!0;var vs=Vo.x,ys=Vo.y;es[0].set(2*vs,ys,vs,ys),es[1].set(0,ys,vs,ys),es[2].set(3*vs,ys,vs,ys),es[3].set(vs,ys,vs,ys),es[4].set(3*vs,0,vs,ys),es[5].set(vs,0,vs,ys),Vo.x*=4,Vo.y*=2}else us=1,ms=!1;if(null===xs.map){xs.map=new Me(Vo.x,Vo.y,{minFilter:oa,magFilter:oa,format:La}),_s.updateProjectionMatrix()}xs.isSpotLightShadow&&xs.update(hs),xs&&xs.isRectAreaLightShadow&&xs.update(hs);var bs=xs.map,Ss=xs.matrix;Wo.setFromMatrixPosition(hs.matrixWorld),_s.position.copy(Wo),wo.setRenderTarget(bs),wo.clear();for(var Ms=0;Ms<us;Ms++){if(ms){ko.copy(_s.position),ko.add(Ko[Ms]),_s.up.copy($o[Ms]),_s.lookAt(ko);var Ts=es[Ms];Fo.viewport(Ts)}else ko.setFromMatrixPosition(hs.target.matrixWorld),_s.lookAt(ko);_s.updateMatrixWorld(),_s.matrixWorldInverse.getInverse(_s.matrixWorld),Ss.set(0.5,0,0,0.5,0,0.5,0,0.5,0,0,0.5,0.5,0,0,0,1),Ss.multiply(_s.projectionMatrix),Ss.multiply(_s.matrixWorldInverse),Oo.multiplyMatrices(_s.projectionMatrix,_s.matrixWorldInverse),Bo.setFromMatrix(Oo),Xo.length=0,Io(cs,ps,_s);for(var Ls=0,As=Xo.length;Ls<As;Ls++){var Rs=Xo[Ls],Ps=Do.update(Rs),ws=Rs.material;if(ws&&ws.isMultiMaterial)for(var Cs=Ps.groups,Ds=ws.materials,Us=0,Ns=Cs.length;Us<Ns;Us++){var Is=Cs[Us],zs=Ds[Is.materialIndex];if(!0===zs.visible){var Fs=No(Rs,zs,ms,Wo);wo.renderBufferDirect(_s,null,Ps,Fs,Rs,Is)}}else{var Fs=No(Rs,ws,ms,Wo);wo.renderBufferDirect(_s,null,Ps,Fs,Rs,null)}}}}var Bs=wo.getClearColor(),Os=wo.getClearAlpha();wo.setClearColor(Bs,Os),ds.needsUpdate=!1}}}function Ne(wo,Co){this.origin=wo===void 0?new E:wo,this.direction=Co===void 0?new E:Co}function Ie(wo,Co,Do,Uo){this._x=wo||0,this._y=Co||0,this._z=Do||0,this._order=Uo||Ie.DefaultOrder}function ze(){this.mask=1}function Fe(){Object.defineProperty(this,'id',{value:To++}),this.uuid=ci.generateUUID(),this.name='',this.type='Object3D',this.parent=null,this.children=[],this.up=Fe.DefaultUp.clone();var Do=new E,Uo=new Ie,No=new _,Io=new E(1,1,1);Uo.onChange(function(){No.setFromEuler(Uo,!1)}),No.onChange(function(){Uo.setFromQuaternion(No,void 0,!1)}),Object.defineProperties(this,{position:{enumerable:!0,value:Do},rotation:{enumerable:!0,value:Uo},quaternion:{enumerable:!0,value:No},scale:{enumerable:!0,value:Io},modelViewMatrix:{value:new S},normalMatrix:{value:new we}}),this.matrix=new S,this.matrixWorld=new S,this.matrixAutoUpdate=Fe.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new ze,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.userData={},this.onBeforeRender=function(){},this.onAfterRender=function(){}}function Be(wo,Co){this.start=wo===void 0?new E:wo,this.end=Co===void 0?new E:Co}function Oe(wo,Co,Do){this.a=wo===void 0?new E:wo,this.b=Co===void 0?new E:Co,this.c=Do===void 0?new E:Do}function Ge(wo,Co,Do,Uo,No,Io){this.a=wo,this.b=Co,this.c=Do,this.normal=Uo&&Uo.isVector3?Uo:new E,this.vertexNormals=Array.isArray(Uo)?Uo:[],this.color=No&&No.isColor?No:new ve,this.vertexColors=Array.isArray(No)?No:[],this.materialIndex=Io===void 0?0:Io}function Ve(wo){Te.call(this),this.type='MeshBasicMaterial',this.color=new ve(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Vr,this.reflectivity=1,this.refractionRatio=0.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap='round',this.wireframeLinejoin='round',this.skinning=!1,this.morphTargets=!1,this.lights=!1,this.setValues(wo)}function He(wo,Co,Do){if(Array.isArray(wo))throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');this.uuid=ci.generateUUID(),this.array=wo,this.itemSize=Co,this.count=wo===void 0?0:wo.length/Co,this.normalized=!0===Do,this.dynamic=!1,this.updateRange={offset:0,count:-1},this.onUploadCallback=function(){},this.version=0}function ke(wo,Co){He.call(this,new Uint16Array(wo),Co)}function We(wo,Co){He.call(this,new Uint32Array(wo),Co)}function Xe(wo,Co){He.call(this,new Float32Array(wo),Co)}function Ye(){this.indices=[],this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.uvs2=[],this.groups=[],this.morphTargets={},this.skinWeights=[],this.skinIndices=[],this.boundingBox=null,this.boundingSphere=null,this.verticesNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.uvsNeedUpdate=!1,this.groupsNeedUpdate=!1}function je(wo){for(var Co=wo.length,Do=-Infinity;Co--;)wo[Co]>Do&&(Do=wo[Co]);return Do}function qe(){return Lo++}function Ze(){Object.defineProperty(this,'id',{value:qe()}),this.uuid=ci.generateUUID(),this.name='',this.type='Geometry',this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.elementsNeedUpdate=!1,this.verticesNeedUpdate=!1,this.uvsNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.lineDistancesNeedUpdate=!1,this.groupsNeedUpdate=!1}function Qe(){Object.defineProperty(this,'id',{value:qe()}),this.uuid=ci.generateUUID(),this.name='',this.type='BufferGeometry',this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:Infinity}}function Je(wo,Co){Fe.call(this),this.type='Mesh',this.geometry=wo===void 0?new Qe:wo,this.material=Co===void 0?new Ve({color:16777215*Math.random()}):Co,this.drawMode=Ja,this.updateMorphTargets()}function Ke(wo,Co,Do,Uo,No,Io){function zo(Wo,Xo,Yo,jo,qo,Zo,Qo,Jo,Ko,$o,es){var os=Ko+1,ls=0,ds=0,cs,ps,us=new E;for(ps=0;ps<$o+1;ps++){var ms=ps*(Qo/$o)-Qo/2;for(cs=0;cs<os;cs++){var fs=cs*(Zo/Ko)-Zo/2;us[Wo]=fs*jo,us[Xo]=ms*qo,us[Yo]=Jo/2,Oo.push(us.x,us.y,us.z),us[Wo]=0,us[Xo]=0,us[Yo]=0<Jo?1:-1,Go.push(us.x,us.y,us.z),Vo.push(cs/Ko),Vo.push(1-ps/$o),ls+=1}}for(ps=0;ps<$o;ps++)for(cs=0;cs<Ko;cs++){var gs=Ho+cs+os*ps,hs=Ho+cs+os*(ps+1),xs=Ho+(cs+1)+os*(ps+1),_s=Ho+(cs+1)+os*ps;Bo.push(gs,hs,_s),Bo.push(hs,xs,_s),ds+=6}Fo.addGroup(ko,ds,es),ko+=ds,Ho+=ls}Qe.call(this),this.type='BoxBufferGeometry',this.parameters={width:wo,height:Co,depth:Do,widthSegments:Uo,heightSegments:No,depthSegments:Io};var Fo=this;Uo=Math.floor(Uo)||1,No=Math.floor(No)||1,Io=Math.floor(Io)||1;var Bo=[],Oo=[],Go=[],Vo=[],Ho=0,ko=0;zo('z','y','x',-1,-1,Do,Co,wo,Io,No,0),zo('z','y','x',1,-1,Do,Co,-wo,Io,No,1),zo('x','z','y',1,1,wo,Do,Co,Uo,Io,2),zo('x','z','y',1,-1,wo,Do,-Co,Uo,Io,3),zo('x','y','z',1,-1,wo,Co,Do,Uo,No,4),zo('x','y','z',-1,-1,wo,Co,-Do,Uo,No,5),this.setIndex(Bo),this.addAttribute('position',new Xe(Oo,3)),this.addAttribute('normal',new Xe(Go,3)),this.addAttribute('uv',new Xe(Vo,2))}function $e(wo,Co,Do,Uo){Qe.call(this),this.type='PlaneBufferGeometry',this.parameters={width:wo,height:Co,widthSegments:Do,heightSegments:Uo};var zo=Math.floor(Do)||1,Fo=Math.floor(Uo)||1,Bo=zo+1,Ho,ko,Wo=[],Xo=[],Yo=[],jo=[];for(ko=0;ko<Fo+1;ko++){var qo=ko*(Co/Fo)-Co/2;for(Ho=0;Ho<Bo;Ho++){var Zo=Ho*(wo/zo)-wo/2;Xo.push(Zo,-qo,0),Yo.push(0,0,1),jo.push(Ho/zo),jo.push(1-ko/Fo)}}for(ko=0;ko<Fo;ko++)for(Ho=0;Ho<zo;Ho++){var Qo=Ho+Bo*ko,Jo=Ho+Bo*(ko+1),Ko=Ho+1+Bo*(ko+1),$o=Ho+1+Bo*ko;Wo.push(Qo,Jo,$o),Wo.push(Jo,Ko,$o)}this.setIndex(Wo),this.addAttribute('position',new Xe(Xo,3)),this.addAttribute('normal',new Xe(Yo,3)),this.addAttribute('uv',new Xe(jo,2))}function et(){Fe.call(this),this.type='Camera',this.matrixWorldInverse=new S,this.projectionMatrix=new S}function tt(wo,Co,Do,Uo){et.call(this),this.type='PerspectiveCamera',this.fov=wo===void 0?50:wo,this.zoom=1,this.near=Do===void 0?0.1:Do,this.far=Uo===void 0?2e3:Uo,this.focus=10,this.aspect=Co===void 0?1:Co,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}function rt(wo,Co,Do,Uo,No,Io){et.call(this),this.type='OrthographicCamera',this.zoom=1,this.view=null,this.left=wo,this.right=Co,this.top=Do,this.bottom=Uo,this.near=No===void 0?0.1:No,this.far=Io===void 0?2e3:Io,this.updateProjectionMatrix()}function at(wo,Co,Do){var Fo,Bo,Oo;return{setMode:function(Go){Fo=Go},setIndex:function(Go){Go.array instanceof Uint32Array&&Co.get('OES_element_index_uint')?(Bo=wo.UNSIGNED_INT,Oo=4):Go.array instanceof Uint16Array?(Bo=wo.UNSIGNED_SHORT,Oo=2):(Bo=wo.UNSIGNED_BYTE,Oo=1)},render:function(Go,Vo){wo.drawElements(Fo,Vo,Bo,Go*Oo),Do.calls++,Do.vertices+=Vo,Fo===wo.TRIANGLES&&(Do.faces+=Vo/3)},renderInstances:function(Go,Vo,Ho){var ko=Co.get('ANGLE_instanced_arrays');return null===ko?void console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.'):void(ko.drawElementsInstancedANGLE(Fo,Ho,Bo,Vo*Oo,Go.maxInstancedCount),Do.calls++,Do.vertices+=Ho*Go.maxInstancedCount,Fo===wo.TRIANGLES&&(Do.faces+=Go.maxInstancedCount*Ho/3))}}}function it(wo,Co,Do){var zo;return{setMode:function(Fo){zo=Fo},render:function(Fo,Bo){wo.drawArrays(zo,Fo,Bo),Do.calls++,Do.vertices+=Bo,zo===wo.TRIANGLES&&(Do.faces+=Bo/3)},renderInstances:function(Fo){var Bo=Co.get('ANGLE_instanced_arrays');if(null===Bo)return void console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');var Oo=Fo.attributes.position,Go=0;Oo.isInterleavedBufferAttribute?(Go=Oo.data.count,Bo.drawArraysInstancedANGLE(zo,0,Go,Fo.maxInstancedCount)):(Go=Oo.count,Bo.drawArraysInstancedANGLE(zo,0,Go,Fo.maxInstancedCount)),Do.calls++,Do.vertices+=Go*Fo.maxInstancedCount,zo===wo.TRIANGLES&&(Do.faces+=Fo.maxInstancedCount*Go/3)}}}function nt(){var wo={};return{get:function(Co){if(void 0!==wo[Co.id])return wo[Co.id];var Do;switch(Co.type){case'DirectionalLight':Do={direction:new E,color:new ve,shadow:!1,shadowBias:0,shadowRadius:1,shadowMapSize:new T};break;case'SpotLight':Do={position:new E,direction:new E,color:new ve,distance:0,coneCos:0,penumbraCos:0,decay:0,shadow:!1,shadowBias:0,shadowRadius:1,shadowMapSize:new T};break;case'PointLight':Do={position:new E,color:new ve,distance:0,decay:0,shadow:!1,shadowBias:0,shadowRadius:1,shadowMapSize:new T};break;case'HemisphereLight':Do={direction:new E,skyColor:new ve,groundColor:new ve};break;case'RectAreaLight':Do={color:new ve,position:new E,halfWidth:new E,halfHeight:new E};}return wo[Co.id]=Do,Do}}}function ot(wo){for(var Co=wo.split('\n'),Do=0;Do<Co.length;Do++)Co[Do]=Do+1+': '+Co[Do];return Co.join('\n')}function st(wo,Co,Do){var Uo=wo.createShader(Co);return wo.shaderSource(Uo,Do),wo.compileShader(Uo),!1===wo.getShaderParameter(Uo,wo.COMPILE_STATUS)&&console.error('THREE.WebGLShader: Shader couldn\'t compile.'),''!==wo.getShaderInfoLog(Uo)&&console.warn('THREE.WebGLShader: gl.getShaderInfoLog()',Co===wo.VERTEX_SHADER?'vertex':'fragment',wo.getShaderInfoLog(Uo),ot(Do)),Uo}function lt(wo){switch(wo){case ei:return['Linear','( value )'];case ti:return['sRGB','( value )'];case ai:return['RGBE','( value )'];case ni:return['RGBM','( value, 7.0 )'];case oi:return['RGBM','( value, 16.0 )'];case si:return['RGBD','( value, 256.0 )'];case ri:return['Gamma','( value, float( GAMMA_FACTOR ) )'];default:throw new Error('unsupported encoding: '+wo);}}function dt(wo,Co){var Do=lt(Co);return'vec4 '+wo+'( vec4 value ) { return '+Do[0]+'ToLinear'+Do[1]+'; }'}function ct(wo,Co){var Do=lt(Co);return'vec4 '+wo+'( vec4 value ) { return LinearTo'+Do[0]+Do[1]+'; }'}function pt(wo,Co){var Do;switch(Co){case Xr:Do='Linear';break;case Yr:Do='Reinhard';break;case jr:Do='Uncharted2';break;case qr:Do='OptimizedCineon';break;default:throw new Error('unsupported toneMapping: '+Co);}return'vec3 '+wo+'( vec3 color ) { return '+Do+'ToneMapping( color ); }'}function ut(wo,Co,Do){wo=wo||{};var Uo=[wo.derivatives||Co.envMapCubeUV||Co.bumpMap||Co.normalMap||Co.flatShading?'#extension GL_OES_standard_derivatives : enable':'',(wo.fragDepth||Co.logarithmicDepthBuffer)&&Do.get('EXT_frag_depth')?'#extension GL_EXT_frag_depth : enable':'',wo.drawBuffers&&Do.get('WEBGL_draw_buffers')?'#extension GL_EXT_draw_buffers : require':'',(wo.shaderTextureLOD||Co.envMap)&&Do.get('EXT_shader_texture_lod')?'#extension GL_EXT_shader_texture_lod : enable':''];return Uo.filter(gt).join('\n')}function mt(wo){var Co=[];for(var Do in wo){var Uo=wo[Do];!1===Uo||Co.push('#define '+Do+' '+Uo)}return Co.join('\n')}function ft(wo,Co){for(var Uo={},No=wo.getProgramParameter(Co,wo.ACTIVE_ATTRIBUTES),Io=0;Io<No;Io++){var zo=wo.getActiveAttrib(Co,Io),Fo=zo.name;Uo[Fo]=wo.getAttribLocation(Co,Fo)}return Uo}function gt(wo){return''!==wo}function ht(wo,Co){return wo.replace(/NUM_DIR_LIGHTS/g,Co.numDirLights).replace(/NUM_SPOT_LIGHTS/g,Co.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,Co.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,Co.numPointLights).replace(/NUM_HEMI_LIGHTS/g,Co.numHemiLights)}function xt(wo){var Do=/#include +<([\w\d.]+)>/g;return wo.replace(Do,function(Uo,No){var Io=yo[No];if(Io===void 0)throw new Error('Can not resolve #include <'+No+'>');return xt(Io)})}function _t(wo){var Do=/for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;return wo.replace(Do,function(Uo,No,Io,zo){for(var Fo='',Bo=parseInt(No);Bo<parseInt(Io);Bo++)Fo+=zo.replace(/\[ i \]/g,'[ '+Bo+' ]');return Fo})}function vt(wo,Co,Do,Uo){var No=wo.context,Io=Do.extensions,zo=Do.defines,Fo=Do.__webglShader.vertexShader,Bo=Do.__webglShader.fragmentShader,Oo='SHADOWMAP_TYPE_BASIC';Uo.shadowMapType===tr?Oo='SHADOWMAP_TYPE_PCF':Uo.shadowMapType===rr&&(Oo='SHADOWMAP_TYPE_PCF_SOFT');var Go='ENVMAP_TYPE_CUBE',Vo='ENVMAP_MODE_REFLECTION',Ho='ENVMAP_BLENDING_MULTIPLY';if(Uo.envMap){switch(Do.envMap.mapping){case Qr:case Jr:Go='ENVMAP_TYPE_CUBE';break;case ta:case ra:Go='ENVMAP_TYPE_CUBE_UV';break;case Kr:case $r:Go='ENVMAP_TYPE_EQUIREC';break;case ea:Go='ENVMAP_TYPE_SPHERE';}switch(Do.envMap.mapping){case Jr:case $r:Vo='ENVMAP_MODE_REFRACTION';}switch(Do.combine){case Vr:Ho='ENVMAP_BLENDING_MULTIPLY';break;case Hr:Ho='ENVMAP_BLENDING_MIX';break;case kr:Ho='ENVMAP_BLENDING_ADD';}}var ko=0<wo.gammaFactor?wo.gammaFactor:1,Wo=ut(Io,Uo,wo.extensions),Xo=mt(zo),Yo=No.createProgram(),jo,qo;Do.isRawShaderMaterial?(jo=[Xo,'\n'].filter(gt).join('\n'),qo=[Wo,Xo,'\n'].filter(gt).join('\n')):(jo=['precision '+Uo.precision+' float;','precision '+Uo.precision+' int;','#define SHADER_NAME '+Do.__webglShader.name,Xo,Uo.supportsVertexTextures?'#define VERTEX_TEXTURES':'','#define GAMMA_FACTOR '+ko,'#define MAX_BONES '+Uo.maxBones,Uo.useFog&&Uo.fog?'#define USE_FOG':'',Uo.useFog&&Uo.fogExp?'#define FOG_EXP2':'',Uo.map?'#define USE_MAP':'',Uo.envMap?'#define USE_ENVMAP':'',Uo.envMap?'#define '+Vo:'',Uo.lightMap?'#define USE_LIGHTMAP':'',Uo.aoMap?'#define USE_AOMAP':'',Uo.emissiveMap?'#define USE_EMISSIVEMAP':'',Uo.bumpMap?'#define USE_BUMPMAP':'',Uo.normalMap?'#define USE_NORMALMAP':'',Uo.displacementMap&&Uo.supportsVertexTextures?'#define USE_DISPLACEMENTMAP':'',Uo.specularMap?'#define USE_SPECULARMAP':'',Uo.roughnessMap?'#define USE_ROUGHNESSMAP':'',Uo.metalnessMap?'#define USE_METALNESSMAP':'',Uo.alphaMap?'#define USE_ALPHAMAP':'',Uo.vertexColors?'#define USE_COLOR':'',Uo.flatShading?'#define FLAT_SHADED':'',Uo.skinning?'#define USE_SKINNING':'',Uo.useVertexTexture?'#define BONE_TEXTURE':'',Uo.morphTargets?'#define USE_MORPHTARGETS':'',Uo.morphNormals&&!1===Uo.flatShading?'#define USE_MORPHNORMALS':'',Uo.doubleSided?'#define DOUBLE_SIDED':'',Uo.flipSided?'#define FLIP_SIDED':'','#define NUM_CLIPPING_PLANES '+Uo.numClippingPlanes,Uo.shadowMapEnabled?'#define USE_SHADOWMAP':'',Uo.shadowMapEnabled?'#define '+Oo:'',Uo.sizeAttenuation?'#define USE_SIZEATTENUATION':'',Uo.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',Uo.logarithmicDepthBuffer&&wo.extensions.get('EXT_frag_depth')?'#define USE_LOGDEPTHBUF_EXT':'','uniform mat4 modelMatrix;','uniform mat4 modelViewMatrix;','uniform mat4 projectionMatrix;','uniform mat4 viewMatrix;','uniform mat3 normalMatrix;','uniform vec3 cameraPosition;','attribute vec3 position;','attribute vec3 normal;','attribute vec2 uv;','#ifdef USE_COLOR','\tattribute vec3 color;','#endif','#ifdef USE_MORPHTARGETS','\tattribute vec3 morphTarget0;','\tattribute vec3 morphTarget1;','\tattribute vec3 morphTarget2;','\tattribute vec3 morphTarget3;','\t#ifdef USE_MORPHNORMALS','\t\tattribute vec3 morphNormal0;','\t\tattribute vec3 morphNormal1;','\t\tattribute vec3 morphNormal2;','\t\tattribute vec3 morphNormal3;','\t#else','\t\tattribute vec3 morphTarget4;','\t\tattribute vec3 morphTarget5;','\t\tattribute vec3 morphTarget6;','\t\tattribute vec3 morphTarget7;','\t#endif','#endif','#ifdef USE_SKINNING','\tattribute vec4 skinIndex;','\tattribute vec4 skinWeight;','#endif','\n'].filter(gt).join('\n'),qo=[Wo,'precision '+Uo.precision+' float;','precision '+Uo.precision+' int;','#define SHADER_NAME '+Do.__webglShader.name,Xo,Uo.alphaTest?'#define ALPHATEST '+Uo.alphaTest:'','#define GAMMA_FACTOR '+ko,Uo.useFog&&Uo.fog?'#define USE_FOG':'',Uo.useFog&&Uo.fogExp?'#define FOG_EXP2':'',Uo.map?'#define USE_MAP':'',Uo.envMap?'#define USE_ENVMAP':'',Uo.envMap?'#define '+Go:'',Uo.envMap?'#define '+Vo:'',Uo.envMap?'#define '+Ho:'',Uo.lightMap?'#define USE_LIGHTMAP':'',Uo.aoMap?'#define USE_AOMAP':'',Uo.emissiveMap?'#define USE_EMISSIVEMAP':'',Uo.bumpMap?'#define USE_BUMPMAP':'',Uo.normalMap?'#define USE_NORMALMAP':'',Uo.specularMap?'#define USE_SPECULARMAP':'',Uo.roughnessMap?'#define USE_ROUGHNESSMAP':'',Uo.metalnessMap?'#define USE_METALNESSMAP':'',Uo.alphaMap?'#define USE_ALPHAMAP':'',Uo.vertexColors?'#define USE_COLOR':'',Uo.gradientMap?'#define USE_GRADIENTMAP':'',Uo.flatShading?'#define FLAT_SHADED':'',Uo.doubleSided?'#define DOUBLE_SIDED':'',Uo.flipSided?'#define FLIP_SIDED':'','#define NUM_CLIPPING_PLANES '+Uo.numClippingPlanes,'#define UNION_CLIPPING_PLANES '+(Uo.numClippingPlanes-Uo.numClipIntersection),Uo.shadowMapEnabled?'#define USE_SHADOWMAP':'',Uo.shadowMapEnabled?'#define '+Oo:'',Uo.premultipliedAlpha?'#define PREMULTIPLIED_ALPHA':'',Uo.physicallyCorrectLights?'#define PHYSICALLY_CORRECT_LIGHTS':'',Uo.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',Uo.logarithmicDepthBuffer&&wo.extensions.get('EXT_frag_depth')?'#define USE_LOGDEPTHBUF_EXT':'',Uo.envMap&&wo.extensions.get('EXT_shader_texture_lod')?'#define TEXTURE_LOD_EXT':'','uniform mat4 viewMatrix;','uniform vec3 cameraPosition;',Uo.toneMapping===Wr?'':'#define TONE_MAPPING',Uo.toneMapping===Wr?'':yo.tonemapping_pars_fragment,Uo.toneMapping===Wr?'':pt('toneMapping',Uo.toneMapping),Uo.outputEncoding||Uo.mapEncoding||Uo.envMapEncoding||Uo.emissiveMapEncoding?yo.encodings_pars_fragment:'',Uo.mapEncoding?dt('mapTexelToLinear',Uo.mapEncoding):'',Uo.envMapEncoding?dt('envMapTexelToLinear',Uo.envMapEncoding):'',Uo.emissiveMapEncoding?dt('emissiveMapTexelToLinear',Uo.emissiveMapEncoding):'',Uo.outputEncoding?ct('linearToOutputTexel',Uo.outputEncoding):'',Uo.depthPacking?'#define DEPTH_PACKING '+Do.depthPacking:'','\n'].filter(gt).join('\n')),Fo=xt(Fo,Uo),Fo=ht(Fo,Uo),Bo=xt(Bo,Uo),Bo=ht(Bo,Uo),Do.isShaderMaterial||(Fo=_t(Fo),Bo=_t(Bo));var Zo=jo+Fo,Qo=qo+Bo,Jo=st(No,No.VERTEX_SHADER,Zo),Ko=st(No,No.FRAGMENT_SHADER,Qo);No.attachShader(Yo,Jo),No.attachShader(Yo,Ko),void 0===Do.index0AttributeName?!0===Uo.morphTargets&&No.bindAttribLocation(Yo,0,'position'):No.bindAttribLocation(Yo,0,Do.index0AttributeName),No.linkProgram(Yo);var $o=No.getProgramInfoLog(Yo),es=No.getShaderInfoLog(Jo),ts=No.getShaderInfoLog(Ko),rs=!0,as=!0;!1===No.getProgramParameter(Yo,No.LINK_STATUS)?(rs=!1,console.error('THREE.WebGLProgram: shader error: ',No.getError(),'gl.VALIDATE_STATUS',No.getProgramParameter(Yo,No.VALIDATE_STATUS),'gl.getProgramInfoLog',$o,es,ts)):''===$o?(''===es||''===ts)&&(as=!1):console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()',$o),as&&(this.diagnostics={runnable:rs,material:Do,programLog:$o,vertexShader:{log:es,prefix:jo},fragmentShader:{log:ts,prefix:qo}}),No.deleteShader(Jo),No.deleteShader(Ko);var is;this.getUniforms=function(){return void 0===is&&(is=new xe(No,Yo,wo)),is};var ns;return this.getAttributes=function(){return void 0===ns&&(ns=ft(No,Yo)),ns},this.destroy=function(){No.deleteProgram(Yo),this.program=void 0},Object.defineProperties(this,{uniforms:{get:function(){return console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().'),this.getUniforms()}},attributes:{get:function(){return console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().'),this.getAttributes()}}}),this.id=Ao++,this.code=Co,this.usedTimes=1,this.program=Yo,this.vertexShader=Jo,this.fragmentShader=Ko,this}function yt(wo,Co){function Do(Fo){if(Co.floatVertexTextures&&Fo&&Fo.skeleton&&Fo.skeleton.useVertexTexture)return 1024;var Bo=Co.maxVertexUniforms,Oo=Math.floor((Bo-20)/4),Go=Oo;return void 0!==Fo&&Fo&&Fo.isSkinnedMesh&&(Go=Math.min(Fo.skeleton.bones.length,Go),Go<Fo.skeleton.bones.length&&console.warn('WebGLRenderer: too many bones - '+Fo.skeleton.bones.length+', this GPU supports just '+Go+' (try OpenGL instead of ANGLE)')),Go}function Uo(Fo,Bo){var Oo;return Fo?Fo.isTexture?Oo=Fo.encoding:Fo.isWebGLRenderTarget&&(console.warn('THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.'),Oo=Fo.texture.encoding):Oo=ei,Oo===ei&&Bo&&(Oo=ri),Oo}var No=[],Io={MeshDepthMaterial:'depth',MeshNormalMaterial:'normal',MeshBasicMaterial:'basic',MeshLambertMaterial:'lambert',MeshPhongMaterial:'phong',MeshToonMaterial:'phong',MeshStandardMaterial:'physical',MeshPhysicalMaterial:'physical',LineBasicMaterial:'basic',LineDashedMaterial:'dashed',PointsMaterial:'points'},zo=['precision','supportsVertexTextures','map','mapEncoding','envMap','envMapMode','envMapEncoding','lightMap','aoMap','emissiveMap','emissiveMapEncoding','bumpMap','normalMap','displacementMap','specularMap','roughnessMap','metalnessMap','gradientMap','alphaMap','combine','vertexColors','fog','useFog','fogExp','flatShading','sizeAttenuation','logarithmicDepthBuffer','skinning','maxBones','useVertexTexture','morphTargets','morphNormals','maxMorphTargets','maxMorphNormals','premultipliedAlpha','numDirLights','numPointLights','numSpotLights','numHemiLights','numRectAreaLights','shadowMapEnabled','shadowMapType','toneMapping','physicallyCorrectLights','alphaTest','doubleSided','flipSided','numClippingPlanes','numClipIntersection','depthPacking'];this.getParameters=function(Fo,Bo,Oo,Go,Vo,Ho){var ko=Io[Fo.type],Wo=Do(Ho),Xo=wo.getPrecision();null!==Fo.precision&&(Xo=Co.getMaxPrecision(Fo.precision),Xo!==Fo.precision&&console.warn('THREE.WebGLProgram.getParameters:',Fo.precision,'not supported, using',Xo,'instead.'));var Yo=wo.getCurrentRenderTarget(),jo={shaderID:ko,precision:Xo,supportsVertexTextures:Co.vertexTextures,outputEncoding:Uo(Yo?Yo.texture:null,wo.gammaOutput),map:!!Fo.map,mapEncoding:Uo(Fo.map,wo.gammaInput),envMap:!!Fo.envMap,envMapMode:Fo.envMap&&Fo.envMap.mapping,envMapEncoding:Uo(Fo.envMap,wo.gammaInput),envMapCubeUV:!!Fo.envMap&&(Fo.envMap.mapping===ta||Fo.envMap.mapping===ra),lightMap:!!Fo.lightMap,aoMap:!!Fo.aoMap,emissiveMap:!!Fo.emissiveMap,emissiveMapEncoding:Uo(Fo.emissiveMap,wo.gammaInput),bumpMap:!!Fo.bumpMap,normalMap:!!Fo.normalMap,displacementMap:!!Fo.displacementMap,roughnessMap:!!Fo.roughnessMap,metalnessMap:!!Fo.metalnessMap,specularMap:!!Fo.specularMap,alphaMap:!!Fo.alphaMap,gradientMap:!!Fo.gradientMap,combine:Fo.combine,vertexColors:Fo.vertexColors,fog:!!Oo,useFog:Fo.fog,fogExp:Oo&&Oo.isFogExp2,flatShading:Fo.shading===or,sizeAttenuation:Fo.sizeAttenuation,logarithmicDepthBuffer:Co.logarithmicDepthBuffer,skinning:Fo.skinning,maxBones:Wo,useVertexTexture:Co.floatVertexTextures&&Ho&&Ho.skeleton&&Ho.skeleton.useVertexTexture,morphTargets:Fo.morphTargets,morphNormals:Fo.morphNormals,maxMorphTargets:wo.maxMorphTargets,maxMorphNormals:wo.maxMorphNormals,numDirLights:Bo.directional.length,numPointLights:Bo.point.length,numSpotLights:Bo.spot.length,numRectAreaLights:Bo.rectArea.length,numHemiLights:Bo.hemi.length,numClippingPlanes:Go,numClipIntersection:Vo,shadowMapEnabled:wo.shadowMap.enabled&&Ho.receiveShadow&&0<Bo.shadows.length,shadowMapType:wo.shadowMap.type,toneMapping:wo.toneMapping,physicallyCorrectLights:wo.physicallyCorrectLights,premultipliedAlpha:Fo.premultipliedAlpha,alphaTest:Fo.alphaTest,doubleSided:Fo.side===nr,flipSided:Fo.side===ir,depthPacking:Fo.depthPacking!==void 0&&Fo.depthPacking};return jo},this.getProgramCode=function(Fo,Bo){var Oo=[];if(Bo.shaderID?Oo.push(Bo.shaderID):(Oo.push(Fo.fragmentShader),Oo.push(Fo.vertexShader)),void 0!==Fo.defines)for(var Go in Fo.defines)Oo.push(Go),Oo.push(Fo.defines[Go]);for(var Vo=0;Vo<zo.length;Vo++)Oo.push(Bo[zo[Vo]]);return Oo.join()},this.acquireProgram=function(Fo,Bo,Oo){for(var Vo=0,Ho=No.length,Go,ko;Vo<Ho;Vo++)if(ko=No[Vo],ko.code===Oo){Go=ko,++Go.usedTimes;break}return void 0===Go&&(Go=new vt(wo,Oo,Fo,Bo),No.push(Go)),Go},this.releaseProgram=function(Fo){if(0===--Fo.usedTimes){var Bo=No.indexOf(Fo);No[Bo]=No[No.length-1],No.pop(),Fo.destroy()}},this.programs=No}function Et(wo,Co,Do){function Uo(Oo){var Go=Oo.target,Vo=Bo[Go.id];null!==Vo.index&&Io(Vo.index),zo(Vo.attributes),Go.removeEventListener('dispose',Uo),delete Bo[Go.id];var Ho=Co.get(Go);Ho.wireframe&&Io(Ho.wireframe),Co.delete(Go);var ko=Co.get(Vo);ko.wireframe&&Io(ko.wireframe),Co.delete(Vo),Do.memory.geometries--}function No(Oo){return Oo.isInterleavedBufferAttribute?Co.get(Oo.data).__webglBuffer:Co.get(Oo).__webglBuffer}function Io(Oo){var Go=No(Oo);Go!==void 0&&(wo.deleteBuffer(Go),Fo(Oo))}function zo(Oo){for(var Go in Oo)Io(Oo[Go])}function Fo(Oo){Oo.isInterleavedBufferAttribute?Co.delete(Oo.data):Co.delete(Oo)}var Bo={};return{get:function(Oo){var Go=Oo.geometry;if(void 0!==Bo[Go.id])return Bo[Go.id];Go.addEventListener('dispose',Uo);var Vo;return Go.isBufferGeometry?Vo=Go:Go.isGeometry&&(void 0===Go._bufferGeometry&&(Go._bufferGeometry=new Qe().setFromObject(Oo)),Vo=Go._bufferGeometry),Bo[Go.id]=Vo,Do.memory.geometries++,Vo}}}function bt(wo,Co,Do){function No(Vo,Ho){var ko=Vo.isInterleavedBufferAttribute?Vo.data:Vo,Wo=Co.get(ko);Wo.__webglBuffer===void 0?Io(Wo,ko,Ho):Wo.version!==ko.version&&zo(Wo,ko,Ho)}function Io(Vo,Ho,ko){Vo.__webglBuffer=wo.createBuffer(),wo.bindBuffer(ko,Vo.__webglBuffer);var Wo=Ho.dynamic?wo.DYNAMIC_DRAW:wo.STATIC_DRAW;wo.bufferData(ko,Ho.array,Wo);var Xo=wo.FLOAT,Yo=Ho.array;Yo instanceof Float32Array?Xo=wo.FLOAT:Yo instanceof Float64Array?console.warn('Unsupported data buffer format: Float64Array'):Yo instanceof Uint16Array?Xo=wo.UNSIGNED_SHORT:Yo instanceof Int16Array?Xo=wo.SHORT:Yo instanceof Uint32Array?Xo=wo.UNSIGNED_INT:Yo instanceof Int32Array?Xo=wo.INT:Yo instanceof Int8Array?Xo=wo.BYTE:Yo instanceof Uint8Array&&(Xo=wo.UNSIGNED_BYTE),Vo.bytesPerElement=Yo.BYTES_PER_ELEMENT,Vo.type=Xo,Vo.version=Ho.version,Ho.onUploadCallback()}function zo(Vo,Ho,ko){wo.bindBuffer(ko,Vo.__webglBuffer),!1===Ho.dynamic?wo.bufferData(ko,Ho.array,wo.STATIC_DRAW):-1===Ho.updateRange.count?wo.bufferSubData(ko,0,Ho.array):0===Ho.updateRange.count?console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.'):(wo.bufferSubData(ko,Ho.updateRange.offset*Ho.array.BYTES_PER_ELEMENT,Ho.array.subarray(Ho.updateRange.offset,Ho.updateRange.offset+Ho.updateRange.count)),Ho.updateRange.count=0),Vo.version=Ho.version}var Go=new Et(wo,Co,Do);return{getAttributeBuffer:function(Vo){return Vo.isInterleavedBufferAttribute?Co.get(Vo.data).__webglBuffer:Co.get(Vo).__webglBuffer},getAttributeProperties:function(Vo){return Vo.isInterleavedBufferAttribute?Co.get(Vo.data):Co.get(Vo)},getWireframeAttribute:function(Vo){var Ho=Co.get(Vo);if(void 0!==Ho.wireframe)return Ho.wireframe;var ko=[],Wo=Vo.index,Xo=Vo.attributes;if(null!==Wo)for(var Yo=Wo.array,jo=0,qo=Yo.length;jo<qo;jo+=3){var Zo=Yo[jo+0],Qo=Yo[jo+1],Jo=Yo[jo+2];ko.push(Zo,Qo,Qo,Jo,Jo,Zo)}else for(var Yo=Xo.position.array,jo=0,qo=Yo.length/3-1;jo<qo;jo+=3){var Zo=jo+0,Qo=jo+1,Jo=jo+2;ko.push(Zo,Qo,Qo,Jo,Jo,Zo)}var Ko=new(65535<je(ko)?We:ke)(ko,1);return No(Ko,wo.ELEMENT_ARRAY_BUFFER),Ho.wireframe=Ko,Ko},update:function(Vo){var Ho=Go.get(Vo);Vo.geometry.isGeometry&&Ho.updateFromObject(Vo);var ko=Ho.index,Wo=Ho.attributes;for(var Xo in null!==ko&&No(ko,wo.ELEMENT_ARRAY_BUFFER),Wo)No(Wo[Xo],wo.ARRAY_BUFFER);var Yo=Ho.morphAttributes;for(var Xo in Yo)for(var jo=Yo[Xo],qo=0,Zo=jo.length;qo<Zo;qo++)No(jo[qo],wo.ARRAY_BUFFER);return Ho}}}function St(wo,Co,Do,Uo,No,Io,zo){function Fo(ns,os){if(ns.width>os||ns.height>os){var ss=os/Math.max(ns.width,ns.height),ls=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');ls.width=Math.floor(ns.width*ss),ls.height=Math.floor(ns.height*ss);var ds=ls.getContext('2d');return ds.drawImage(ns,0,0,ns.width,ns.height,0,0,ls.width,ls.height),console.warn('THREE.WebGLRenderer: image is too big ('+ns.width+'x'+ns.height+'). Resized to '+ls.width+'x'+ls.height,ns),ls}return ns}function Bo(ns){return ci.isPowerOfTwo(ns.width)&&ci.isPowerOfTwo(ns.height)}function Oo(ns){if(ns instanceof HTMLImageElement||ns instanceof HTMLCanvasElement){var os=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');os.width=ci.nearestPowerOfTwo(ns.width),os.height=ci.nearestPowerOfTwo(ns.height);var ss=os.getContext('2d');return ss.drawImage(ns,0,0,os.width,os.height),console.warn('THREE.WebGLRenderer: image is not power of two ('+ns.width+'x'+ns.height+'). Resized to '+os.width+'x'+os.height,ns),os}return ns}function Go(ns){return ns.wrapS!==ia||ns.wrapT!==ia||ns.minFilter!==oa&&ns.minFilter!==da}function Vo(ns){return ns===oa||ns===sa||ns===la?wo.NEAREST:wo.LINEAR}function Ho(ns){var os=ns.target;os.removeEventListener('dispose',Ho),Wo(os),as.textures--}function ko(ns){var os=ns.target;os.removeEventListener('dispose',ko),Xo(os),as.textures--}function Wo(ns){var os=Uo.get(ns);if(ns.image&&os.__image__webglTextureCube)wo.deleteTexture(os.__image__webglTextureCube);else{if(os.__webglInit===void 0)return;wo.deleteTexture(os.__webglTexture)}Uo.delete(ns)}function Xo(ns){var os=Uo.get(ns),ss=Uo.get(ns.texture);if(ns){if(void 0!==ss.__webglTexture&&wo.deleteTexture(ss.__webglTexture),ns.depthTexture&&ns.depthTexture.dispose(),ns.isWebGLRenderTargetCube)for(var ls=0;6>ls;ls++)wo.deleteFramebuffer(os.__webglFramebuffer[ls]),os.__webglDepthbuffer&&wo.deleteRenderbuffer(os.__webglDepthbuffer[ls]);else wo.deleteFramebuffer(os.__webglFramebuffer),os.__webglDepthbuffer&&wo.deleteRenderbuffer(os.__webglDepthbuffer);Uo.delete(ns.texture),Uo.delete(ns)}}function Yo(ns,os){var ss=Uo.get(ns);if(0<ns.version&&ss.__version!==ns.version){var ls=ns.image;if(ls===void 0)console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined',ns);else if(!1===ls.complete)console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete',ns);else return void Qo(ss,ns,os)}Do.activeTexture(wo.TEXTURE0+os),Do.bindTexture(wo.TEXTURE_2D,ss.__webglTexture)}function Zo(ns,os,ss){var ls;if(ss?(wo.texParameteri(ns,wo.TEXTURE_WRAP_S,Io(os.wrapS)),wo.texParameteri(ns,wo.TEXTURE_WRAP_T,Io(os.wrapT)),wo.texParameteri(ns,wo.TEXTURE_MAG_FILTER,Io(os.magFilter)),wo.texParameteri(ns,wo.TEXTURE_MIN_FILTER,Io(os.minFilter))):(wo.texParameteri(ns,wo.TEXTURE_WRAP_S,wo.CLAMP_TO_EDGE),wo.texParameteri(ns,wo.TEXTURE_WRAP_T,wo.CLAMP_TO_EDGE),(os.wrapS!==ia||os.wrapT!==ia)&&console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.',os),wo.texParameteri(ns,wo.TEXTURE_MAG_FILTER,Vo(os.magFilter)),wo.texParameteri(ns,wo.TEXTURE_MIN_FILTER,Vo(os.minFilter)),os.minFilter!==oa&&os.minFilter!==da&&console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.',os)),ls=Co.get('EXT_texture_filter_anisotropic'),ls){if(os.type===_a&&null===Co.get('OES_texture_float_linear'))return;if(os.type===va&&null===Co.get('OES_texture_half_float_linear'))return;(1<os.anisotropy||Uo.get(os).__currentAnisotropy)&&(wo.texParameterf(ns,ls.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(os.anisotropy,No.getMaxAnisotropy())),Uo.get(os).__currentAnisotropy=os.anisotropy)}}function Qo(ns,os,ss){ns.__webglInit===void 0&&(ns.__webglInit=!0,os.addEventListener('dispose',Ho),ns.__webglTexture=wo.createTexture(),as.textures++),Do.activeTexture(wo.TEXTURE0+ss),Do.bindTexture(wo.TEXTURE_2D,ns.__webglTexture),wo.pixelStorei(wo.UNPACK_FLIP_Y_WEBGL,os.flipY),wo.pixelStorei(wo.UNPACK_PREMULTIPLY_ALPHA_WEBGL,os.premultiplyAlpha),wo.pixelStorei(wo.UNPACK_ALIGNMENT,os.unpackAlignment);var ls=Fo(os.image,No.maxTextureSize);Go(os)&&!1===Bo(ls)&&(ls=Oo(ls));var ds=Bo(ls),cs=Io(os.format),ps=Io(os.type);Zo(wo.TEXTURE_2D,os,ds);var ms=os.mipmaps,us;if(os.isDepthTexture){var fs=wo.DEPTH_COMPONENT;if(os.type===_a){if(!is)throw new Error('Float Depth Texture only supported in WebGL2.0');fs=wo.DEPTH_COMPONENT32F}else is&&(fs=wo.DEPTH_COMPONENT16);os.format===wa&&fs===wo.DEPTH_COMPONENT&&os.type!==ga&&os.type!==xa&&(console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.'),os.type=ga,ps=Io(os.type)),os.format===Ca&&(fs=wo.DEPTH_STENCIL,os.type!==Sa&&(console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.'),os.type=Sa,ps=Io(os.type))),Do.texImage2D(wo.TEXTURE_2D,0,fs,ls.width,ls.height,0,cs,ps,null)}else if(os.isDataTexture){if(0<ms.length&&ds){for(var gs=0,hs=ms.length;gs<hs;gs++)us=ms[gs],Do.texImage2D(wo.TEXTURE_2D,gs,cs,us.width,us.height,0,cs,ps,us.data);os.generateMipmaps=!1}else Do.texImage2D(wo.TEXTURE_2D,0,cs,ls.width,ls.height,0,cs,ps,ls.data);}else if(os.isCompressedTexture)for(var gs=0,hs=ms.length;gs<hs;gs++)us=ms[gs],os.format!==La&&os.format!==Ta?-1<Do.getCompressedTextureFormats().indexOf(cs)?Do.compressedTexImage2D(wo.TEXTURE_2D,gs,cs,us.width,us.height,0,us.data):console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'):Do.texImage2D(wo.TEXTURE_2D,gs,cs,us.width,us.height,0,cs,ps,us.data);else if(0<ms.length&&ds){for(var gs=0,hs=ms.length;gs<hs;gs++)us=ms[gs],Do.texImage2D(wo.TEXTURE_2D,gs,cs,cs,ps,us);os.generateMipmaps=!1}else Do.texImage2D(wo.TEXTURE_2D,0,cs,cs,ps,ls);os.generateMipmaps&&ds&&wo.generateMipmap(wo.TEXTURE_2D),ns.__version=os.version,os.onUpdate&&os.onUpdate(os)}function Jo(ns,os,ss,ls){var ds=Io(os.texture.format),cs=Io(os.texture.type);Do.texImage2D(ls,0,ds,os.width,os.height,0,ds,cs,null),wo.bindFramebuffer(wo.FRAMEBUFFER,ns),wo.framebufferTexture2D(wo.FRAMEBUFFER,ss,ls,Uo.get(os.texture).__webglTexture,0),wo.bindFramebuffer(wo.FRAMEBUFFER,null)}function Ko(ns,os){wo.bindRenderbuffer(wo.RENDERBUFFER,ns),os.depthBuffer&&!os.stencilBuffer?(wo.renderbufferStorage(wo.RENDERBUFFER,wo.DEPTH_COMPONENT16,os.width,os.height),wo.framebufferRenderbuffer(wo.FRAMEBUFFER,wo.DEPTH_ATTACHMENT,wo.RENDERBUFFER,ns)):os.depthBuffer&&os.stencilBuffer?(wo.renderbufferStorage(wo.RENDERBUFFER,wo.DEPTH_STENCIL,os.width,os.height),wo.framebufferRenderbuffer(wo.FRAMEBUFFER,wo.DEPTH_STENCIL_ATTACHMENT,wo.RENDERBUFFER,ns)):wo.renderbufferStorage(wo.RENDERBUFFER,wo.RGBA4,os.width,os.height),wo.bindRenderbuffer(wo.RENDERBUFFER,null)}function $o(ns,os){var ss=os&&os.isWebGLRenderTargetCube;if(ss)throw new Error('Depth Texture with cube render targets is not supported!');if(wo.bindFramebuffer(wo.FRAMEBUFFER,ns),!(os.depthTexture&&os.depthTexture.isDepthTexture))throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');Uo.get(os.depthTexture).__webglTexture&&os.depthTexture.image.width===os.width&&os.depthTexture.image.height===os.height||(os.depthTexture.image.width=os.width,os.depthTexture.image.height=os.height,os.depthTexture.needsUpdate=!0),Yo(os.depthTexture,0);var ls=Uo.get(os.depthTexture).__webglTexture;if(os.depthTexture.format===wa)wo.framebufferTexture2D(wo.FRAMEBUFFER,wo.DEPTH_ATTACHMENT,wo.TEXTURE_2D,ls,0);else if(os.depthTexture.format===Ca)wo.framebufferTexture2D(wo.FRAMEBUFFER,wo.DEPTH_STENCIL_ATTACHMENT,wo.TEXTURE_2D,ls,0);else throw new Error('Unknown depthTexture format')}function es(ns){var os=Uo.get(ns),ss=!0===ns.isWebGLRenderTargetCube;if(ns.depthTexture){if(ss)throw new Error('target.depthTexture not supported in Cube render targets');$o(os.__webglFramebuffer,ns)}else if(ss){os.__webglDepthbuffer=[];for(var ls=0;6>ls;ls++)wo.bindFramebuffer(wo.FRAMEBUFFER,os.__webglFramebuffer[ls]),os.__webglDepthbuffer[ls]=wo.createRenderbuffer(),Ko(os.__webglDepthbuffer[ls],ns)}else wo.bindFramebuffer(wo.FRAMEBUFFER,os.__webglFramebuffer),os.__webglDepthbuffer=wo.createRenderbuffer(),Ko(os.__webglDepthbuffer,ns);wo.bindFramebuffer(wo.FRAMEBUFFER,null)}var as=zo.memory,is='undefined'!==typeof WebGL2RenderingContext&&wo instanceof WebGL2RenderingContext;this.setTexture2D=Yo,this.setTextureCube=function(ns,os){var ss=Uo.get(ns);if(6===ns.image.length)if(0<ns.version&&ss.__version!==ns.version){ss.__image__webglTextureCube||(ns.addEventListener('dispose',Ho),ss.__image__webglTextureCube=wo.createTexture(),as.textures++),Do.activeTexture(wo.TEXTURE0+os),Do.bindTexture(wo.TEXTURE_CUBE_MAP,ss.__image__webglTextureCube),wo.pixelStorei(wo.UNPACK_FLIP_Y_WEBGL,ns.flipY);for(var ls=ns&&ns.isCompressedTexture,ds=ns.image[0]&&ns.image[0].isDataTexture,cs=[],ps=0;6>ps;ps++)cs[ps]=ls||ds?ds?ns.image[ps].image:ns.image[ps]:Fo(ns.image[ps],No.maxCubemapSize);var us=cs[0],ms=Bo(us),fs=Io(ns.format),gs=Io(ns.type);Zo(wo.TEXTURE_CUBE_MAP,ns,ms);for(var ps=0;6>ps;ps++)if(!ls)ds?Do.texImage2D(wo.TEXTURE_CUBE_MAP_POSITIVE_X+ps,0,fs,cs[ps].width,cs[ps].height,0,fs,gs,cs[ps].data):Do.texImage2D(wo.TEXTURE_CUBE_MAP_POSITIVE_X+ps,0,fs,fs,gs,cs[ps]);else for(var xs=cs[ps].mipmaps,_s=0,vs=xs.length,hs;_s<vs;_s++)hs=xs[_s],ns.format!==La&&ns.format!==Ta?-1<Do.getCompressedTextureFormats().indexOf(fs)?Do.compressedTexImage2D(wo.TEXTURE_CUBE_MAP_POSITIVE_X+ps,_s,fs,hs.width,hs.height,0,hs.data):console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()'):Do.texImage2D(wo.TEXTURE_CUBE_MAP_POSITIVE_X+ps,_s,fs,hs.width,hs.height,0,fs,gs,hs.data);ns.generateMipmaps&&ms&&wo.generateMipmap(wo.TEXTURE_CUBE_MAP),ss.__version=ns.version,ns.onUpdate&&ns.onUpdate(ns)}else Do.activeTexture(wo.TEXTURE0+os),Do.bindTexture(wo.TEXTURE_CUBE_MAP,ss.__image__webglTextureCube)},this.setTextureCubeDynamic=function(ns,os){Do.activeTexture(wo.TEXTURE0+os),Do.bindTexture(wo.TEXTURE_CUBE_MAP,Uo.get(ns).__webglTexture)},this.setupRenderTarget=function(ns){var os=Uo.get(ns),ss=Uo.get(ns.texture);ns.addEventListener('dispose',ko),ss.__webglTexture=wo.createTexture(),as.textures++;var ls=!0===ns.isWebGLRenderTargetCube,ds=Bo(ns);if(ls){os.__webglFramebuffer=[];for(var cs=0;6>cs;cs++)os.__webglFramebuffer[cs]=wo.createFramebuffer()}else os.__webglFramebuffer=wo.createFramebuffer();if(ls){Do.bindTexture(wo.TEXTURE_CUBE_MAP,ss.__webglTexture),Zo(wo.TEXTURE_CUBE_MAP,ns.texture,ds);for(var cs=0;6>cs;cs++)Jo(os.__webglFramebuffer[cs],ns,wo.COLOR_ATTACHMENT0,wo.TEXTURE_CUBE_MAP_POSITIVE_X+cs);ns.texture.generateMipmaps&&ds&&wo.generateMipmap(wo.TEXTURE_CUBE_MAP),Do.bindTexture(wo.TEXTURE_CUBE_MAP,null)}else Do.bindTexture(wo.TEXTURE_2D,ss.__webglTexture),Zo(wo.TEXTURE_2D,ns.texture,ds),Jo(os.__webglFramebuffer,ns,wo.COLOR_ATTACHMENT0,wo.TEXTURE_2D),ns.texture.generateMipmaps&&ds&&wo.generateMipmap(wo.TEXTURE_2D),Do.bindTexture(wo.TEXTURE_2D,null);ns.depthBuffer&&es(ns)},this.updateRenderTargetMipmap=function(ns){var os=ns.texture;if(os.generateMipmaps&&Bo(ns)&&os.minFilter!==oa&&os.minFilter!==da){var ss=ns&&ns.isWebGLRenderTargetCube?wo.TEXTURE_CUBE_MAP:wo.TEXTURE_2D,ls=Uo.get(os).__webglTexture;Do.bindTexture(ss,ls),wo.generateMipmap(ss),Do.bindTexture(ss,null)}}}function Mt(){var wo={};return{get:function(Co){var Do=Co.uuid,Uo=wo[Do];return void 0===Uo&&(Uo={},wo[Do]=Uo),Uo},delete:function(Co){delete wo[Co.uuid]},clear:function(){wo={}}}}function Tt(wo,Co,Do){function zo(Ws,Xs,Ys){var js=new Uint8Array(4),qs=wo.createTexture();wo.bindTexture(Ws,qs),wo.texParameteri(Ws,wo.TEXTURE_MIN_FILTER,wo.NEAREST),wo.texParameteri(Ws,wo.TEXTURE_MAG_FILTER,wo.NEAREST);for(var Zs=0;Zs<Ys;Zs++)wo.texImage2D(Xs+Zs,0,wo.RGBA,1,1,0,wo.RGBA,wo.UNSIGNED_BYTE,js);return qs}function Ho(Ws){!0!==ys[Ws]&&(wo.enable(Ws),ys[Ws]=!0)}function ko(Ws){!1!==ys[Ws]&&(wo.disable(Ws),ys[Ws]=!1)}function Xo(Ws,Xs,Ys,js,qs,Zs,Qs,Js){Ws===pr?ko(wo.BLEND):Ho(wo.BLEND),(Ws!==bs||Js!==Ps)&&(Ws===mr?Js?(wo.blendEquationSeparate(wo.FUNC_ADD,wo.FUNC_ADD),wo.blendFuncSeparate(wo.ONE,wo.ONE,wo.ONE,wo.ONE)):(wo.blendEquation(wo.FUNC_ADD),wo.blendFunc(wo.SRC_ALPHA,wo.ONE)):Ws===fr?Js?(wo.blendEquationSeparate(wo.FUNC_ADD,wo.FUNC_ADD),wo.blendFuncSeparate(wo.ZERO,wo.ZERO,wo.ONE_MINUS_SRC_COLOR,wo.ONE_MINUS_SRC_ALPHA)):(wo.blendEquation(wo.FUNC_ADD),wo.blendFunc(wo.ZERO,wo.ONE_MINUS_SRC_COLOR)):Ws===gr?Js?(wo.blendEquationSeparate(wo.FUNC_ADD,wo.FUNC_ADD),wo.blendFuncSeparate(wo.ZERO,wo.SRC_COLOR,wo.ZERO,wo.SRC_ALPHA)):(wo.blendEquation(wo.FUNC_ADD),wo.blendFunc(wo.ZERO,wo.SRC_COLOR)):Js?(wo.blendEquationSeparate(wo.FUNC_ADD,wo.FUNC_ADD),wo.blendFuncSeparate(wo.ONE,wo.ONE_MINUS_SRC_ALPHA,wo.ONE,wo.ONE_MINUS_SRC_ALPHA)):(wo.blendEquationSeparate(wo.FUNC_ADD,wo.FUNC_ADD),wo.blendFuncSeparate(wo.SRC_ALPHA,wo.ONE_MINUS_SRC_ALPHA,wo.ONE,wo.ONE_MINUS_SRC_ALPHA)),bs=Ws,Ps=Js),Ws===hr?(qs=qs||Xs,Zs=Zs||Ys,Qs=Qs||js,(Xs!==Ss||qs!==Ls)&&(wo.blendEquationSeparate(Do(Xs),Do(qs)),Ss=Xs,Ls=qs),(Ys!==Ms||js!==Ts||Zs!==As||Qs!==Rs)&&(wo.blendFuncSeparate(Do(Ys),Do(js),Do(Zs),Do(Qs)),Ms=Ys,Ts=js,As=Zs,Rs=Qs)):(Ss=null,Ms=null,Ts=null,Ls=null,As=null,Rs=null)}function Zo(Ws){fs.setFunc(Ws)}function es(Ws){ws!==Ws&&(Ws?wo.frontFace(wo.CW):wo.frontFace(wo.CCW),ws=Ws)}function ts(Ws){Ws===qt?ko(wo.CULL_FACE):(Ho(wo.CULL_FACE),Ws!==Cs&&(Ws===Zt?wo.cullFace(wo.BACK):Ws===Qt?wo.cullFace(wo.FRONT):wo.cullFace(wo.FRONT_AND_BACK))),Cs=Ws}function os(Ws){void 0===Ws&&(Ws=wo.TEXTURE0+zs-1),Os!==Ws&&(wo.activeTexture(Ws),Os=Ws)}var ms=new function(){var Ws=!1,Xs=new _e,Ys=null,js=new _e;return{setMask:function(qs){Ys===qs||Ws||(wo.colorMask(qs,qs,qs,qs),Ys=qs)},setLocked:function(qs){Ws=qs},setClear:function(qs,Zs,Qs,Js,Ks){!0===Ks&&(qs*=Js,Zs*=Js,Qs*=Js),Xs.set(qs,Zs,Qs,Js),!1===js.equals(Xs)&&(wo.clearColor(qs,Zs,Qs,Js),js.copy(Xs))},reset:function(){Ws=!1,Ys=null,js.set(0,0,0,1)}}},fs=new function(){var Ws=!1,Xs=null,Ys=null,js=null;return{setTest:function(qs){qs?Ho(wo.DEPTH_TEST):ko(wo.DEPTH_TEST)},setMask:function(qs){Xs===qs||Ws||(wo.depthMask(qs),Xs=qs)},setFunc:function(qs){Ys!==qs&&(qs?qs===Ur?wo.depthFunc(wo.NEVER):qs===Nr?wo.depthFunc(wo.ALWAYS):qs===Ir?wo.depthFunc(wo.LESS):qs===zr?wo.depthFunc(wo.LEQUAL):qs===Fr?wo.depthFunc(wo.EQUAL):qs===Br?wo.depthFunc(wo.GEQUAL):qs===Or?wo.depthFunc(wo.GREATER):qs===Gr?wo.depthFunc(wo.NOTEQUAL):wo.depthFunc(wo.LEQUAL):wo.depthFunc(wo.LEQUAL),Ys=qs)},setLocked:function(qs){Ws=qs},setClear:function(qs){js!==qs&&(wo.clearDepth(qs),js=qs)},reset:function(){Ws=!1,Xs=null,Ys=null,js=null}}},gs=new function(){var Ws=!1,Xs=null,Ys=null,js=null,qs=null,Zs=null,Qs=null,Js=null,Ks=null;return{setTest:function($s){$s?Ho(wo.STENCIL_TEST):ko(wo.STENCIL_TEST)},setMask:function($s){Xs===$s||Ws||(wo.stencilMask($s),Xs=$s)},setFunc:function($s,el,rl){(Ys!==$s||js!==el||qs!==rl)&&(wo.stencilFunc($s,el,rl),Ys=$s,js=el,qs=rl)},setOp:function($s,el,rl){(Zs!==$s||Qs!==el||Js!==rl)&&(wo.stencilOp($s,el,rl),Zs=$s,Qs=el,Js=rl)},setLocked:function($s){Ws=$s},setClear:function($s){Ks!==$s&&(wo.clearStencil($s),Ks=$s)},reset:function(){Ws=!1,Xs=null,Ys=null,js=null,qs=null,Zs=null,Qs=null,Js=null,Ks=null}}},hs=wo.getParameter(wo.MAX_VERTEX_ATTRIBS),xs=new Uint8Array(hs),_s=new Uint8Array(hs),vs=new Uint8Array(hs),ys={},Es=null,bs=null,Ss=null,Ms=null,Ts=null,Ls=null,As=null,Rs=null,Ps=!1,ws=null,Cs=null,Ds=null,Us=null,Ns=null,Is=null,zs=wo.getParameter(wo.MAX_TEXTURE_IMAGE_UNITS),Fs=parseFloat(/^WebGL\ ([0-9])/.exec(wo.getParameter(wo.VERSION))[1]),Bs=1<=parseFloat(Fs),Os=null,Gs={},Vs=new _e,Hs=new _e,ks={};return ks[wo.TEXTURE_2D]=zo(wo.TEXTURE_2D,wo.TEXTURE_2D,1),ks[wo.TEXTURE_CUBE_MAP]=zo(wo.TEXTURE_CUBE_MAP,wo.TEXTURE_CUBE_MAP_POSITIVE_X,6),{buffers:{color:ms,depth:fs,stencil:gs},init:function(){ms.setClear(0,0,0,1),fs.setClear(1),gs.setClear(0),Ho(wo.DEPTH_TEST),Zo(zr),es(!1),ts(Zt),Ho(wo.CULL_FACE),Ho(wo.BLEND),Xo(ur)},initAttributes:function(){for(var Ws=0,Xs=xs.length;Ws<Xs;Ws++)xs[Ws]=0},enableAttribute:function(Ws){if(xs[Ws]=1,0===_s[Ws]&&(wo.enableVertexAttribArray(Ws),_s[Ws]=1),0!==vs[Ws]){var Xs=Co.get('ANGLE_instanced_arrays');Xs.vertexAttribDivisorANGLE(Ws,0),vs[Ws]=0}},enableAttributeAndDivisor:function(Ws,Xs,Ys){xs[Ws]=1,0===_s[Ws]&&(wo.enableVertexAttribArray(Ws),_s[Ws]=1),vs[Ws]!==Xs&&(Ys.vertexAttribDivisorANGLE(Ws,Xs),vs[Ws]=Xs)},disableUnusedAttributes:function(){for(var Ws=0,Xs=_s.length;Ws!==Xs;++Ws)_s[Ws]!==xs[Ws]&&(wo.disableVertexAttribArray(Ws),_s[Ws]=0)},enable:Ho,disable:ko,getCompressedTextureFormats:function(){if(null===Es&&(Es=[],Co.get('WEBGL_compressed_texture_pvrtc')||Co.get('WEBGL_compressed_texture_s3tc')||Co.get('WEBGL_compressed_texture_etc1')))for(var Ws=wo.getParameter(wo.COMPRESSED_TEXTURE_FORMATS),Xs=0;Xs<Ws.length;Xs++)Es.push(Ws[Xs]);return Es},setBlending:Xo,setColorWrite:function(Ws){ms.setMask(Ws)},setDepthTest:function(Ws){fs.setTest(Ws)},setDepthWrite:function(Ws){fs.setMask(Ws)},setDepthFunc:Zo,setStencilTest:function(Ws){gs.setTest(Ws)},setStencilWrite:function(Ws){gs.setMask(Ws)},setStencilFunc:function(Ws,Xs,Ys){gs.setFunc(Ws,Xs,Ys)},setStencilOp:function(Ws,Xs,Ys){gs.setOp(Ws,Xs,Ys)},setFlipSided:es,setCullFace:ts,setLineWidth:function(Ws){Ws!==Ds&&(Bs&&wo.lineWidth(Ws),Ds=Ws)},setPolygonOffset:function(Ws,Xs,Ys){Ws?(Ho(wo.POLYGON_OFFSET_FILL),(Us!==Xs||Ns!==Ys)&&(wo.polygonOffset(Xs,Ys),Us=Xs,Ns=Ys)):ko(wo.POLYGON_OFFSET_FILL)},getScissorTest:function(){return Is},setScissorTest:function(Ws){Is=Ws,Ws?Ho(wo.SCISSOR_TEST):ko(wo.SCISSOR_TEST)},activeTexture:os,bindTexture:function(Ws,Xs){null===Os&&os();var Ys=Gs[Os];void 0===Ys&&(Ys={type:void 0,texture:void 0},Gs[Os]=Ys),(Ys.type!==Ws||Ys.texture!==Xs)&&(wo.bindTexture(Ws,Xs||ks[Ws]),Ys.type=Ws,Ys.texture=Xs)},compressedTexImage2D:function(){try{wo.compressedTexImage2D.apply(wo,arguments)}catch(Ws){console.error(Ws)}},texImage2D:function(){try{wo.texImage2D.apply(wo,arguments)}catch(Ws){console.error(Ws)}},scissor:function(Ws){!1===Vs.equals(Ws)&&(wo.scissor(Ws.x,Ws.y,Ws.z,Ws.w),Vs.copy(Ws))},viewport:function(Ws){!1===Hs.equals(Ws)&&(wo.viewport(Ws.x,Ws.y,Ws.z,Ws.w),Hs.copy(Ws))},reset:function(){for(var Ws=0;Ws<_s.length;Ws++)1===_s[Ws]&&(wo.disableVertexAttribArray(Ws),_s[Ws]=0);ys={},Es=null,Os=null,Gs={},bs=null,ws=null,Cs=null,ms.reset(),fs.reset(),gs.reset()}}}function Lt(wo,Co,Do){function No(Qo){if('highp'===Qo){if(0<wo.getShaderPrecisionFormat(wo.VERTEX_SHADER,wo.HIGH_FLOAT).precision&&0<wo.getShaderPrecisionFormat(wo.FRAGMENT_SHADER,wo.HIGH_FLOAT).precision)return'highp';Qo='mediump'}return'mediump'===Qo&&0<wo.getShaderPrecisionFormat(wo.VERTEX_SHADER,wo.MEDIUM_FLOAT).precision&&0<wo.getShaderPrecisionFormat(wo.FRAGMENT_SHADER,wo.MEDIUM_FLOAT).precision?'mediump':'lowp'}var Io,zo=Do.precision===void 0?'highp':Do.precision,Fo=No(zo);Fo!==zo&&(console.warn('THREE.WebGLRenderer:',zo,'not supported, using',Fo,'instead.'),zo=Fo);var Bo=!0===Do.logarithmicDepthBuffer&&!!Co.get('EXT_frag_depth'),Oo=wo.getParameter(wo.MAX_TEXTURE_IMAGE_UNITS),Go=wo.getParameter(wo.MAX_VERTEX_TEXTURE_IMAGE_UNITS),Vo=wo.getParameter(wo.MAX_TEXTURE_SIZE),Ho=wo.getParameter(wo.MAX_CUBE_MAP_TEXTURE_SIZE),ko=wo.getParameter(wo.MAX_VERTEX_ATTRIBS),Wo=wo.getParameter(wo.MAX_VERTEX_UNIFORM_VECTORS),Xo=wo.getParameter(wo.MAX_VARYING_VECTORS),Yo=wo.getParameter(wo.MAX_FRAGMENT_UNIFORM_VECTORS),jo=0<Go,qo=!!Co.get('OES_texture_float');return{getMaxAnisotropy:function(){if(void 0!==Io)return Io;var Qo=Co.get('EXT_texture_filter_anisotropic');return Io=null===Qo?0:wo.getParameter(Qo.MAX_TEXTURE_MAX_ANISOTROPY_EXT),Io},getMaxPrecision:No,precision:zo,logarithmicDepthBuffer:Bo,maxTextures:Oo,maxVertexTextures:Go,maxTextureSize:Vo,maxCubemapSize:Ho,maxAttributes:ko,maxVertexUniforms:Wo,maxVaryings:Xo,maxFragmentUniforms:Yo,vertexTextures:jo,floatFragmentTextures:qo,floatVertexTextures:jo&&qo}}function At(wo){var Co={};return{get:function(Do){if(void 0!==Co[Do])return Co[Do];var Uo;return Uo='WEBGL_depth_texture'===Do?wo.getExtension('WEBGL_depth_texture')||wo.getExtension('MOZ_WEBGL_depth_texture')||wo.getExtension('WEBKIT_WEBGL_depth_texture'):'EXT_texture_filter_anisotropic'===Do?wo.getExtension('EXT_texture_filter_anisotropic')||wo.getExtension('MOZ_EXT_texture_filter_anisotropic')||wo.getExtension('WEBKIT_EXT_texture_filter_anisotropic'):'WEBGL_compressed_texture_s3tc'===Do?wo.getExtension('WEBGL_compressed_texture_s3tc')||wo.getExtension('MOZ_WEBGL_compressed_texture_s3tc')||wo.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc'):'WEBGL_compressed_texture_pvrtc'===Do?wo.getExtension('WEBGL_compressed_texture_pvrtc')||wo.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'):'WEBGL_compressed_texture_etc1'===Do?wo.getExtension('WEBGL_compressed_texture_etc1'):wo.getExtension(Do),null===Uo&&console.warn('THREE.WebGLRenderer: '+Do+' extension not supported.'),Co[Do]=Uo,Uo}}}function Rt(){function wo(){Oo.value!==Uo&&(Oo.value=Uo,Oo.needsUpdate=0<No),Do.numPlanes=No,Do.numIntersection=0}function Co(Go,Vo,Ho,ko){var Wo=null===Go?0:Go.length,Xo=null;if(0!==Wo){if(Xo=Oo.value,!0!==ko||null===Xo){var Yo=Ho+4*Wo,jo=Vo.matrixWorldInverse;Bo.getNormalMatrix(jo),(null===Xo||Xo.length<Yo)&&(Xo=new Float32Array(Yo));for(var qo=0,Zo=Ho;qo!==Wo;++qo,Zo+=4)Fo.copy(Go[qo]).applyMatrix4(jo,Bo),Fo.normal.toArray(Xo,Zo),Xo[Zo+3]=Fo.constant}Oo.value=Xo,Oo.needsUpdate=!0}return Do.numPlanes=Wo,Xo}var Do=this,Uo=null,No=0,Io=!1,zo=!1,Fo=new Ce,Bo=new we,Oo={value:null,needsUpdate:!1};this.uniform=Oo,this.numPlanes=0,this.numIntersection=0,this.init=function(Go,Vo,Ho){var ko=0!==Go.length||Vo||0!==No||Io;return Io=Vo,Uo=Co(Go,Ho,0),No=Go.length,ko},this.beginShadows=function(){zo=!0,Co(null)},this.endShadows=function(){zo=!1,wo()},this.setState=function(Go,Vo,Ho,ko,Wo,Xo){if(!Io||null===Go||0===Go.length||zo&&!Ho)zo?Co(null):wo();else{var Yo=zo?0:No,jo=4*Yo,qo=Wo.clippingState||null;Oo.value=qo,qo=Co(Go,ko,jo,Xo);for(var Zo=0;Zo!==jo;++Zo)qo[Zo]=Uo[Zo];Wo.clippingState=qo,this.numIntersection=Vo?this.numPlanes:0,this.numPlanes+=Yo}}}function wt(){Fe.call(this),this.type='Scene',this.background=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0}function Ct(wo,Co,Do,Uo,No,Io,zo,Fo,Bo){function Oo(){requestAnimationFrame(Oo),wo.readyState>=wo.HAVE_CURRENT_DATA&&(Go.needsUpdate=!0)}L.call(this,wo,Co,Do,Uo,No,Io,zo,Fo,Bo),this.generateMipmaps=!1;var Go=this;Oo()}function Ut(wo){this.manager=wo===void 0?Po:wo}function Nt(wo){this.manager=wo===void 0?Po:wo}function It(wo,Co,Do,Uo){this.ray=new Ne(wo,Co),this.near=Do||0,this.far=Uo||Infinity,this.params={Mesh:{},Line:{},LOD:{},Points:{threshold:1},Sprite:{}},Object.defineProperties(this.params,{PointCloud:{get:function(){return console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.'),this.Points}}})}function zt(wo,Co){return wo.distance-Co.distance}function Ft(wo,Co,Do,Uo){if(!1!==wo.visible&&(wo.raycast(Co,Do),!0===Uo))for(var No=wo.children,Io=0,zo=No.length;Io<zo;Io++)Ft(No[Io],Co,Do,!0)}function Bt(wo,Co,Do,Uo,No){Ze.call(this),this.type='TorusGeometry',this.parameters={radius:wo,tube:Co,radialSegments:Do,tubularSegments:Uo,arc:No},this.fromBufferGeometry(new Ot(wo,Co,Do,Uo,No))}function Ot(wo,Co,Do,Uo,No){Qe.call(this),this.type='TorusBufferGeometry',this.parameters={radius:wo,tube:Co,radialSegments:Do,tubularSegments:Uo,arc:No},wo=wo||100,Co=Co||40,Do=Math.floor(Do)||8,Uo=Math.floor(Uo)||6,No=No||2*Math.PI;var Io=[],zo=[],Fo=[],Bo=[],Oo=new E,Go=new E,Vo=new E,Ho,ko;for(Ho=0;Ho<=Do;Ho++)for(ko=0;ko<=Uo;ko++){var Wo=ko/Uo*No,Xo=2*(Ho/Do*Math.PI);Go.x=(wo+Co*Math.cos(Xo))*Math.cos(Wo),Go.y=(wo+Co*Math.cos(Xo))*Math.sin(Wo),Go.z=Co*Math.sin(Xo),zo.push(Go.x,Go.y,Go.z),Oo.x=wo*Math.cos(Wo),Oo.y=wo*Math.sin(Wo),Vo.subVectors(Go,Oo).normalize(),Fo.push(Vo.x,Vo.y,Vo.z),Bo.push(ko/Uo),Bo.push(Ho/Do)}for(Ho=1;Ho<=Do;Ho++)for(ko=1;ko<=Uo;ko++){var Yo=(Uo+1)*Ho+ko-1,jo=(Uo+1)*(Ho-1)+ko-1,qo=(Uo+1)*(Ho-1)+ko,Zo=(Uo+1)*Ho+ko;Io.push(Yo,jo,Zo),Io.push(jo,qo,Zo)}this.setIndex(Io),this.addAttribute('position',new Xe(zo,3)),this.addAttribute('normal',new Xe(Fo,3)),this.addAttribute('uv',new Xe(Bo,2))}function Gt(wo,Co,Do,Uo,No,Io,zo){Ze.call(this),this.type='SphereGeometry',this.parameters={radius:wo,widthSegments:Co,heightSegments:Do,phiStart:Uo,phiLength:No,thetaStart:Io,thetaLength:zo},this.fromBufferGeometry(new Vt(wo,Co,Do,Uo,No,Io,zo))}function Vt(wo,Co,Do,Uo,No,Io,zo){Qe.call(this),this.type='SphereBufferGeometry',this.parameters={radius:wo,widthSegments:Co,heightSegments:Do,phiStart:Uo,phiLength:No,thetaStart:Io,thetaLength:zo},wo=wo||50,Co=Math.max(3,Math.floor(Co)||8),Do=Math.max(2,Math.floor(Do)||6),Uo=Uo===void 0?0:Uo,No=No===void 0?2*Math.PI:No,Io=Io===void 0?0:Io,zo=zo===void 0?Math.PI:zo;var Fo=Io+zo,Bo,Oo,Go=0,Vo=[],Ho=new E,ko=new E,Wo=[],Xo=[],Yo=[],jo=[];for(Oo=0;Oo<=Do;Oo++){var qo=[],Zo=Oo/Do;for(Bo=0;Bo<=Co;Bo++){var Qo=Bo/Co;Ho.x=-wo*Math.cos(Uo+Qo*No)*Math.sin(Io+Zo*zo),Ho.y=wo*Math.cos(Io+Zo*zo),Ho.z=wo*Math.sin(Uo+Qo*No)*Math.sin(Io+Zo*zo),Xo.push(Ho.x,Ho.y,Ho.z),ko.set(Ho.x,Ho.y,Ho.z).normalize(),Yo.push(ko.x,ko.y,ko.z),jo.push(Qo,1-Zo),qo.push(Go++)}Vo.push(qo)}for(Oo=0;Oo<Do;Oo++)for(Bo=0;Bo<Co;Bo++){var Jo=Vo[Oo][Bo+1],Ko=Vo[Oo][Bo],$o=Vo[Oo+1][Bo],es=Vo[Oo+1][Bo+1];(0!==Oo||0<Io)&&Wo.push(Jo,Ko,es),(Oo!==Do-1||Fo<Math.PI)&&Wo.push(Ko,$o,es)}this.setIndex(Wo),this.addAttribute('position',new Xe(Xo,3)),this.addAttribute('normal',new Xe(Yo,3)),this.addAttribute('uv',new Xe(jo,2))}function Ht(wo,Co,Do,Uo){Ze.call(this),this.type='CircleGeometry',this.parameters={radius:wo,segments:Co,thetaStart:Do,thetaLength:Uo},this.fromBufferGeometry(new kt(wo,Co,Do,Uo))}function kt(wo,Co,Do,Uo){Qe.call(this),this.type='CircleBufferGeometry',this.parameters={radius:wo,segments:Co,thetaStart:Do,thetaLength:Uo},wo=wo||50,Co=Co===void 0?8:Math.max(3,Co),Do=Do===void 0?0:Do,Uo=Uo===void 0?2*Math.PI:Uo;var No=[],Io=[],zo=[],Fo=[],Bo,Oo,Go=new E,Vo=new T;for(Io.push(0,0,0),zo.push(0,0,1),Fo.push(0.5,0.5),(Oo=0,Bo=3);Oo<=Co;Oo++,Bo+=3){var Ho=Do+Oo/Co*Uo;Go.x=wo*Math.cos(Ho),Go.y=wo*Math.sin(Ho),Io.push(Go.x,Go.y,Go.z),zo.push(0,0,1),Vo.x=(Io[Bo]/wo+1)/2,Vo.y=(Io[Bo+1]/wo+1)/2,Fo.push(Vo.x,Vo.y)}for(Bo=1;Bo<=Co;Bo++)No.push(Bo,Bo+1,0);this.setIndex(No),this.addAttribute('position',new Xe(Io,3)),this.addAttribute('normal',new Xe(zo,3)),this.addAttribute('uv',new Xe(Fo,2))}function Wt(wo,Co,Do,Uo,No,Io){Ze.call(this),this.type='RingGeometry',this.parameters={innerRadius:wo,outerRadius:Co,thetaSegments:Do,phiSegments:Uo,thetaStart:No,thetaLength:Io},this.fromBufferGeometry(new Xt(wo,Co,Do,Uo,No,Io))}function Xt(wo,Co,Do,Uo,No,Io){Qe.call(this),this.type='RingBufferGeometry',this.parameters={innerRadius:wo,outerRadius:Co,thetaSegments:Do,phiSegments:Uo,thetaStart:No,thetaLength:Io},wo=wo||20,Co=Co||50,No=No===void 0?0:No,Io=Io===void 0?2*Math.PI:Io,Do=Do===void 0?8:Math.max(3,Do),Uo=Uo===void 0?1:Math.max(1,Uo);var zo=[],Fo=[],Bo=[],Oo=[],Go,Vo=wo,Ho=(Co-wo)/Uo,ko=new E,Wo=new T,Xo,Yo;for(Xo=0;Xo<=Uo;Xo++){for(Yo=0;Yo<=Do;Yo++)Go=No+Yo/Do*Io,ko.x=Vo*Math.cos(Go),ko.y=Vo*Math.sin(Go),Fo.push(ko.x,ko.y,ko.z),Bo.push(0,0,1),Wo.x=(ko.x/Co+1)/2,Wo.y=(ko.y/Co+1)/2,Oo.push(Wo.x,Wo.y);Vo+=Ho}for(Xo=0;Xo<Uo;Xo++){var jo=Xo*(Do+1);for(Yo=0;Yo<Do;Yo++){Go=Yo+jo;var qo=Go,Zo=Go+Do+1,Qo=Go+Do+2,Jo=Go+1;zo.push(qo,Zo,Jo),zo.push(Zo,Qo,Jo)}}this.setIndex(zo),this.addAttribute('position',new Xe(Fo,3)),this.addAttribute('normal',new Xe(Bo,3)),this.addAttribute('uv',new Xe(Oo,2))}Number.EPSILON===void 0&&(Number.EPSILON=Math.pow(2,-52)),Math.sign===void 0&&(Math.sign=function(wo){return 0>wo?-1:0<wo?1:+wo}),Function.prototype.name===void 0&&Object.defineProperty(Function.prototype,'name',{get:function(){return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]}}),Object.assign===void 0&&function(){Object.assign=function(wo){if(wo===void 0||null===wo)throw new TypeError('Cannot convert undefined or null to object');for(var Co=Object(wo),Do=1,Uo;Do<arguments.length;Do++)if(Uo=arguments[Do],void 0!==Uo&&null!==Uo)for(var No in Uo)Object.prototype.hasOwnProperty.call(Uo,No)&&(Co[No]=Uo[No]);return Co}}();var Yt='84',qt=0,Zt=1,Qt=2,Kt=0,tr=1,rr=2,ar=0,ir=1,nr=2,or=1,sr=2,lr=0,pr=0,ur=1,mr=2,fr=3,gr=4,hr=5,xr=100,_r=101,vr=102,yr=103,Er=104,br=200,Sr=201,Mr=202,Tr=203,Lr=204,Ar=205,Rr=206,Pr=207,wr=208,Cr=209,Dr=210,Ur=0,Nr=1,Ir=2,zr=3,Fr=4,Br=5,Or=6,Gr=7,Vr=0,Hr=1,kr=2,Wr=0,Xr=1,Yr=2,jr=3,qr=4,Zr=300,Qr=301,Jr=302,Kr=303,$r=304,ea=305,ta=306,ra=307,aa=1e3,ia=1001,na=1002,oa=1003,sa=1004,la=1005,da=1006,ca=1007,pa=1008,ua=1009,ma=1010,fa=1011,ga=1012,ha=1013,xa=1014,_a=1015,va=1016,ya=1017,Ea=1018,ba=1019,Sa=1020,Ma=1021,Ta=1022,La=1023,Aa=1024,Ra=1025,wa=1026,Ca=1027,Da=2001,Ua=2002,Na=2003,Ia=2004,za=2100,Fa=2101,Ba=2102,Oa=2103,Ga=2151,Ja=0,Ka=1,$a=2,ei=3e3,ti=3001,ri=3007,ai=3002,ni=3004,oi=3005,si=3006,li=3200,di=3201,ci={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){var wo='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''),Co=Array(36),Do=0,Uo;return function(){for(var Io=0;36>Io;Io++)8===Io||13===Io||18===Io||23===Io?Co[Io]='-':14===Io?Co[Io]='4':(2>=Do&&(Do=0|33554432+16777216*Math.random()),Uo=15&Do,Do>>=4,Co[Io]=wo[19===Io?8|3&Uo:Uo]);return Co.join('')}}(),clamp:function(wo,Co,Do){return Math.max(Co,Math.min(Do,wo))},euclideanModulo:function(wo,Co){return(wo%Co+Co)%Co},mapLinear:function(wo,Co,Do,Uo,No){return Uo+(wo-Co)*(No-Uo)/(Do-Co)},lerp:function(wo,Co,Do){return(1-Do)*wo+Do*Co},smoothstep:function(wo,Co,Do){return wo<=Co?0:wo>=Do?1:(wo=(wo-Co)/(Do-Co),wo*wo*(3-2*wo))},smootherstep:function(wo,Co,Do){return wo<=Co?0:wo>=Do?1:(wo=(wo-Co)/(Do-Co),wo*wo*wo*(wo*(6*wo-15)+10))},randInt:function(wo,Co){return wo+Math.floor(Math.random()*(Co-wo+1))},randFloat:function(wo,Co){return wo+Math.random()*(Co-wo)},randFloatSpread:function(wo){return wo*(0.5-Math.random())},degToRad:function(wo){return wo*ci.DEG2RAD},radToDeg:function(wo){return wo*ci.RAD2DEG},isPowerOfTwo:function(wo){return 0===(wo&wo-1)&&0!==wo},nearestPowerOfTwo:function(wo){return Math.pow(2,Math.round(Math.log(wo)/Math.LN2))},nextPowerOfTwo:function(wo){return wo--,wo|=wo>>1,wo|=wo>>2,wo|=wo>>4,wo|=wo>>8,wo|=wo>>16,wo++,wo}};_.prototype={constructor:_,get x(){return this._x},set x(wo){this._x=wo,this.onChangeCallback()},get y(){return this._y},set y(wo){this._y=wo,this.onChangeCallback()},get z(){return this._z},set z(wo){this._z=wo,this.onChangeCallback()},get w(){return this._w},set w(wo){this._w=wo,this.onChangeCallback()},set:function(wo,Co,Do,Uo){return this._x=wo,this._y=Co,this._z=Do,this._w=Uo,this.onChangeCallback(),this},clone:function(){return new this.constructor(this._x,this._y,this._z,this._w)},copy:function(wo){return this._x=wo.x,this._y=wo.y,this._z=wo.z,this._w=wo.w,this.onChangeCallback(),this},setFromEuler:function(wo,Co){if(!1===(wo&&wo.isEuler))throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');var Do=Math.cos(wo._x/2),Uo=Math.cos(wo._y/2),No=Math.cos(wo._z/2),Io=Math.sin(wo._x/2),zo=Math.sin(wo._y/2),Fo=Math.sin(wo._z/2),Bo=wo.order;return'XYZ'===Bo?(this._x=Io*Uo*No+Do*zo*Fo,this._y=Do*zo*No-Io*Uo*Fo,this._z=Do*Uo*Fo+Io*zo*No,this._w=Do*Uo*No-Io*zo*Fo):'YXZ'===Bo?(this._x=Io*Uo*No+Do*zo*Fo,this._y=Do*zo*No-Io*Uo*Fo,this._z=Do*Uo*Fo-Io*zo*No,this._w=Do*Uo*No+Io*zo*Fo):'ZXY'===Bo?(this._x=Io*Uo*No-Do*zo*Fo,this._y=Do*zo*No+Io*Uo*Fo,this._z=Do*Uo*Fo+Io*zo*No,this._w=Do*Uo*No-Io*zo*Fo):'ZYX'===Bo?(this._x=Io*Uo*No-Do*zo*Fo,this._y=Do*zo*No+Io*Uo*Fo,this._z=Do*Uo*Fo-Io*zo*No,this._w=Do*Uo*No+Io*zo*Fo):'YZX'===Bo?(this._x=Io*Uo*No+Do*zo*Fo,this._y=Do*zo*No+Io*Uo*Fo,this._z=Do*Uo*Fo-Io*zo*No,this._w=Do*Uo*No-Io*zo*Fo):'XZY'===Bo&&(this._x=Io*Uo*No-Do*zo*Fo,this._y=Do*zo*No-Io*Uo*Fo,this._z=Do*Uo*Fo+Io*zo*No,this._w=Do*Uo*No+Io*zo*Fo),!1!==Co&&this.onChangeCallback(),this},setFromAxisAngle:function(wo,Co){var Do=Co/2,Uo=Math.sin(Do);return this._x=wo.x*Uo,this._y=wo.y*Uo,this._z=wo.z*Uo,this._w=Math.cos(Do),this.onChangeCallback(),this},setFromRotationMatrix:function(wo){var Co=wo.elements,Do=Co[0],Uo=Co[4],No=Co[8],Io=Co[1],zo=Co[5],Fo=Co[9],Bo=Co[2],Oo=Co[6],Go=Co[10],Vo=Do+zo+Go,Ho;return 0<Vo?(Ho=0.5/Math.sqrt(Vo+1),this._w=0.25/Ho,this._x=(Oo-Fo)*Ho,this._y=(No-Bo)*Ho,this._z=(Io-Uo)*Ho):Do>zo&&Do>Go?(Ho=2*Math.sqrt(1+Do-zo-Go),this._w=(Oo-Fo)/Ho,this._x=0.25*Ho,this._y=(Uo+Io)/Ho,this._z=(No+Bo)/Ho):zo>Go?(Ho=2*Math.sqrt(1+zo-Do-Go),this._w=(No-Bo)/Ho,this._x=(Uo+Io)/Ho,this._y=0.25*Ho,this._z=(Fo+Oo)/Ho):(Ho=2*Math.sqrt(1+Go-Do-zo),this._w=(Io-Uo)/Ho,this._x=(No+Bo)/Ho,this._y=(Fo+Oo)/Ho,this._z=0.25*Ho),this.onChangeCallback(),this},setFromUnitVectors:function(){var wo,Co;return function(No,Io){return void 0===wo&&(wo=new E),Co=No.dot(Io)+1,Co<1e-6?(Co=0,Math.abs(No.x)>Math.abs(No.z)?wo.set(-No.y,No.x,0):wo.set(0,-No.z,No.y)):wo.crossVectors(No,Io),this._x=wo.x,this._y=wo.y,this._z=wo.z,this._w=Co,this.normalize()}}(),inverse:function(){return this.conjugate().normalize()},conjugate:function(){return this._x*=-1,this._y*=-1,this._z*=-1,this.onChangeCallback(),this},dot:function(wo){return this._x*wo._x+this._y*wo._y+this._z*wo._z+this._w*wo._w},lengthSq:function(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w},length:function(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)},normalize:function(){var wo=this.length();return 0===wo?(this._x=0,this._y=0,this._z=0,this._w=1):(wo=1/wo,this._x*=wo,this._y*=wo,this._z*=wo,this._w*=wo),this.onChangeCallback(),this},multiply:function(wo,Co){return void 0===Co?this.multiplyQuaternions(this,wo):(console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.'),this.multiplyQuaternions(wo,Co))},premultiply:function(wo){return this.multiplyQuaternions(wo,this)},multiplyQuaternions:function(wo,Co){var Do=wo._x,Uo=wo._y,No=wo._z,Io=wo._w,zo=Co._x,Fo=Co._y,Bo=Co._z,Oo=Co._w;return this._x=Do*Oo+Io*zo+Uo*Bo-No*Fo,this._y=Uo*Oo+Io*Fo+No*zo-Do*Bo,this._z=No*Oo+Io*Bo+Do*Fo-Uo*zo,this._w=Io*Oo-Do*zo-Uo*Fo-No*Bo,this.onChangeCallback(),this},slerp:function(wo,Co){if(0===Co)return this;if(1===Co)return this.copy(wo);var Do=this._x,Uo=this._y,No=this._z,Io=this._w,zo=Io*wo._w+Do*wo._x+Uo*wo._y+No*wo._z;if(0>zo?(this._w=-wo._w,this._x=-wo._x,this._y=-wo._y,this._z=-wo._z,zo=-zo):this.copy(wo),1<=zo)return this._w=Io,this._x=Do,this._y=Uo,this._z=No,this;var Fo=Math.sqrt(1-zo*zo);if(1e-3>Math.abs(Fo))return this._w=0.5*(Io+this._w),this._x=0.5*(Do+this._x),this._y=0.5*(Uo+this._y),this._z=0.5*(No+this._z),this;var Bo=Math.atan2(Fo,zo),Oo=Math.sin((1-Co)*Bo)/Fo,Go=Math.sin(Co*Bo)/Fo;return this._w=Io*Oo+this._w*Go,this._x=Do*Oo+this._x*Go,this._y=Uo*Oo+this._y*Go,this._z=No*Oo+this._z*Go,this.onChangeCallback(),this},equals:function(wo){return wo._x===this._x&&wo._y===this._y&&wo._z===this._z&&wo._w===this._w},fromArray:function(wo,Co){return void 0===Co&&(Co=0),this._x=wo[Co],this._y=wo[Co+1],this._z=wo[Co+2],this._w=wo[Co+3],this.onChangeCallback(),this},toArray:function(wo,Co){return void 0===wo&&(wo=[]),void 0===Co&&(Co=0),wo[Co]=this._x,wo[Co+1]=this._y,wo[Co+2]=this._z,wo[Co+3]=this._w,wo},onChange:function(wo){return this.onChangeCallback=wo,this},onChangeCallback:function(){}},Object.assign(_,{slerp:function(wo,Co,Do,Uo){return Do.copy(wo).slerp(Co,Uo)},slerpFlat:function(wo,Co,Do,Uo,No,Io,zo){var Fo=Do[Uo+0],Bo=Do[Uo+1],Oo=Do[Uo+2],Go=Do[Uo+3],Vo=No[Io+0],Ho=No[Io+1],ko=No[Io+2],Wo=No[Io+3];if(Go!==Wo||Fo!==Vo||Bo!==Ho||Oo!==ko){var Xo=1-zo,Yo=Fo*Vo+Bo*Ho+Oo*ko+Go*Wo,jo=0<=Yo?1:-1,qo=1-Yo*Yo;if(qo>Number.EPSILON){var Zo=Math.sqrt(qo),Qo=Math.atan2(Zo,Yo*jo);Xo=Math.sin(Xo*Qo)/Zo,zo=Math.sin(zo*Qo)/Zo}var Jo=zo*jo;if(Fo=Fo*Xo+Vo*Jo,Bo=Bo*Xo+Ho*Jo,Oo=Oo*Xo+ko*Jo,Go=Go*Xo+Wo*Jo,Xo===1-zo){var Ko=1/Math.sqrt(Fo*Fo+Bo*Bo+Oo*Oo+Go*Go);Fo*=Ko,Bo*=Ko,Oo*=Ko,Go*=Ko}}wo[Co]=Fo,wo[Co+1]=Bo,wo[Co+2]=Oo,wo[Co+3]=Go}}),E.prototype={constructor:E,isVector3:!0,set:function(wo,Co,Do){return this.x=wo,this.y=Co,this.z=Do,this},setScalar:function(wo){return this.x=wo,this.y=wo,this.z=wo,this},setX:function(wo){return this.x=wo,this},setY:function(wo){return this.y=wo,this},setZ:function(wo){return this.z=wo,this},setComponent:function(wo,Co){switch(wo){case 0:this.x=Co;break;case 1:this.y=Co;break;case 2:this.z=Co;break;default:throw new Error('index is out of range: '+wo);}return this},getComponent:function(wo){switch(wo){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error('index is out of range: '+wo);}},clone:function(){return new this.constructor(this.x,this.y,this.z)},copy:function(wo){return this.x=wo.x,this.y=wo.y,this.z=wo.z,this},add:function(wo,Co){return void 0===Co?(this.x+=wo.x,this.y+=wo.y,this.z+=wo.z,this):(console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.'),this.addVectors(wo,Co))},addScalar:function(wo){return this.x+=wo,this.y+=wo,this.z+=wo,this},addVectors:function(wo,Co){return this.x=wo.x+Co.x,this.y=wo.y+Co.y,this.z=wo.z+Co.z,this},addScaledVector:function(wo,Co){return this.x+=wo.x*Co,this.y+=wo.y*Co,this.z+=wo.z*Co,this},sub:function(wo,Co){return void 0===Co?(this.x-=wo.x,this.y-=wo.y,this.z-=wo.z,this):(console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'),this.subVectors(wo,Co))},subScalar:function(wo){return this.x-=wo,this.y-=wo,this.z-=wo,this},subVectors:function(wo,Co){return this.x=wo.x-Co.x,this.y=wo.y-Co.y,this.z=wo.z-Co.z,this},multiply:function(wo,Co){return void 0===Co?(this.x*=wo.x,this.y*=wo.y,this.z*=wo.z,this):(console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.'),this.multiplyVectors(wo,Co))},multiplyScalar:function(wo){return isFinite(wo)?(this.x*=wo,this.y*=wo,this.z*=wo):(this.x=0,this.y=0,this.z=0),this},multiplyVectors:function(wo,Co){return this.x=wo.x*Co.x,this.y=wo.y*Co.y,this.z=wo.z*Co.z,this},applyEuler:function(){var wo;return function(Do){return!1===(Do&&Do.isEuler)&&console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.'),void 0===wo&&(wo=new _),this.applyQuaternion(wo.setFromEuler(Do))}}(),applyAxisAngle:function(){var wo;return function(Do,Uo){return void 0===wo&&(wo=new _),this.applyQuaternion(wo.setFromAxisAngle(Do,Uo))}}(),applyMatrix3:function(wo){var Co=this.x,Do=this.y,Uo=this.z,No=wo.elements;return this.x=No[0]*Co+No[3]*Do+No[6]*Uo,this.y=No[1]*Co+No[4]*Do+No[7]*Uo,this.z=No[2]*Co+No[5]*Do+No[8]*Uo,this},applyMatrix4:function(wo){var Co=this.x,Do=this.y,Uo=this.z,No=wo.elements;this.x=No[0]*Co+No[4]*Do+No[8]*Uo+No[12],this.y=No[1]*Co+No[5]*Do+No[9]*Uo+No[13],this.z=No[2]*Co+No[6]*Do+No[10]*Uo+No[14];var Io=No[3]*Co+No[7]*Do+No[11]*Uo+No[15];return this.divideScalar(Io)},applyQuaternion:function(wo){var Co=this.x,Do=this.y,Uo=this.z,No=wo.x,Io=wo.y,zo=wo.z,Fo=wo.w,Bo=Fo*Co+Io*Uo-zo*Do,Oo=Fo*Do+zo*Co-No*Uo,Go=Fo*Uo+No*Do-Io*Co,Vo=-No*Co-Io*Do-zo*Uo;return this.x=Bo*Fo+Vo*-No+Oo*-zo-Go*-Io,this.y=Oo*Fo+Vo*-Io+Go*-No-Bo*-zo,this.z=Go*Fo+Vo*-zo+Bo*-Io-Oo*-No,this},project:function(){var wo;return function(Do){return void 0===wo&&(wo=new S),wo.multiplyMatrices(Do.projectionMatrix,wo.getInverse(Do.matrixWorld)),this.applyMatrix4(wo)}}(),unproject:function(){var wo;return function(Do){return void 0===wo&&(wo=new S),wo.multiplyMatrices(Do.matrixWorld,wo.getInverse(Do.projectionMatrix)),this.applyMatrix4(wo)}}(),transformDirection:function(wo){var Co=this.x,Do=this.y,Uo=this.z,No=wo.elements;return this.x=No[0]*Co+No[4]*Do+No[8]*Uo,this.y=No[1]*Co+No[5]*Do+No[9]*Uo,this.z=No[2]*Co+No[6]*Do+No[10]*Uo,this.normalize()},divide:function(wo){return this.x/=wo.x,this.y/=wo.y,this.z/=wo.z,this},divideScalar:function(wo){return this.multiplyScalar(1/wo)},min:function(wo){return this.x=Math.min(this.x,wo.x),this.y=Math.min(this.y,wo.y),this.z=Math.min(this.z,wo.z),this},max:function(wo){return this.x=Math.max(this.x,wo.x),this.y=Math.max(this.y,wo.y),this.z=Math.max(this.z,wo.z),this},clamp:function(wo,Co){return this.x=Math.max(wo.x,Math.min(Co.x,this.x)),this.y=Math.max(wo.y,Math.min(Co.y,this.y)),this.z=Math.max(wo.z,Math.min(Co.z,this.z)),this},clampScalar:function(){var wo,Co;return function(Uo,No){return void 0===wo&&(wo=new E,Co=new E),wo.set(Uo,Uo,Uo),Co.set(No,No,No),this.clamp(wo,Co)}}(),clampLength:function(wo,Co){var Do=this.length();return this.multiplyScalar(Math.max(wo,Math.min(Co,Do))/Do)},floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this},ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this},round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this},roundToZero:function(){return this.x=0>this.x?Math.ceil(this.x):Math.floor(this.x),this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y),this.z=0>this.z?Math.ceil(this.z):Math.floor(this.z),this},negate:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this},dot:function(wo){return this.x*wo.x+this.y*wo.y+this.z*wo.z},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},lengthManhattan:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)},normalize:function(){return this.divideScalar(this.length())},setLength:function(wo){return this.multiplyScalar(wo/this.length())},lerp:function(wo,Co){return this.x+=(wo.x-this.x)*Co,this.y+=(wo.y-this.y)*Co,this.z+=(wo.z-this.z)*Co,this},lerpVectors:function(wo,Co,Do){return this.subVectors(Co,wo).multiplyScalar(Do).add(wo)},cross:function(wo,Co){if(void 0!==Co)return console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.'),this.crossVectors(wo,Co);var Do=this.x,Uo=this.y,No=this.z;return this.x=Uo*wo.z-No*wo.y,this.y=No*wo.x-Do*wo.z,this.z=Do*wo.y-Uo*wo.x,this},crossVectors:function(wo,Co){var Do=wo.x,Uo=wo.y,No=wo.z,Io=Co.x,zo=Co.y,Fo=Co.z;return this.x=Uo*Fo-No*zo,this.y=No*Io-Do*Fo,this.z=Do*zo-Uo*Io,this},projectOnVector:function(wo){var Co=wo.dot(this)/wo.lengthSq();return this.copy(wo).multiplyScalar(Co)},projectOnPlane:function(){var wo;return function(Do){return void 0===wo&&(wo=new E),wo.copy(this).projectOnVector(Do),this.sub(wo)}}(),reflect:function(){var wo;return function(Do){return void 0===wo&&(wo=new E),this.sub(wo.copy(Do).multiplyScalar(2*this.dot(Do)))}}(),angleTo:function(wo){var Co=this.dot(wo)/Math.sqrt(this.lengthSq()*wo.lengthSq());return Math.acos(ci.clamp(Co,-1,1))},distanceTo:function(wo){return Math.sqrt(this.distanceToSquared(wo))},distanceToSquared:function(wo){var Co=this.x-wo.x,Do=this.y-wo.y,Uo=this.z-wo.z;return Co*Co+Do*Do+Uo*Uo},distanceToManhattan:function(wo){return Math.abs(this.x-wo.x)+Math.abs(this.y-wo.y)+Math.abs(this.z-wo.z)},setFromSpherical:function(wo){var Co=Math.sin(wo.phi)*wo.radius;return this.x=Co*Math.sin(wo.theta),this.y=Math.cos(wo.phi)*wo.radius,this.z=Co*Math.cos(wo.theta),this},setFromCylindrical:function(wo){return this.x=wo.radius*Math.sin(wo.theta),this.y=wo.y,this.z=wo.radius*Math.cos(wo.theta),this},setFromMatrixPosition:function(wo){return this.setFromMatrixColumn(wo,3)},setFromMatrixScale:function(wo){var Co=this.setFromMatrixColumn(wo,0).length(),Do=this.setFromMatrixColumn(wo,1).length(),Uo=this.setFromMatrixColumn(wo,2).length();return this.x=Co,this.y=Do,this.z=Uo,this},setFromMatrixColumn:function(wo,Co){if('number'===typeof wo){console.warn('THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).');var Do=wo;wo=Co,Co=Do}return this.fromArray(wo.elements,4*Co)},equals:function(wo){return wo.x===this.x&&wo.y===this.y&&wo.z===this.z},fromArray:function(wo,Co){return void 0===Co&&(Co=0),this.x=wo[Co],this.y=wo[Co+1],this.z=wo[Co+2],this},toArray:function(wo,Co){return void 0===wo&&(wo=[]),void 0===Co&&(Co=0),wo[Co]=this.x,wo[Co+1]=this.y,wo[Co+2]=this.z,wo},fromBufferAttribute:function(wo,Co,Do){return void 0!==Do&&console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().'),this.x=wo.getX(Co),this.y=wo.getY(Co),this.z=wo.getZ(Co),this}},S.prototype={constructor:S,isMatrix4:!0,set:function(wo,Co,Do,Uo,No,Io,zo,Fo,Bo,Oo,Go,Vo,Ho,ko,Wo,Xo){var Yo=this.elements;return Yo[0]=wo,Yo[4]=Co,Yo[8]=Do,Yo[12]=Uo,Yo[1]=No,Yo[5]=Io,Yo[9]=zo,Yo[13]=Fo,Yo[2]=Bo,Yo[6]=Oo,Yo[10]=Go,Yo[14]=Vo,Yo[3]=Ho,Yo[7]=ko,Yo[11]=Wo,Yo[15]=Xo,this},identity:function(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this},clone:function(){return new S().fromArray(this.elements)},copy:function(wo){return this.elements.set(wo.elements),this},copyPosition:function(wo){var Co=this.elements,Do=wo.elements;return Co[12]=Do[12],Co[13]=Do[13],Co[14]=Do[14],this},extractBasis:function(wo,Co,Do){return wo.setFromMatrixColumn(this,0),Co.setFromMatrixColumn(this,1),Do.setFromMatrixColumn(this,2),this},makeBasis:function(wo,Co,Do){return this.set(wo.x,Co.x,Do.x,0,wo.y,Co.y,Do.y,0,wo.z,Co.z,Do.z,0,0,0,0,1),this},extractRotation:function(){var wo;return function(Do){void 0===wo&&(wo=new E);var Uo=this.elements,No=Do.elements,Io=1/wo.setFromMatrixColumn(Do,0).length(),zo=1/wo.setFromMatrixColumn(Do,1).length(),Fo=1/wo.setFromMatrixColumn(Do,2).length();return Uo[0]=No[0]*Io,Uo[1]=No[1]*Io,Uo[2]=No[2]*Io,Uo[4]=No[4]*zo,Uo[5]=No[5]*zo,Uo[6]=No[6]*zo,Uo[8]=No[8]*Fo,Uo[9]=No[9]*Fo,Uo[10]=No[10]*Fo,this}}(),makeRotationFromEuler:function(wo){!1===(wo&&wo.isEuler)&&console.error('THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');var Co=this.elements,Do=wo.x,Uo=wo.y,No=wo.z,Io=Math.cos(Do),zo=Math.sin(Do),Fo=Math.cos(Uo),Bo=Math.sin(Uo),Oo=Math.cos(No),Go=Math.sin(No);if('XYZ'===wo.order){var Vo=Io*Oo,Ho=Io*Go,ko=zo*Oo,Wo=zo*Go;Co[0]=Fo*Oo,Co[4]=-Fo*Go,Co[8]=Bo,Co[1]=Ho+ko*Bo,Co[5]=Vo-Wo*Bo,Co[9]=-zo*Fo,Co[2]=Wo-Vo*Bo,Co[6]=ko+Ho*Bo,Co[10]=Io*Fo}else if('YXZ'===wo.order){var Xo=Fo*Oo,Yo=Fo*Go,jo=Bo*Oo,qo=Bo*Go;Co[0]=Xo+qo*zo,Co[4]=jo*zo-Yo,Co[8]=Io*Bo,Co[1]=Io*Go,Co[5]=Io*Oo,Co[9]=-zo,Co[2]=Yo*zo-jo,Co[6]=qo+Xo*zo,Co[10]=Io*Fo}else if('ZXY'===wo.order){var Xo=Fo*Oo,Yo=Fo*Go,jo=Bo*Oo,qo=Bo*Go;Co[0]=Xo-qo*zo,Co[4]=-Io*Go,Co[8]=jo+Yo*zo,Co[1]=Yo+jo*zo,Co[5]=Io*Oo,Co[9]=qo-Xo*zo,Co[2]=-Io*Bo,Co[6]=zo,Co[10]=Io*Fo}else if('ZYX'===wo.order){var Vo=Io*Oo,Ho=Io*Go,ko=zo*Oo,Wo=zo*Go;Co[0]=Fo*Oo,Co[4]=ko*Bo-Ho,Co[8]=Vo*Bo+Wo,Co[1]=Fo*Go,Co[5]=Wo*Bo+Vo,Co[9]=Ho*Bo-ko,Co[2]=-Bo,Co[6]=zo*Fo,Co[10]=Io*Fo}else if('YZX'===wo.order){var Zo=Io*Fo,Qo=Io*Bo,Jo=zo*Fo,Ko=zo*Bo;Co[0]=Fo*Oo,Co[4]=Ko-Zo*Go,Co[8]=Jo*Go+Qo,Co[1]=Go,Co[5]=Io*Oo,Co[9]=-zo*Oo,Co[2]=-Bo*Oo,Co[6]=Qo*Go+Jo,Co[10]=Zo-Ko*Go}else if('XZY'===wo.order){var Zo=Io*Fo,Qo=Io*Bo,Jo=zo*Fo,Ko=zo*Bo;Co[0]=Fo*Oo,Co[4]=-Go,Co[8]=Bo*Oo,Co[1]=Zo*Go+Ko,Co[5]=Io*Oo,Co[9]=Qo*Go-Jo,Co[2]=Jo*Go-Qo,Co[6]=zo*Oo,Co[10]=Ko*Go+Zo}return Co[3]=0,Co[7]=0,Co[11]=0,Co[12]=0,Co[13]=0,Co[14]=0,Co[15]=1,this},makeRotationFromQuaternion:function(wo){var Co=this.elements,Do=wo.x,Uo=wo.y,No=wo.z,Io=wo.w,zo=Do+Do,Fo=Uo+Uo,Bo=No+No,Oo=Do*zo,Go=Do*Fo,Vo=Do*Bo,Ho=Uo*Fo,ko=Uo*Bo,Wo=No*Bo,Xo=Io*zo,Yo=Io*Fo,jo=Io*Bo;return Co[0]=1-(Ho+Wo),Co[4]=Go-jo,Co[8]=Vo+Yo,Co[1]=Go+jo,Co[5]=1-(Oo+Wo),Co[9]=ko-Xo,Co[2]=Vo-Yo,Co[6]=ko+Xo,Co[10]=1-(Oo+Ho),Co[3]=0,Co[7]=0,Co[11]=0,Co[12]=0,Co[13]=0,Co[14]=0,Co[15]=1,this},lookAt:function(){var wo,Co,Do;return function(No,Io,zo){void 0===wo&&(wo=new E,Co=new E,Do=new E);var Fo=this.elements;return Do.subVectors(No,Io).normalize(),0===Do.lengthSq()&&(Do.z=1),wo.crossVectors(zo,Do).normalize(),0===wo.lengthSq()&&(Do.z+=1e-4,wo.crossVectors(zo,Do).normalize()),Co.crossVectors(Do,wo),Fo[0]=wo.x,Fo[4]=Co.x,Fo[8]=Do.x,Fo[1]=wo.y,Fo[5]=Co.y,Fo[9]=Do.y,Fo[2]=wo.z,Fo[6]=Co.z,Fo[10]=Do.z,this}}(),multiply:function(wo,Co){return void 0===Co?this.multiplyMatrices(this,wo):(console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.'),this.multiplyMatrices(wo,Co))},premultiply:function(wo){return this.multiplyMatrices(wo,this)},multiplyMatrices:function(wo,Co){var Do=wo.elements,Uo=Co.elements,No=this.elements,Io=Do[0],zo=Do[4],Fo=Do[8],Bo=Do[12],Oo=Do[1],Go=Do[5],Vo=Do[9],Ho=Do[13],ko=Do[2],Wo=Do[6],Xo=Do[10],Yo=Do[14],jo=Do[3],qo=Do[7],Zo=Do[11],Qo=Do[15],Jo=Uo[0],Ko=Uo[4],$o=Uo[8],es=Uo[12],ts=Uo[1],rs=Uo[5],as=Uo[9],is=Uo[13],ns=Uo[2],os=Uo[6],ss=Uo[10],ls=Uo[14],ds=Uo[3],cs=Uo[7],ps=Uo[11],us=Uo[15];return No[0]=Io*Jo+zo*ts+Fo*ns+Bo*ds,No[4]=Io*Ko+zo*rs+Fo*os+Bo*cs,No[8]=Io*$o+zo*as+Fo*ss+Bo*ps,No[12]=Io*es+zo*is+Fo*ls+Bo*us,No[1]=Oo*Jo+Go*ts+Vo*ns+Ho*ds,No[5]=Oo*Ko+Go*rs+Vo*os+Ho*cs,No[9]=Oo*$o+Go*as+Vo*ss+Ho*ps,No[13]=Oo*es+Go*is+Vo*ls+Ho*us,No[2]=ko*Jo+Wo*ts+Xo*ns+Yo*ds,No[6]=ko*Ko+Wo*rs+Xo*os+Yo*cs,No[10]=ko*$o+Wo*as+Xo*ss+Yo*ps,No[14]=ko*es+Wo*is+Xo*ls+Yo*us,No[3]=jo*Jo+qo*ts+Zo*ns+Qo*ds,No[7]=jo*Ko+qo*rs+Zo*os+Qo*cs,No[11]=jo*$o+qo*as+Zo*ss+Qo*ps,No[15]=jo*es+qo*is+Zo*ls+Qo*us,this},multiplyToArray:function(wo,Co,Do){var Uo=this.elements;return this.multiplyMatrices(wo,Co),Do[0]=Uo[0],Do[1]=Uo[1],Do[2]=Uo[2],Do[3]=Uo[3],Do[4]=Uo[4],Do[5]=Uo[5],Do[6]=Uo[6],Do[7]=Uo[7],Do[8]=Uo[8],Do[9]=Uo[9],Do[10]=Uo[10],Do[11]=Uo[11],Do[12]=Uo[12],Do[13]=Uo[13],Do[14]=Uo[14],Do[15]=Uo[15],this},multiplyScalar:function(wo){var Co=this.elements;return Co[0]*=wo,Co[4]*=wo,Co[8]*=wo,Co[12]*=wo,Co[1]*=wo,Co[5]*=wo,Co[9]*=wo,Co[13]*=wo,Co[2]*=wo,Co[6]*=wo,Co[10]*=wo,Co[14]*=wo,Co[3]*=wo,Co[7]*=wo,Co[11]*=wo,Co[15]*=wo,this},applyToBufferAttribute:function(){var wo;return function(Do){wo===void 0&&(wo=new E);for(var Uo=0,No=Do.count;Uo<No;Uo++)wo.x=Do.getX(Uo),wo.y=Do.getY(Uo),wo.z=Do.getZ(Uo),wo.applyMatrix4(this),Do.setXYZ(Uo,wo.x,wo.y,wo.z);return Do}}(),determinant:function(){var wo=this.elements,Co=wo[0],Do=wo[4],Uo=wo[8],No=wo[12],Io=wo[1],zo=wo[5],Fo=wo[9],Bo=wo[13],Oo=wo[2],Go=wo[6],Vo=wo[10],Ho=wo[14],ko=wo[3],Wo=wo[7],Xo=wo[11],Yo=wo[15];return ko*(+No*Fo*Go-Uo*Bo*Go-No*zo*Vo+Do*Bo*Vo+Uo*zo*Ho-Do*Fo*Ho)+Wo*(+Co*Fo*Ho-Co*Bo*Vo+No*Io*Vo-Uo*Io*Ho+Uo*Bo*Oo-No*Fo*Oo)+Xo*(+Co*Bo*Go-Co*zo*Ho-No*Io*Go+Do*Io*Ho+No*zo*Oo-Do*Bo*Oo)+Yo*(-Uo*zo*Oo-Co*Fo*Go+Co*zo*Vo+Uo*Io*Go-Do*Io*Vo+Do*Fo*Oo)},transpose:function(){var wo=this.elements,Co;return Co=wo[1],wo[1]=wo[4],wo[4]=Co,Co=wo[2],wo[2]=wo[8],wo[8]=Co,Co=wo[6],wo[6]=wo[9],wo[9]=Co,Co=wo[3],wo[3]=wo[12],wo[12]=Co,Co=wo[7],wo[7]=wo[13],wo[13]=Co,Co=wo[11],wo[11]=wo[14],wo[14]=Co,this},setPosition:function(wo){var Co=this.elements;return Co[12]=wo.x,Co[13]=wo.y,Co[14]=wo.z,this},getInverse:function(wo,Co){var Do=this.elements,Uo=wo.elements,No=Uo[0],Io=Uo[1],zo=Uo[2],Fo=Uo[3],Bo=Uo[4],Oo=Uo[5],Go=Uo[6],Vo=Uo[7],Ho=Uo[8],ko=Uo[9],Wo=Uo[10],Xo=Uo[11],Yo=Uo[12],jo=Uo[13],qo=Uo[14],Zo=Uo[15],Qo=ko*qo*Vo-jo*Wo*Vo+jo*Go*Xo-Oo*qo*Xo-ko*Go*Zo+Oo*Wo*Zo,Jo=Yo*Wo*Vo-Ho*qo*Vo-Yo*Go*Xo+Bo*qo*Xo+Ho*Go*Zo-Bo*Wo*Zo,Ko=Ho*jo*Vo-Yo*ko*Vo+Yo*Oo*Xo-Bo*jo*Xo-Ho*Oo*Zo+Bo*ko*Zo,$o=Yo*ko*Go-Ho*jo*Go-Yo*Oo*Wo+Bo*jo*Wo+Ho*Oo*qo-Bo*ko*qo,es=No*Qo+Io*Jo+zo*Ko+Fo*$o;if(0===es){var ts='THREE.Matrix4.getInverse(): can\'t invert matrix, determinant is 0';if(!0===Co)throw new Error(ts);else console.warn(ts);return this.identity()}var rs=1/es;return Do[0]=Qo*rs,Do[1]=(jo*Wo*Fo-ko*qo*Fo-jo*zo*Xo+Io*qo*Xo+ko*zo*Zo-Io*Wo*Zo)*rs,Do[2]=(Oo*qo*Fo-jo*Go*Fo+jo*zo*Vo-Io*qo*Vo-Oo*zo*Zo+Io*Go*Zo)*rs,Do[3]=(ko*Go*Fo-Oo*Wo*Fo-ko*zo*Vo+Io*Wo*Vo+Oo*zo*Xo-Io*Go*Xo)*rs,Do[4]=Jo*rs,Do[5]=(Ho*qo*Fo-Yo*Wo*Fo+Yo*zo*Xo-No*qo*Xo-Ho*zo*Zo+No*Wo*Zo)*rs,Do[6]=(Yo*Go*Fo-Bo*qo*Fo-Yo*zo*Vo+No*qo*Vo+Bo*zo*Zo-No*Go*Zo)*rs,Do[7]=(Bo*Wo*Fo-Ho*Go*Fo+Ho*zo*Vo-No*Wo*Vo-Bo*zo*Xo+No*Go*Xo)*rs,Do[8]=Ko*rs,Do[9]=(Yo*ko*Fo-Ho*jo*Fo-Yo*Io*Xo+No*jo*Xo+Ho*Io*Zo-No*ko*Zo)*rs,Do[10]=(Bo*jo*Fo-Yo*Oo*Fo+Yo*Io*Vo-No*jo*Vo-Bo*Io*Zo+No*Oo*Zo)*rs,Do[11]=(Ho*Oo*Fo-Bo*ko*Fo-Ho*Io*Vo+No*ko*Vo+Bo*Io*Xo-No*Oo*Xo)*rs,Do[12]=$o*rs,Do[13]=(Ho*jo*zo-Yo*ko*zo+Yo*Io*Wo-No*jo*Wo-Ho*Io*qo+No*ko*qo)*rs,Do[14]=(Yo*Oo*zo-Bo*jo*zo-Yo*Io*Go+No*jo*Go+Bo*Io*qo-No*Oo*qo)*rs,Do[15]=(Bo*ko*zo-Ho*Oo*zo+Ho*Io*Go-No*ko*Go-Bo*Io*Wo+No*Oo*Wo)*rs,this},scale:function(wo){var Co=this.elements,Do=wo.x,Uo=wo.y,No=wo.z;return Co[0]*=Do,Co[4]*=Uo,Co[8]*=No,Co[1]*=Do,Co[5]*=Uo,Co[9]*=No,Co[2]*=Do,Co[6]*=Uo,Co[10]*=No,Co[3]*=Do,Co[7]*=Uo,Co[11]*=No,this},getMaxScaleOnAxis:function(){var wo=this.elements,Co=wo[0]*wo[0]+wo[1]*wo[1]+wo[2]*wo[2],Do=wo[4]*wo[4]+wo[5]*wo[5]+wo[6]*wo[6],Uo=wo[8]*wo[8]+wo[9]*wo[9]+wo[10]*wo[10];return Math.sqrt(Math.max(Co,Do,Uo))},makeTranslation:function(wo,Co,Do){return this.set(1,0,0,wo,0,1,0,Co,0,0,1,Do,0,0,0,1),this},makeRotationX:function(wo){var Co=Math.cos(wo),Do=Math.sin(wo);return this.set(1,0,0,0,0,Co,-Do,0,0,Do,Co,0,0,0,0,1),this},makeRotationY:function(wo){var Co=Math.cos(wo),Do=Math.sin(wo);return this.set(Co,0,Do,0,0,1,0,0,-Do,0,Co,0,0,0,0,1),this},makeRotationZ:function(wo){var Co=Math.cos(wo),Do=Math.sin(wo);return this.set(Co,-Do,0,0,Do,Co,0,0,0,0,1,0,0,0,0,1),this},makeRotationAxis:function(wo,Co){var Do=Math.cos(Co),Uo=Math.sin(Co),No=1-Do,Io=wo.x,zo=wo.y,Fo=wo.z,Bo=No*Io,Oo=No*zo;return this.set(Bo*Io+Do,Bo*zo-Uo*Fo,Bo*Fo+Uo*zo,0,Bo*zo+Uo*Fo,Oo*zo+Do,Oo*Fo-Uo*Io,0,Bo*Fo-Uo*zo,Oo*Fo+Uo*Io,No*Fo*Fo+Do,0,0,0,0,1),this},makeScale:function(wo,Co,Do){return this.set(wo,0,0,0,0,Co,0,0,0,0,Do,0,0,0,0,1),this},makeShear:function(wo,Co,Do){return this.set(1,Co,Do,0,wo,1,Do,0,wo,Co,1,0,0,0,0,1),this},compose:function(wo,Co,Do){return this.makeRotationFromQuaternion(Co),this.scale(Do),this.setPosition(wo),this},decompose:function(){var wo,Co;return function(Uo,No,Io){void 0===wo&&(wo=new E,Co=new S);var zo=this.elements,Fo=wo.set(zo[0],zo[1],zo[2]).length(),Bo=wo.set(zo[4],zo[5],zo[6]).length(),Oo=wo.set(zo[8],zo[9],zo[10]).length(),Go=this.determinant();0>Go&&(Fo=-Fo),Uo.x=zo[12],Uo.y=zo[13],Uo.z=zo[14],Co.elements.set(this.elements);var Vo=1/Fo,Ho=1/Bo,ko=1/Oo;return Co.elements[0]*=Vo,Co.elements[1]*=Vo,Co.elements[2]*=Vo,Co.elements[4]*=Ho,Co.elements[5]*=Ho,Co.elements[6]*=Ho,Co.elements[8]*=ko,Co.elements[9]*=ko,Co.elements[10]*=ko,No.setFromRotationMatrix(Co),Io.x=Fo,Io.y=Bo,Io.z=Oo,this}}(),makePerspective:function(wo,Co,Do,Uo,No,Io){void 0===Io&&console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');var zo=this.elements;return zo[0]=2*No/(Co-wo),zo[4]=0,zo[8]=(Co+wo)/(Co-wo),zo[12]=0,zo[1]=0,zo[5]=2*No/(Do-Uo),zo[9]=(Do+Uo)/(Do-Uo),zo[13]=0,zo[2]=0,zo[6]=0,zo[10]=-(Io+No)/(Io-No),zo[14]=-2*Io*No/(Io-No),zo[3]=0,zo[7]=0,zo[11]=-1,zo[15]=0,this},makeOrthographic:function(wo,Co,Do,Uo,No,Io){var zo=this.elements,Fo=1/(Co-wo),Bo=1/(Do-Uo),Oo=1/(Io-No);return zo[0]=2*Fo,zo[4]=0,zo[8]=0,zo[12]=-((Co+wo)*Fo),zo[1]=0,zo[5]=2*Bo,zo[9]=0,zo[13]=-((Do+Uo)*Bo),zo[2]=0,zo[6]=0,zo[10]=-2*Oo,zo[14]=-((Io+No)*Oo),zo[3]=0,zo[7]=0,zo[11]=0,zo[15]=1,this},equals:function(wo){for(var Co=this.elements,Do=wo.elements,Uo=0;16>Uo;Uo++)if(Co[Uo]!==Do[Uo])return!1;return!0},fromArray:function(wo,Co){Co===void 0&&(Co=0);for(var Do=0;16>Do;Do++)this.elements[Do]=wo[Do+Co];return this},toArray:function(wo,Co){void 0===wo&&(wo=[]),void 0===Co&&(Co=0);var Do=this.elements;return wo[Co]=Do[0],wo[Co+1]=Do[1],wo[Co+2]=Do[2],wo[Co+3]=Do[3],wo[Co+4]=Do[4],wo[Co+5]=Do[5],wo[Co+6]=Do[6],wo[Co+7]=Do[7],wo[Co+8]=Do[8],wo[Co+9]=Do[9],wo[Co+10]=Do[10],wo[Co+11]=Do[11],wo[Co+12]=Do[12],wo[Co+13]=Do[13],wo[Co+14]=Do[14],wo[Co+15]=Do[15],wo}},M.prototype={addEventListener:function(wo,Co){this._listeners===void 0&&(this._listeners={});var Do=this._listeners;Do[wo]===void 0&&(Do[wo]=[]),-1===Do[wo].indexOf(Co)&&Do[wo].push(Co)},hasEventListener:function(wo,Co){if(this._listeners===void 0)return!1;var Do=this._listeners;return Do[wo]!==void 0&&-1!==Do[wo].indexOf(Co)},removeEventListener:function(wo,Co){if(void 0!==this._listeners){var Do=this._listeners,Uo=Do[wo];if(void 0!==Uo){var No=Uo.indexOf(Co);-1!==No&&Uo.splice(No,1)}}},dispatchEvent:function(wo){if(void 0!==this._listeners){var Co=this._listeners,Do=Co[wo.type];if(void 0!==Do){wo.target=this;var Uo=[],No=0,Io=Do.length;for(No=0;No<Io;No++)Uo[No]=Do[No];for(No=0;No<Io;No++)Uo[No].call(this,wo)}}}},T.prototype={constructor:T,isVector2:!0,get width(){return this.x},set width(wo){this.x=wo},get height(){return this.y},set height(wo){this.y=wo},set:function(wo,Co){return this.x=wo,this.y=Co,this},setScalar:function(wo){return this.x=wo,this.y=wo,this},setX:function(wo){return this.x=wo,this},setY:function(wo){return this.y=wo,this},setComponent:function(wo,Co){switch(wo){case 0:this.x=Co;break;case 1:this.y=Co;break;default:throw new Error('index is out of range: '+wo);}return this},getComponent:function(wo){switch(wo){case 0:return this.x;case 1:return this.y;default:throw new Error('index is out of range: '+wo);}},clone:function(){return new this.constructor(this.x,this.y)},copy:function(wo){return this.x=wo.x,this.y=wo.y,this},add:function(wo,Co){return void 0===Co?(this.x+=wo.x,this.y+=wo.y,this):(console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.'),this.addVectors(wo,Co))},addScalar:function(wo){return this.x+=wo,this.y+=wo,this},addVectors:function(wo,Co){return this.x=wo.x+Co.x,this.y=wo.y+Co.y,this},addScaledVector:function(wo,Co){return this.x+=wo.x*Co,this.y+=wo.y*Co,this},sub:function(wo,Co){return void 0===Co?(this.x-=wo.x,this.y-=wo.y,this):(console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'),this.subVectors(wo,Co))},subScalar:function(wo){return this.x-=wo,this.y-=wo,this},subVectors:function(wo,Co){return this.x=wo.x-Co.x,this.y=wo.y-Co.y,this},multiply:function(wo){return this.x*=wo.x,this.y*=wo.y,this},multiplyScalar:function(wo){return isFinite(wo)?(this.x*=wo,this.y*=wo):(this.x=0,this.y=0),this},divide:function(wo){return this.x/=wo.x,this.y/=wo.y,this},divideScalar:function(wo){return this.multiplyScalar(1/wo)},min:function(wo){return this.x=Math.min(this.x,wo.x),this.y=Math.min(this.y,wo.y),this},max:function(wo){return this.x=Math.max(this.x,wo.x),this.y=Math.max(this.y,wo.y),this},clamp:function(wo,Co){return this.x=Math.max(wo.x,Math.min(Co.x,this.x)),this.y=Math.max(wo.y,Math.min(Co.y,this.y)),this},clampScalar:function(){var wo,Co;return function(Uo,No){return void 0===wo&&(wo=new T,Co=new T),wo.set(Uo,Uo),Co.set(No,No),this.clamp(wo,Co)}}(),clampLength:function(wo,Co){var Do=this.length();return this.multiplyScalar(Math.max(wo,Math.min(Co,Do))/Do)},floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this},ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this},round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this},roundToZero:function(){return this.x=0>this.x?Math.ceil(this.x):Math.floor(this.x),this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y),this},negate:function(){return this.x=-this.x,this.y=-this.y,this},dot:function(wo){return this.x*wo.x+this.y*wo.y},lengthSq:function(){return this.x*this.x+this.y*this.y},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},lengthManhattan:function(){return Math.abs(this.x)+Math.abs(this.y)},normalize:function(){return this.divideScalar(this.length())},angle:function(){var wo=Math.atan2(this.y,this.x);return 0>wo&&(wo+=2*Math.PI),wo},distanceTo:function(wo){return Math.sqrt(this.distanceToSquared(wo))},distanceToSquared:function(wo){var Co=this.x-wo.x,Do=this.y-wo.y;return Co*Co+Do*Do},distanceToManhattan:function(wo){return Math.abs(this.x-wo.x)+Math.abs(this.y-wo.y)},setLength:function(wo){return this.multiplyScalar(wo/this.length())},lerp:function(wo,Co){return this.x+=(wo.x-this.x)*Co,this.y+=(wo.y-this.y)*Co,this},lerpVectors:function(wo,Co,Do){return this.subVectors(Co,wo).multiplyScalar(Do).add(wo)},equals:function(wo){return wo.x===this.x&&wo.y===this.y},fromArray:function(wo,Co){return void 0===Co&&(Co=0),this.x=wo[Co],this.y=wo[Co+1],this},toArray:function(wo,Co){return void 0===wo&&(wo=[]),void 0===Co&&(Co=0),wo[Co]=this.x,wo[Co+1]=this.y,wo},fromBufferAttribute:function(wo,Co,Do){return void 0!==Do&&console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().'),this.x=wo.getX(Co),this.y=wo.getY(Co),this},rotateAround:function(wo,Co){var Do=Math.cos(Co),Uo=Math.sin(Co),No=this.x-wo.x,Io=this.y-wo.y;return this.x=No*Do-Io*Uo+wo.x,this.y=No*Uo+Io*Do+wo.y,this}};var pi=0;L.DEFAULT_IMAGE=void 0,L.DEFAULT_MAPPING=Zr,L.prototype={constructor:L,isTexture:!0,set needsUpdate(wo){!0===wo&&this.version++},clone:function(){return new this.constructor().copy(this)},copy:function(wo){return this.image=wo.image,this.mipmaps=wo.mipmaps.slice(0),this.mapping=wo.mapping,this.wrapS=wo.wrapS,this.wrapT=wo.wrapT,this.magFilter=wo.magFilter,this.minFilter=wo.minFilter,this.anisotropy=wo.anisotropy,this.format=wo.format,this.type=wo.type,this.offset.copy(wo.offset),this.repeat.copy(wo.repeat),this.generateMipmaps=wo.generateMipmaps,this.premultiplyAlpha=wo.premultiplyAlpha,this.flipY=wo.flipY,this.unpackAlignment=wo.unpackAlignment,this.encoding=wo.encoding,this},toJSON:function(wo){function Co(No){var Io;return void 0===No.toDataURL?(Io=document.createElementNS('http://www.w3.org/1999/xhtml','canvas'),Io.width=No.width,Io.height=No.height,Io.getContext('2d').drawImage(No,0,0,No.width,No.height)):Io=No,2048<Io.width||2048<Io.height?Io.toDataURL('image/jpeg',0.6):Io.toDataURL('image/png')}if(void 0!==wo.textures[this.uuid])return wo.textures[this.uuid];var Do={metadata:{version:4.4,type:'Texture',generator:'Texture.toJSON'},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],wrap:[this.wrapS,this.wrapT],minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY};if(void 0!==this.image){var Uo=this.image;void 0===Uo.uuid&&(Uo.uuid=ci.generateUUID()),void 0===wo.images[Uo.uuid]&&(wo.images[Uo.uuid]={uuid:Uo.uuid,url:Co(Uo)}),Do.image=Uo.uuid}return wo.textures[this.uuid]=Do,Do},dispose:function(){this.dispatchEvent({type:'dispose'})},transformUv:function(wo){if(this.mapping===Zr){if(wo.multiply(this.repeat),wo.add(this.offset),0>wo.x||1<wo.x)switch(this.wrapS){case aa:wo.x-=Math.floor(wo.x);break;case ia:wo.x=0>wo.x?0:1;break;case na:1===Math.abs(Math.floor(wo.x)%2)?wo.x=Math.ceil(wo.x)-wo.x:wo.x-=Math.floor(wo.x);}if(0>wo.y||1<wo.y)switch(this.wrapT){case aa:wo.y-=Math.floor(wo.y);break;case ia:wo.y=0>wo.y?0:1;break;case na:1===Math.abs(Math.floor(wo.y)%2)?wo.y=Math.ceil(wo.y)-wo.y:wo.y-=Math.floor(wo.y);}this.flipY&&(wo.y=1-wo.y)}}},Object.assign(L.prototype,M.prototype),A.prototype=Object.create(L.prototype),A.prototype.constructor=A,A.prototype.isCubeTexture=!0,Object.defineProperty(A.prototype,'images',{get:function(){return this.image},set:function(wo){this.image=wo}});var ui=new L,mi=new A,fi=[],gi=[];fe.prototype.setValue=function(wo,Co){for(var Do=this.seq,Uo=0,No=Do.length,Io;Uo!==No;++Uo)Io=Do[Uo],Io.setValue(wo,Co[Io.id])};var hi=/([\w\d_]+)(\])?(\[|\.)?/g;xe.prototype.setValue=function(wo,Co,Do){var Uo=this.map[Co];Uo!==void 0&&Uo.setValue(wo,Do,this.renderer)},xe.prototype.set=function(wo,Co,Do){var Uo=this.map[Do];Uo!==void 0&&Uo.setValue(wo,Co[Do],this.renderer)},xe.prototype.setOptional=function(wo,Co,Do){var Uo=Co[Do];Uo!==void 0&&this.setValue(wo,Do,Uo)},xe.upload=function(wo,Co,Do,Uo){for(var No=0,Io=Co.length;No!==Io;++No){var zo=Co[No],Fo=Do[zo.id];!1!==Fo.needsUpdate&&zo.setValue(wo,Fo.value,Uo)}},xe.seqWithValue=function(wo,Co){for(var Do=[],Uo=0,No=wo.length,Io;Uo!==No;++Uo)Io=wo[Uo],Io.id in Co&&Do.push(Io);return Do};var xi={merge:function(wo){for(var Co={},Do=0,Uo;Do<wo.length;Do++)for(var No in Uo=this.clone(wo[Do]),Uo)Co[No]=Uo[No];return Co},clone:function(wo){var Co={};for(var Do in wo)for(var Uo in Co[Do]={},wo[Do]){var No=wo[Do][Uo];Co[Do][Uo]=No&&(No.isColor||No.isMatrix3||No.isMatrix4||No.isVector2||No.isVector3||No.isVector4||No.isTexture)?No.clone():Array.isArray(No)?No.slice():No}return Co}},yo={alphamap_fragment:'#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n',alphamap_pars_fragment:'#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n',alphatest_fragment:'#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n',aomap_fragment:'#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n',aomap_pars_fragment:'#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif',begin_vertex:'\nvec3 transformed = vec3( position );\n',beginnormal_vertex:'\nvec3 objectNormal = vec3( normal );\n',bsdfs:'float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 ltcTextureCoords( const in GeometricContext geometry, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = (LUT_SIZE - 1.0)/LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5/LUT_SIZE;\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nvoid clipQuadToHorizon( inout vec3 L[5], out int n ) {\n\tint config = 0;\n\tif ( L[0].z > 0.0 ) config += 1;\n\tif ( L[1].z > 0.0 ) config += 2;\n\tif ( L[2].z > 0.0 ) config += 4;\n\tif ( L[3].z > 0.0 ) config += 8;\n\tn = 0;\n\tif ( config == 0 ) {\n\t} else if ( config == 1 ) {\n\t\tn = 3;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 2 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 3 ) {\n\t\tn = 4;\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t\tL[3] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 4 ) {\n\t\tn = 3;\n\t\tL[0] = -L[3].z * L[2] + L[2].z * L[3];\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t} else if ( config == 5 ) {\n\t\tn = 0;\n\t} else if ( config == 6 ) {\n\t\tn = 4;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 7 ) {\n\t\tn = 5;\n\t\tL[4] = -L[3].z * L[0] + L[0].z * L[3];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 8 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[1] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] =  L[3];\n\t} else if ( config == 9 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[2].z * L[3] + L[3].z * L[2];\n\t} else if ( config == 10 ) {\n\t\tn = 0;\n\t} else if ( config == 11 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 12 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t} else if ( config == 13 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = L[2];\n\t\tL[2] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t} else if ( config == 14 ) {\n\t\tn = 5;\n\t\tL[4] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t} else if ( config == 15 ) {\n\t\tn = 4;\n\t}\n\tif ( n == 3 )\n\t\tL[3] = L[0];\n\tif ( n == 4 )\n\t\tL[4] = L[0];\n}\nfloat integrateLtcBrdfOverRectEdge( vec3 v1, vec3 v2 ) {\n\tfloat cosTheta = dot( v1, v2 );\n\tfloat theta = acos( cosTheta );\n\tfloat res = cross( v1, v2 ).z * ( ( theta > 0.001 ) ? theta / sin( theta ) : 1.0 );\n\treturn res;\n}\nvoid initRectPoints( const in vec3 pos, const in vec3 halfWidth, const in vec3 halfHeight, out vec3 rectPoints[4] ) {\n\trectPoints[0] = pos - halfWidth - halfHeight;\n\trectPoints[1] = pos + halfWidth - halfHeight;\n\trectPoints[2] = pos + halfWidth + halfHeight;\n\trectPoints[3] = pos - halfWidth + halfHeight;\n}\nvec3 integrateLtcBrdfOverRect( const in GeometricContext geometry, const in mat3 brdfMat, const in vec3 rectPoints[4] ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tvec3 T1, T2;\n\tT1 = normalize(V - N * dot( V, N ));\n\tT2 = - cross( N, T1 );\n\tmat3 brdfWrtSurface = brdfMat * transpose( mat3( T1, T2, N ) );\n\tvec3 clippedRect[5];\n\tclippedRect[0] = brdfWrtSurface * ( rectPoints[0] - P );\n\tclippedRect[1] = brdfWrtSurface * ( rectPoints[1] - P );\n\tclippedRect[2] = brdfWrtSurface * ( rectPoints[2] - P );\n\tclippedRect[3] = brdfWrtSurface * ( rectPoints[3] - P );\n\tint n;\n\tclipQuadToHorizon(clippedRect, n);\n\tif ( n == 0 )\n\t\treturn vec3( 0, 0, 0 );\n\tclippedRect[0] = normalize( clippedRect[0] );\n\tclippedRect[1] = normalize( clippedRect[1] );\n\tclippedRect[2] = normalize( clippedRect[2] );\n\tclippedRect[3] = normalize( clippedRect[3] );\n\tclippedRect[4] = normalize( clippedRect[4] );\n\tfloat sum = 0.0;\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[0], clippedRect[1] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[1], clippedRect[2] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[2], clippedRect[3] );\n\tif (n >= 4)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[3], clippedRect[4] );\n\tif (n == 5)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[4], clippedRect[0] );\n\tsum = max( 0.0, sum );\n\tvec3 Lo_i = vec3( sum, sum, sum );\n\treturn Lo_i;\n}\nvec3 Rect_Area_Light_Specular_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight,\n\t\tconst in float roughness,\n\t\tconst in sampler2D ltcMat, const in sampler2D ltcMag ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tvec2 uv = ltcTextureCoords( geometry, roughness );\n\tvec4 brdfLtcApproxParams, t;\n\tbrdfLtcApproxParams = texture2D( ltcMat, uv );\n\tt = texture2D( ltcMat, uv );\n\tfloat brdfLtcScalar = texture2D( ltcMag, uv ).a;\n\tmat3 brdfLtcApproxMat = mat3(\n\t\tvec3(   1,   0, t.y ),\n\t\tvec3(   0, t.z,   0 ),\n\t\tvec3( t.w,   0, t.x )\n\t);\n\tvec3 specularReflectance = integrateLtcBrdfOverRect( geometry, brdfLtcApproxMat, rectPoints );\n\tspecularReflectance *= brdfLtcScalar;\n\treturn specularReflectance;\n}\nvec3 Rect_Area_Light_Diffuse_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tmat3 diffuseBrdfMat = mat3(1);\n\tvec3 diffuseReflectance = integrateLtcBrdfOverRect( geometry, diffuseBrdfMat, rectPoints );\n\treturn diffuseReflectance;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n',bumpmap_pars_fragment:'#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n',clipping_planes_fragment:'#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n',clipping_planes_pars_fragment:'#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n',clipping_planes_pars_vertex:'#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n',clipping_planes_vertex:'#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n',color_fragment:'#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif',color_pars_fragment:'#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n',color_pars_vertex:'#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif',color_vertex:'#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif',common:'#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n',cube_uv_reflection_fragment:'#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n',defaultnormal_vertex:'#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n',displacementmap_pars_vertex:'#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n',displacementmap_vertex:'#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n',emissivemap_fragment:'#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n',emissivemap_pars_fragment:'#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n',encodings_fragment:'  gl_FragColor = linearToOutputTexel( gl_FragColor );\n',encodings_pars_fragment:'\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n',envmap_fragment:'#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n',envmap_pars_fragment:'#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n',envmap_pars_vertex:'#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n',envmap_vertex:'#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n',fog_vertex:'\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif',fog_pars_vertex:'#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n',fog_fragment:'#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n',fog_pars_fragment:'#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n',gradientmap_pars_fragment:'#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n',lightmap_fragment:'#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n',lightmap_pars_fragment:'#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif',lights_lambert_vertex:'vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n',lights_pars:'uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n',lights_phong_fragment:'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n',lights_phong_pars_fragment:'varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_BlinnPhong( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 matDiffColor = material.diffuseColor;\n\t\tvec3 matSpecColor = material.specularColor;\n\t\tvec3 lightColor   = rectAreaLight.color;\n\t\tfloat roughness = BlinnExponentToGGXRoughness( material.specularShininess );\n\t\tvec3 spec = Rect_Area_Light_Specular_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n\t\t\t\troughness,\n\t\t\t\tltcMat, ltcMag );\n\t\tvec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n\t\treflectedLight.directSpecular += lightColor * matSpecColor * spec / PI2;\n\t\treflectedLight.directDiffuse  += lightColor * matDiffColor * diff / PI2;\n\t}\n#endif\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n',lights_physical_fragment:'PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n',lights_physical_pars_fragment:'struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 matDiffColor = material.diffuseColor;\n\t\tvec3 matSpecColor = material.specularColor;\n\t\tvec3 lightColor   = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 spec = Rect_Area_Light_Specular_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n\t\t\t\troughness,\n\t\t\t\tltcMat, ltcMag );\n\t\tvec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n\t\treflectedLight.directSpecular += lightColor * matSpecColor * spec;\n\t\treflectedLight.directDiffuse  += lightColor * matDiffColor * diff;\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n',lights_template:'\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n',logdepthbuf_fragment:'#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif',logdepthbuf_pars_fragment:'#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n',logdepthbuf_pars_vertex:'#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif',logdepthbuf_vertex:'#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n',map_fragment:'#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n',map_pars_fragment:'#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n',map_particle_fragment:'#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n',map_particle_pars_fragment:'#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n',metalnessmap_fragment:'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n',metalnessmap_pars_fragment:'#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif',morphnormal_vertex:'#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n',morphtarget_pars_vertex:'#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif',morphtarget_vertex:'#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n',normal_flip:'#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n',normal_fragment:'#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n',normalmap_pars_fragment:'#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n',packing:'vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n',premultiplied_alpha_fragment:'#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n',project_vertex:'#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n',roughnessmap_fragment:'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n',roughnessmap_pars_fragment:'#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif',shadowmap_pars_fragment:'#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n',shadowmap_pars_vertex:'#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n',shadowmap_vertex:'#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n',shadowmask_pars_fragment:'float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n',skinbase_vertex:'#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif',skinning_pars_vertex:'#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n',skinning_vertex:'#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n',skinnormal_vertex:'#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n',specularmap_fragment:'float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif',specularmap_pars_fragment:'#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif',tonemapping_fragment:'#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n',tonemapping_pars_fragment:'#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n',uv_pars_fragment:'#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif',uv_pars_vertex:'#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n',uv_vertex:'#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif',uv2_pars_fragment:'#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif',uv2_pars_vertex:'#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif',uv2_vertex:'#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif',worldpos_vertex:'#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n',cube_frag:'uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n',cube_vert:'varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n',depth_frag:'#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n',depth_vert:'#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n',distanceRGBA_frag:'uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n',distanceRGBA_vert:'varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n',equirect_frag:'uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n',equirect_vert:'varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n',linedashed_frag:'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n',linedashed_vert:'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n',meshbasic_frag:'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n',meshbasic_vert:'#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n',meshlambert_frag:'uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n',meshlambert_vert:'#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n',meshphong_frag:'#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n',meshphong_vert:'#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n',meshphysical_frag:'#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n',meshphysical_vert:'#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n',normal_frag:'#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n',normal_vert:'#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n',points_frag:'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n',points_vert:'uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n',shadow_frag:'uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\n}\n',shadow_vert:'#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n'};_e.prototype={constructor:_e,isVector4:!0,set:function(wo,Co,Do,Uo){return this.x=wo,this.y=Co,this.z=Do,this.w=Uo,this},setScalar:function(wo){return this.x=wo,this.y=wo,this.z=wo,this.w=wo,this},setX:function(wo){return this.x=wo,this},setY:function(wo){return this.y=wo,this},setZ:function(wo){return this.z=wo,this},setW:function(wo){return this.w=wo,this},setComponent:function(wo,Co){switch(wo){case 0:this.x=Co;break;case 1:this.y=Co;break;case 2:this.z=Co;break;case 3:this.w=Co;break;default:throw new Error('index is out of range: '+wo);}return this},getComponent:function(wo){switch(wo){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error('index is out of range: '+wo);}},clone:function(){return new this.constructor(this.x,this.y,this.z,this.w)},copy:function(wo){return this.x=wo.x,this.y=wo.y,this.z=wo.z,this.w=void 0===wo.w?1:wo.w,this},add:function(wo,Co){return void 0===Co?(this.x+=wo.x,this.y+=wo.y,this.z+=wo.z,this.w+=wo.w,this):(console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.'),this.addVectors(wo,Co))},addScalar:function(wo){return this.x+=wo,this.y+=wo,this.z+=wo,this.w+=wo,this},addVectors:function(wo,Co){return this.x=wo.x+Co.x,this.y=wo.y+Co.y,this.z=wo.z+Co.z,this.w=wo.w+Co.w,this},addScaledVector:function(wo,Co){return this.x+=wo.x*Co,this.y+=wo.y*Co,this.z+=wo.z*Co,this.w+=wo.w*Co,this},sub:function(wo,Co){return void 0===Co?(this.x-=wo.x,this.y-=wo.y,this.z-=wo.z,this.w-=wo.w,this):(console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'),this.subVectors(wo,Co))},subScalar:function(wo){return this.x-=wo,this.y-=wo,this.z-=wo,this.w-=wo,this},subVectors:function(wo,Co){return this.x=wo.x-Co.x,this.y=wo.y-Co.y,this.z=wo.z-Co.z,this.w=wo.w-Co.w,this},multiplyScalar:function(wo){return isFinite(wo)?(this.x*=wo,this.y*=wo,this.z*=wo,this.w*=wo):(this.x=0,this.y=0,this.z=0,this.w=0),this},applyMatrix4:function(wo){var Co=this.x,Do=this.y,Uo=this.z,No=this.w,Io=wo.elements;return this.x=Io[0]*Co+Io[4]*Do+Io[8]*Uo+Io[12]*No,this.y=Io[1]*Co+Io[5]*Do+Io[9]*Uo+Io[13]*No,this.z=Io[2]*Co+Io[6]*Do+Io[10]*Uo+Io[14]*No,this.w=Io[3]*Co+Io[7]*Do+Io[11]*Uo+Io[15]*No,this},divideScalar:function(wo){return this.multiplyScalar(1/wo)},setAxisAngleFromQuaternion:function(wo){this.w=2*Math.acos(wo.w);var Co=Math.sqrt(1-wo.w*wo.w);return 1e-4>Co?(this.x=1,this.y=0,this.z=0):(this.x=wo.x/Co,this.y=wo.y/Co,this.z=wo.z/Co),this},setAxisAngleFromRotationMatrix:function(wo){var Io=0.01,zo=0.1,Fo=wo.elements,Bo=Fo[0],Oo=Fo[4],Go=Fo[8],Vo=Fo[1],Ho=Fo[5],ko=Fo[9],Wo=Fo[2],Xo=Fo[6],Yo=Fo[10],Co,Do,Uo,No;if(Math.abs(Oo-Vo)<Io&&Math.abs(Go-Wo)<Io&&Math.abs(ko-Xo)<Io){if(Math.abs(Oo+Vo)<zo&&Math.abs(Go+Wo)<zo&&Math.abs(ko+Xo)<zo&&Math.abs(Bo+Ho+Yo-3)<zo)return this.set(1,0,0,0),this;Co=Math.PI;var jo=(Bo+1)/2,qo=(Ho+1)/2,Zo=(Yo+1)/2,Qo=(Oo+Vo)/4,Jo=(Go+Wo)/4,Ko=(ko+Xo)/4;return jo>qo&&jo>Zo?jo<Io?(Do=0,Uo=0.707106781,No=0.707106781):(Do=Math.sqrt(jo),Uo=Qo/Do,No=Jo/Do):qo>Zo?qo<Io?(Do=0.707106781,Uo=0,No=0.707106781):(Uo=Math.sqrt(qo),Do=Qo/Uo,No=Ko/Uo):Zo<Io?(Do=0.707106781,Uo=0.707106781,No=0):(No=Math.sqrt(Zo),Do=Jo/No,Uo=Ko/No),this.set(Do,Uo,No,Co),this}var $o=Math.sqrt((Xo-ko)*(Xo-ko)+(Go-Wo)*(Go-Wo)+(Vo-Oo)*(Vo-Oo));return 1e-3>Math.abs($o)&&($o=1),this.x=(Xo-ko)/$o,this.y=(Go-Wo)/$o,this.z=(Vo-Oo)/$o,this.w=Math.acos((Bo+Ho+Yo-1)/2),this},min:function(wo){return this.x=Math.min(this.x,wo.x),this.y=Math.min(this.y,wo.y),this.z=Math.min(this.z,wo.z),this.w=Math.min(this.w,wo.w),this},max:function(wo){return this.x=Math.max(this.x,wo.x),this.y=Math.max(this.y,wo.y),this.z=Math.max(this.z,wo.z),this.w=Math.max(this.w,wo.w),this},clamp:function(wo,Co){return this.x=Math.max(wo.x,Math.min(Co.x,this.x)),this.y=Math.max(wo.y,Math.min(Co.y,this.y)),this.z=Math.max(wo.z,Math.min(Co.z,this.z)),this.w=Math.max(wo.w,Math.min(Co.w,this.w)),this},clampScalar:function(){var wo,Co;return function(Uo,No){return void 0===wo&&(wo=new _e,Co=new _e),wo.set(Uo,Uo,Uo,Uo),Co.set(No,No,No,No),this.clamp(wo,Co)}}(),floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this},ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this},round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this},roundToZero:function(){return this.x=0>this.x?Math.ceil(this.x):Math.floor(this.x),this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y),this.z=0>this.z?Math.ceil(this.z):Math.floor(this.z),this.w=0>this.w?Math.ceil(this.w):Math.floor(this.w),this},negate:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this},dot:function(wo){return this.x*wo.x+this.y*wo.y+this.z*wo.z+this.w*wo.w},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)},lengthManhattan:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)},normalize:function(){return this.divideScalar(this.length())},setLength:function(wo){return this.multiplyScalar(wo/this.length())},lerp:function(wo,Co){return this.x+=(wo.x-this.x)*Co,this.y+=(wo.y-this.y)*Co,this.z+=(wo.z-this.z)*Co,this.w+=(wo.w-this.w)*Co,this},lerpVectors:function(wo,Co,Do){return this.subVectors(Co,wo).multiplyScalar(Do).add(wo)},equals:function(wo){return wo.x===this.x&&wo.y===this.y&&wo.z===this.z&&wo.w===this.w},fromArray:function(wo,Co){return void 0===Co&&(Co=0),this.x=wo[Co],this.y=wo[Co+1],this.z=wo[Co+2],this.w=wo[Co+3],this},toArray:function(wo,Co){return void 0===wo&&(wo=[]),void 0===Co&&(Co=0),wo[Co]=this.x,wo[Co+1]=this.y,wo[Co+2]=this.z,wo[Co+3]=this.w,wo},fromBufferAttribute:function(wo,Co,Do){return void 0!==Do&&console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().'),this.x=wo.getX(Co),this.y=wo.getY(Co),this.z=wo.getZ(Co),this.w=wo.getW(Co),this}},ve.prototype={constructor:ve,isColor:!0,r:1,g:1,b:1,set:function(wo){return wo&&wo.isColor?this.copy(wo):'number'===typeof wo?this.setHex(wo):'string'===typeof wo&&this.setStyle(wo),this},setScalar:function(wo){return this.r=wo,this.g=wo,this.b=wo,this},setHex:function(wo){return wo=Math.floor(wo),this.r=(255&wo>>16)/255,this.g=(255&wo>>8)/255,this.b=(255&wo)/255,this},setRGB:function(wo,Co,Do){return this.r=wo,this.g=Co,this.b=Do,this},setHSL:function(){function wo(Co,Do,Uo){return 0>Uo&&(Uo+=1),1<Uo&&(Uo-=1),Uo<1/6?Co+6*(Do-Co)*Uo:Uo<1/2?Do:Uo<2/3?Co+6*(Do-Co)*(2/3-Uo):Co}return function(Do,Uo,No){if(Do=ci.euclideanModulo(Do,1),Uo=ci.clamp(Uo,0,1),No=ci.clamp(No,0,1),0===Uo)this.r=this.g=this.b=No;else{var Io=0.5>=No?No*(1+Uo):No+Uo-No*Uo,zo=2*No-Io;this.r=wo(zo,Io,Do+1/3),this.g=wo(zo,Io,Do),this.b=wo(zo,Io,Do-1/3)}return this}}(),setStyle:function(wo){function Co(Vo){void 0===Vo||1>parseFloat(Vo)&&console.warn('THREE.Color: Alpha component of '+wo+' will be ignored.')}var Do;if(Do=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(wo)){var Uo,No=Do[1],Io=Do[2];switch(No){case'rgb':case'rgba':if(Uo=/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(Io))return this.r=Math.min(255,parseInt(Uo[1],10))/255,this.g=Math.min(255,parseInt(Uo[2],10))/255,this.b=Math.min(255,parseInt(Uo[3],10))/255,Co(Uo[5]),this;if(Uo=/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(Io))return this.r=Math.min(100,parseInt(Uo[1],10))/100,this.g=Math.min(100,parseInt(Uo[2],10))/100,this.b=Math.min(100,parseInt(Uo[3],10))/100,Co(Uo[5]),this;break;case'hsl':case'hsla':if(Uo=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(Io)){var zo=parseFloat(Uo[1])/360,Fo=parseInt(Uo[2],10)/100,Bo=parseInt(Uo[3],10)/100;return Co(Uo[5]),this.setHSL(zo,Fo,Bo)}}}else if(Do=/^\#([A-Fa-f0-9]+)$/.exec(wo)){var Oo=Do[1],Go=Oo.length;if(3===Go)return this.r=parseInt(Oo.charAt(0)+Oo.charAt(0),16)/255,this.g=parseInt(Oo.charAt(1)+Oo.charAt(1),16)/255,this.b=parseInt(Oo.charAt(2)+Oo.charAt(2),16)/255,this;if(6===Go)return this.r=parseInt(Oo.charAt(0)+Oo.charAt(1),16)/255,this.g=parseInt(Oo.charAt(2)+Oo.charAt(3),16)/255,this.b=parseInt(Oo.charAt(4)+Oo.charAt(5),16)/255,this}if(wo&&0<wo.length){var Oo=Eo[wo];void 0===Oo?console.warn('THREE.Color: Unknown color '+wo):this.setHex(Oo)}return this},clone:function(){return new this.constructor(this.r,this.g,this.b)},copy:function(wo){return this.r=wo.r,this.g=wo.g,this.b=wo.b,this},copyGammaToLinear:function(wo,Co){return void 0===Co&&(Co=2),this.r=Math.pow(wo.r,Co),this.g=Math.pow(wo.g,Co),this.b=Math.pow(wo.b,Co),this},copyLinearToGamma:function(wo,Co){void 0===Co&&(Co=2);var Do=0<Co?1/Co:1;return this.r=Math.pow(wo.r,Do),this.g=Math.pow(wo.g,Do),this.b=Math.pow(wo.b,Do),this},convertGammaToLinear:function(){var wo=this.r,Co=this.g,Do=this.b;return this.r=wo*wo,this.g=Co*Co,this.b=Do*Do,this},convertLinearToGamma:function(){return this.r=Math.sqrt(this.r),this.g=Math.sqrt(this.g),this.b=Math.sqrt(this.b),this},getHex:function(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0},getHexString:function(){return('000000'+this.getHex().toString(16)).slice(-6)},getHSL:function(wo){var Co=wo||{h:0,s:0,l:0},Do=this.r,Uo=this.g,No=this.b,Io=Math.max(Do,Uo,No),zo=Math.min(Do,Uo,No),Oo=(zo+Io)/2,Fo,Bo;if(zo===Io)Fo=0,Bo=0;else{var Go=Io-zo;Bo=0.5>=Oo?Go/(Io+zo):Go/(2-Io-zo),Io===Do?Fo=(Uo-No)/Go+(Uo<No?6:0):Io===Uo?Fo=(No-Do)/Go+2:Io===No?Fo=(Do-Uo)/Go+4:void 0,Fo/=6}return Co.h=Fo,Co.s=Bo,Co.l=Oo,Co},getStyle:function(){return'rgb('+(0|255*this.r)+','+(0|255*this.g)+','+(0|255*this.b)+')'},offsetHSL:function(wo,Co,Do){var Uo=this.getHSL();return Uo.h+=wo,Uo.s+=Co,Uo.l+=Do,this.setHSL(Uo.h,Uo.s,Uo.l),this},add:function(wo){return this.r+=wo.r,this.g+=wo.g,this.b+=wo.b,this},addColors:function(wo,Co){return this.r=wo.r+Co.r,this.g=wo.g+Co.g,this.b=wo.b+Co.b,this},addScalar:function(wo){return this.r+=wo,this.g+=wo,this.b+=wo,this},sub:function(wo){return this.r=Math.max(0,this.r-wo.r),this.g=Math.max(0,this.g-wo.g),this.b=Math.max(0,this.b-wo.b),this},multiply:function(wo){return this.r*=wo.r,this.g*=wo.g,this.b*=wo.b,this},multiplyScalar:function(wo){return this.r*=wo,this.g*=wo,this.b*=wo,this},lerp:function(wo,Co){return this.r+=(wo.r-this.r)*Co,this.g+=(wo.g-this.g)*Co,this.b+=(wo.b-this.b)*Co,this},equals:function(wo){return wo.r===this.r&&wo.g===this.g&&wo.b===this.b},fromArray:function(wo,Co){return void 0===Co&&(Co=0),this.r=wo[Co],this.g=wo[Co+1],this.b=wo[Co+2],this},toArray:function(wo,Co){return void 0===wo&&(wo=[]),void 0===Co&&(Co=0),wo[Co]=this.r,wo[Co+1]=this.g,wo[Co+2]=this.b,wo},toJSON:function(){return this.getHex()}};var Eo={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},bo={common:{diffuse:{value:new ve(15658734)},opacity:{value:1},map:{value:null},offsetRepeat:{value:new _e(0,0,1,1)},specularMap:{value:null},alphaMap:{value:null},envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:0.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new T(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:2.5e-4},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new ve(16777215)}},lights:{ambientLightColor:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}}},points:{diffuse:{value:new ve(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},offsetRepeat:{value:new _e(0,0,1,1)}}},So={basic:{uniforms:xi.merge([bo.common,bo.aomap,bo.lightmap,bo.fog]),vertexShader:yo.meshbasic_vert,fragmentShader:yo.meshbasic_frag},lambert:{uniforms:xi.merge([bo.common,bo.aomap,bo.lightmap,bo.emissivemap,bo.fog,bo.lights,{emissive:{value:new ve(0)}}]),vertexShader:yo.meshlambert_vert,fragmentShader:yo.meshlambert_frag},phong:{uniforms:xi.merge([bo.common,bo.aomap,bo.lightmap,bo.emissivemap,bo.bumpmap,bo.normalmap,bo.displacementmap,bo.gradientmap,bo.fog,bo.lights,{emissive:{value:new ve(0)},specular:{value:new ve(1118481)},shininess:{value:30}}]),vertexShader:yo.meshphong_vert,fragmentShader:yo.meshphong_frag},standard:{uniforms:xi.merge([bo.common,bo.aomap,bo.lightmap,bo.emissivemap,bo.bumpmap,bo.normalmap,bo.displacementmap,bo.roughnessmap,bo.metalnessmap,bo.fog,bo.lights,{emissive:{value:new ve(0)},roughness:{value:0.5},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:yo.meshphysical_vert,fragmentShader:yo.meshphysical_frag},points:{uniforms:xi.merge([bo.points,bo.fog]),vertexShader:yo.points_vert,fragmentShader:yo.points_frag},dashed:{uniforms:xi.merge([bo.common,bo.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:yo.linedashed_vert,fragmentShader:yo.linedashed_frag},depth:{uniforms:xi.merge([bo.common,bo.displacementmap]),vertexShader:yo.depth_vert,fragmentShader:yo.depth_frag},normal:{uniforms:xi.merge([bo.common,bo.bumpmap,bo.normalmap,bo.displacementmap,{opacity:{value:1}}]),vertexShader:yo.normal_vert,fragmentShader:yo.normal_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:yo.cube_vert,fragmentShader:yo.cube_frag},equirect:{uniforms:{tEquirect:{value:null},tFlip:{value:-1}},vertexShader:yo.equirect_vert,fragmentShader:yo.equirect_frag},distanceRGBA:{uniforms:{lightPos:{value:new E}},vertexShader:yo.distanceRGBA_vert,fragmentShader:yo.distanceRGBA_frag}};So.physical={uniforms:xi.merge([So.standard.uniforms,{clearCoat:{value:0},clearCoatRoughness:{value:0}}]),vertexShader:yo.meshphysical_vert,fragmentShader:yo.meshphysical_frag},ye.prototype={constructor:ye,set:function(wo,Co){return this.min.copy(wo),this.max.copy(Co),this},setFromPoints:function(wo){this.makeEmpty();for(var Co=0,Do=wo.length;Co<Do;Co++)this.expandByPoint(wo[Co]);return this},setFromCenterAndSize:function(){var wo=new T;return function(Do,Uo){var No=wo.copy(Uo).multiplyScalar(0.5);return this.min.copy(Do).sub(No),this.max.copy(Do).add(No),this}}(),clone:function(){return new this.constructor().copy(this)},copy:function(wo){return this.min.copy(wo.min),this.max.copy(wo.max),this},makeEmpty:function(){return this.min.x=this.min.y=+Infinity,this.max.x=this.max.y=-Infinity,this},isEmpty:function(){return this.max.x<this.min.x||this.max.y<this.min.y},getCenter:function(wo){var Co=wo||new T;return this.isEmpty()?Co.set(0,0):Co.addVectors(this.min,this.max).multiplyScalar(0.5)},getSize:function(wo){var Co=wo||new T;return this.isEmpty()?Co.set(0,0):Co.subVectors(this.max,this.min)},expandByPoint:function(wo){return this.min.min(wo),this.max.max(wo),this},expandByVector:function(wo){return this.min.sub(wo),this.max.add(wo),this},expandByScalar:function(wo){return this.min.addScalar(-wo),this.max.addScalar(wo),this},containsPoint:function(wo){return wo.x<this.min.x||wo.x>this.max.x||wo.y<this.min.y||wo.y>this.max.y?!1:!0},containsBox:function(wo){return this.min.x<=wo.min.x&&wo.max.x<=this.max.x&&this.min.y<=wo.min.y&&wo.max.y<=this.max.y},getParameter:function(wo,Co){var Do=Co||new T;return Do.set((wo.x-this.min.x)/(this.max.x-this.min.x),(wo.y-this.min.y)/(this.max.y-this.min.y))},intersectsBox:function(wo){return wo.max.x<this.min.x||wo.min.x>this.max.x||wo.max.y<this.min.y||wo.min.y>this.max.y?!1:!0},clampPoint:function(wo,Co){var Do=Co||new T;return Do.copy(wo).clamp(this.min,this.max)},distanceToPoint:function(){var wo=new T;return function(Do){var Uo=wo.copy(Do).clamp(this.min,this.max);return Uo.sub(Do).length()}}(),intersect:function(wo){return this.min.max(wo.min),this.max.min(wo.max),this},union:function(wo){return this.min.min(wo.min),this.max.max(wo.max),this},translate:function(wo){return this.min.add(wo),this.max.add(wo),this},equals:function(wo){return wo.min.equals(this.min)&&wo.max.equals(this.max)}},Me.prototype={constructor:Me,isWebGLRenderTarget:!0,setSize:function(wo,Co){(this.width!==wo||this.height!==Co)&&(this.width=wo,this.height=Co,this.dispose()),this.viewport.set(0,0,wo,Co),this.scissor.set(0,0,wo,Co)},clone:function(){return new this.constructor().copy(this)},copy:function(wo){return this.width=wo.width,this.height=wo.height,this.viewport.copy(wo.viewport),this.texture=wo.texture.clone(),this.depthBuffer=wo.depthBuffer,this.stencilBuffer=wo.stencilBuffer,this.depthTexture=wo.depthTexture,this},dispose:function(){this.dispatchEvent({type:'dispose'})}},Object.assign(Me.prototype,M.prototype);var Mo=0;Te.prototype={constructor:Te,isMaterial:!0,get needsUpdate(){return this._needsUpdate},set needsUpdate(wo){!0===wo&&this.update(),this._needsUpdate=wo},setValues:function(wo){if(void 0!==wo)for(var Co in wo){var Do=wo[Co];if(void 0===Do){console.warn('THREE.Material: \''+Co+'\' parameter is undefined.');continue}var Uo=this[Co];if(void 0===Uo){console.warn('THREE.'+this.type+': \''+Co+'\' is not a property of this material.');continue}Uo&&Uo.isColor?Uo.set(Do):Uo&&Uo.isVector3&&Do&&Do.isVector3?Uo.copy(Do):'overdraw'===Co?this[Co]=+Do:this[Co]=Do}},toJSON:function(wo){function Co(zo){var Fo=[];for(var Bo in zo){var Oo=zo[Bo];delete Oo.metadata,Fo.push(Oo)}return Fo}var Do=void 0===wo;Do&&(wo={textures:{},images:{}});var Uo={metadata:{version:4.4,type:'Material',generator:'Material.toJSON'}};if(Uo.uuid=this.uuid,Uo.type=this.type,''!==this.name&&(Uo.name=this.name),this.color&&this.color.isColor&&(Uo.color=this.color.getHex()),void 0!==this.roughness&&(Uo.roughness=this.roughness),void 0!==this.metalness&&(Uo.metalness=this.metalness),this.emissive&&this.emissive.isColor&&(Uo.emissive=this.emissive.getHex()),this.specular&&this.specular.isColor&&(Uo.specular=this.specular.getHex()),void 0!==this.shininess&&(Uo.shininess=this.shininess),void 0!==this.clearCoat&&(Uo.clearCoat=this.clearCoat),void 0!==this.clearCoatRoughness&&(Uo.clearCoatRoughness=this.clearCoatRoughness),this.map&&this.map.isTexture&&(Uo.map=this.map.toJSON(wo).uuid),this.alphaMap&&this.alphaMap.isTexture&&(Uo.alphaMap=this.alphaMap.toJSON(wo).uuid),this.lightMap&&this.lightMap.isTexture&&(Uo.lightMap=this.lightMap.toJSON(wo).uuid),this.bumpMap&&this.bumpMap.isTexture&&(Uo.bumpMap=this.bumpMap.toJSON(wo).uuid,Uo.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(Uo.normalMap=this.normalMap.toJSON(wo).uuid,Uo.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(Uo.displacementMap=this.displacementMap.toJSON(wo).uuid,Uo.displacementScale=this.displacementScale,Uo.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(Uo.roughnessMap=this.roughnessMap.toJSON(wo).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(Uo.metalnessMap=this.metalnessMap.toJSON(wo).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(Uo.emissiveMap=this.emissiveMap.toJSON(wo).uuid),this.specularMap&&this.specularMap.isTexture&&(Uo.specularMap=this.specularMap.toJSON(wo).uuid),this.envMap&&this.envMap.isTexture&&(Uo.envMap=this.envMap.toJSON(wo).uuid,Uo.reflectivity=this.reflectivity),this.gradientMap&&this.gradientMap.isTexture&&(Uo.gradientMap=this.gradientMap.toJSON(wo).uuid),void 0!==this.size&&(Uo.size=this.size),void 0!==this.sizeAttenuation&&(Uo.sizeAttenuation=this.sizeAttenuation),this.blending!==ur&&(Uo.blending=this.blending),this.shading!==sr&&(Uo.shading=this.shading),this.side!==ar&&(Uo.side=this.side),this.vertexColors!==lr&&(Uo.vertexColors=this.vertexColors),1>this.opacity&&(Uo.opacity=this.opacity),!0===this.transparent&&(Uo.transparent=this.transparent),Uo.depthFunc=this.depthFunc,Uo.depthTest=this.depthTest,Uo.depthWrite=this.depthWrite,0<this.alphaTest&&(Uo.alphaTest=this.alphaTest),!0===this.premultipliedAlpha&&(Uo.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(Uo.wireframe=this.wireframe),1<this.wireframeLinewidth&&(Uo.wireframeLinewidth=this.wireframeLinewidth),'round'!==this.wireframeLinecap&&(Uo.wireframeLinecap=this.wireframeLinecap),'round'!==this.wireframeLinejoin&&(Uo.wireframeLinejoin=this.wireframeLinejoin),Uo.skinning=this.skinning,Uo.morphTargets=this.morphTargets,Do){var No=Co(wo.textures),Io=Co(wo.images);0<No.length&&(Uo.textures=No),0<Io.length&&(Uo.images=Io)}return Uo},clone:function(){return new this.constructor().copy(this)},copy:function(wo){this.name=wo.name,this.fog=wo.fog,this.lights=wo.lights,this.blending=wo.blending,this.side=wo.side,this.shading=wo.shading,this.vertexColors=wo.vertexColors,this.opacity=wo.opacity,this.transparent=wo.transparent,this.blendSrc=wo.blendSrc,this.blendDst=wo.blendDst,this.blendEquation=wo.blendEquation,this.blendSrcAlpha=wo.blendSrcAlpha,this.blendDstAlpha=wo.blendDstAlpha,this.blendEquationAlpha=wo.blendEquationAlpha,this.depthFunc=wo.depthFunc,this.depthTest=wo.depthTest,this.depthWrite=wo.depthWrite,this.colorWrite=wo.colorWrite,this.precision=wo.precision,this.polygonOffset=wo.polygonOffset,this.polygonOffsetFactor=wo.polygonOffsetFactor,this.polygonOffsetUnits=wo.polygonOffsetUnits,this.alphaTest=wo.alphaTest,this.premultipliedAlpha=wo.premultipliedAlpha,this.overdraw=wo.overdraw,this.visible=wo.visible,this.clipShadows=wo.clipShadows,this.clipIntersection=wo.clipIntersection;var Co=wo.clippingPlanes,Do=null;if(null!==Co){var Uo=Co.length;Do=Array(Uo);for(var No=0;No!==Uo;++No)Do[No]=Co[No].clone()}return this.clippingPlanes=Do,this},update:function(){this.dispatchEvent({type:'update'})},dispose:function(){this.dispatchEvent({type:'dispose'})}},Object.assign(Te.prototype,M.prototype),Le.prototype=Object.create(Te.prototype),Le.prototype.constructor=Le,Le.prototype.isShaderMaterial=!0,Le.prototype.copy=function(wo){return Te.prototype.copy.call(this,wo),this.fragmentShader=wo.fragmentShader,this.vertexShader=wo.vertexShader,this.uniforms=xi.clone(wo.uniforms),this.defines=wo.defines,this.wireframe=wo.wireframe,this.wireframeLinewidth=wo.wireframeLinewidth,this.lights=wo.lights,this.clipping=wo.clipping,this.skinning=wo.skinning,this.morphTargets=wo.morphTargets,this.morphNormals=wo.morphNormals,this.extensions=wo.extensions,this},Le.prototype.toJSON=function(wo){var Co=Te.prototype.toJSON.call(this,wo);return Co.uniforms=this.uniforms,Co.vertexShader=this.vertexShader,Co.fragmentShader=this.fragmentShader,Co},Ae.prototype=Object.create(Te.prototype),Ae.prototype.constructor=Ae,Ae.prototype.isMeshDepthMaterial=!0,Ae.prototype.copy=function(wo){return Te.prototype.copy.call(this,wo),this.depthPacking=wo.depthPacking,this.skinning=wo.skinning,this.morphTargets=wo.morphTargets,this.map=wo.map,this.alphaMap=wo.alphaMap,this.displacementMap=wo.displacementMap,this.displacementScale=wo.displacementScale,this.displacementBias=wo.displacementBias,this.wireframe=wo.wireframe,this.wireframeLinewidth=wo.wireframeLinewidth,this},Re.prototype={constructor:Re,isBox3:!0,set:function(wo,Co){return this.min.copy(wo),this.max.copy(Co),this},setFromArray:function(wo){for(var Co=+Infinity,Do=+Infinity,Uo=+Infinity,No=-Infinity,Io=-Infinity,zo=-Infinity,Fo=0,Bo=wo.length;Fo<Bo;Fo+=3){var Oo=wo[Fo],Go=wo[Fo+1],Vo=wo[Fo+2];Oo<Co&&(Co=Oo),Go<Do&&(Do=Go),Vo<Uo&&(Uo=Vo),Oo>No&&(No=Oo),Go>Io&&(Io=Go),Vo>zo&&(zo=Vo)}return this.min.set(Co,Do,Uo),this.max.set(No,Io,zo),this},setFromBufferAttribute:function(wo){for(var Co=+Infinity,Do=+Infinity,Uo=+Infinity,No=-Infinity,Io=-Infinity,zo=-Infinity,Fo=0,Bo=wo.count;Fo<Bo;Fo++){var Oo=wo.getX(Fo),Go=wo.getY(Fo),Vo=wo.getZ(Fo);Oo<Co&&(Co=Oo),Go<Do&&(Do=Go),Vo<Uo&&(Uo=Vo),Oo>No&&(No=Oo),Go>Io&&(Io=Go),Vo>zo&&(zo=Vo)}return this.min.set(Co,Do,Uo),this.max.set(No,Io,zo),this},setFromPoints:function(wo){this.makeEmpty();for(var Co=0,Do=wo.length;Co<Do;Co++)this.expandByPoint(wo[Co]);return this},setFromCenterAndSize:function(){var wo=new E;return function(Do,Uo){var No=wo.copy(Uo).multiplyScalar(0.5);return this.min.copy(Do).sub(No),this.max.copy(Do).add(No),this}}(),setFromObject:function(wo){return this.makeEmpty(),this.expandByObject(wo)},clone:function(){return new this.constructor().copy(this)},copy:function(wo){return this.min.copy(wo.min),this.max.copy(wo.max),this},makeEmpty:function(){return this.min.x=this.min.y=this.min.z=+Infinity,this.max.x=this.max.y=this.max.z=-Infinity,this},isEmpty:function(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z},getCenter:function(wo){var Co=wo||new E;return this.isEmpty()?Co.set(0,0,0):Co.addVectors(this.min,this.max).multiplyScalar(0.5)},getSize:function(wo){var Co=wo||new E;return this.isEmpty()?Co.set(0,0,0):Co.subVectors(this.max,this.min)},expandByPoint:function(wo){return this.min.min(wo),this.max.max(wo),this},expandByVector:function(wo){return this.min.sub(wo),this.max.add(wo),this},expandByScalar:function(wo){return this.min.addScalar(-wo),this.max.addScalar(wo),this},expandByObject:function(){var wo=new E;return function(Do){var Uo=this;return Do.updateMatrixWorld(!0),Do.traverse(function(No){var Fo=No.geometry,Io,zo;if(void 0!==Fo)if(Fo.isGeometry){var Bo=Fo.vertices;for(Io=0,zo=Bo.length;Io<zo;Io++)wo.copy(Bo[Io]),wo.applyMatrix4(No.matrixWorld),Uo.expandByPoint(wo)}else if(Fo.isBufferGeometry){var Oo=Fo.attributes.position;if(void 0!==Oo)for(Io=0,zo=Oo.count;Io<zo;Io++)wo.fromBufferAttribute(Oo,Io).applyMatrix4(No.matrixWorld),Uo.expandByPoint(wo)}}),this}}(),containsPoint:function(wo){return wo.x<this.min.x||wo.x>this.max.x||wo.y<this.min.y||wo.y>this.max.y||wo.z<this.min.z||wo.z>this.max.z?!1:!0},containsBox:function(wo){return this.min.x<=wo.min.x&&wo.max.x<=this.max.x&&this.min.y<=wo.min.y&&wo.max.y<=this.max.y&&this.min.z<=wo.min.z&&wo.max.z<=this.max.z},getParameter:function(wo,Co){var Do=Co||new E;return Do.set((wo.x-this.min.x)/(this.max.x-this.min.x),(wo.y-this.min.y)/(this.max.y-this.min.y),(wo.z-this.min.z)/(this.max.z-this.min.z))},intersectsBox:function(wo){return wo.max.x<this.min.x||wo.min.x>this.max.x||wo.max.y<this.min.y||wo.min.y>this.max.y||wo.max.z<this.min.z||wo.min.z>this.max.z?!1:!0},intersectsSphere:function(){var wo;return function(Do){return void 0===wo&&(wo=new E),this.clampPoint(Do.center,wo),wo.distanceToSquared(Do.center)<=Do.radius*Do.radius}}(),intersectsPlane:function(wo){var Co,Do;return 0<wo.normal.x?(Co=wo.normal.x*this.min.x,Do=wo.normal.x*this.max.x):(Co=wo.normal.x*this.max.x,Do=wo.normal.x*this.min.x),0<wo.normal.y?(Co+=wo.normal.y*this.min.y,Do+=wo.normal.y*this.max.y):(Co+=wo.normal.y*this.max.y,Do+=wo.normal.y*this.min.y),0<wo.normal.z?(Co+=wo.normal.z*this.min.z,Do+=wo.normal.z*this.max.z):(Co+=wo.normal.z*this.max.z,Do+=wo.normal.z*this.min.z),Co<=wo.constant&&Do>=wo.constant},clampPoint:function(wo,Co){var Do=Co||new E;return Do.copy(wo).clamp(this.min,this.max)},distanceToPoint:function(){var wo=new E;return function(Do){var Uo=wo.copy(Do).clamp(this.min,this.max);return Uo.sub(Do).length()}}(),getBoundingSphere:function(){var wo=new E;return function(Do){var Uo=Do||new Pe;return this.getCenter(Uo.center),Uo.radius=0.5*this.getSize(wo).length(),Uo}}(),intersect:function(wo){return this.min.max(wo.min),this.max.min(wo.max),this.isEmpty()&&this.makeEmpty(),this},union:function(wo){return this.min.min(wo.min),this.max.max(wo.max),this},applyMatrix4:function(){var wo=[new E,new E,new E,new E,new E,new E,new E,new E];return function(Do){return this.isEmpty()?this:(wo[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(Do),wo[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(Do),wo[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(Do),wo[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(Do),wo[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(Do),wo[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(Do),wo[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(Do),wo[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(Do),this.setFromPoints(wo),this)}}(),translate:function(wo){return this.min.add(wo),this.max.add(wo),this},equals:function(wo){return wo.min.equals(this.min)&&wo.max.equals(this.max)}},Pe.prototype={constructor:Pe,set:function(wo,Co){return this.center.copy(wo),this.radius=Co,this},setFromPoints:function(){var wo;return function(Do,Uo){void 0===wo&&(wo=new Re);var No=this.center;void 0===Uo?wo.setFromPoints(Do).getCenter(No):No.copy(Uo);for(var Io=0,zo=0,Fo=Do.length;zo<Fo;zo++)Io=Math.max(Io,No.distanceToSquared(Do[zo]));return this.radius=Math.sqrt(Io),this}}(),clone:function(){return new this.constructor().copy(this)},copy:function(wo){return this.center.copy(wo.center),this.radius=wo.radius,this},empty:function(){return 0>=this.radius},containsPoint:function(wo){return wo.distanceToSquared(this.center)<=this.radius*this.radius},distanceToPoint:function(wo){return wo.distanceTo(this.center)-this.radius},intersectsSphere:function(wo){var Co=this.radius+wo.radius;return wo.center.distanceToSquared(this.center)<=Co*Co},intersectsBox:function(wo){return wo.intersectsSphere(this)},intersectsPlane:function(wo){return Math.abs(this.center.dot(wo.normal)-wo.constant)<=this.radius},clampPoint:function(wo,Co){var Do=this.center.distanceToSquared(wo),Uo=Co||new E;return Uo.copy(wo),Do>this.radius*this.radius&&(Uo.sub(this.center).normalize(),Uo.multiplyScalar(this.radius).add(this.center)),Uo},getBoundingBox:function(wo){var Co=wo||new Re;return Co.set(this.center,this.center),Co.expandByScalar(this.radius),Co},applyMatrix4:function(wo){return this.center.applyMatrix4(wo),this.radius*=wo.getMaxScaleOnAxis(),this},translate:function(wo){return this.center.add(wo),this},equals:function(wo){return wo.center.equals(this.center)&&wo.radius===this.radius}},we.prototype={constructor:we,isMatrix3:!0,set:function(wo,Co,Do,Uo,No,Io,zo,Fo,Bo){var Oo=this.elements;return Oo[0]=wo,Oo[1]=Uo,Oo[2]=zo,Oo[3]=Co,Oo[4]=No,Oo[5]=Fo,Oo[6]=Do,Oo[7]=Io,Oo[8]=Bo,this},identity:function(){return this.set(1,0,0,0,1,0,0,0,1),this},clone:function(){return new this.constructor().fromArray(this.elements)},copy:function(wo){var Co=wo.elements;return this.set(Co[0],Co[3],Co[6],Co[1],Co[4],Co[7],Co[2],Co[5],Co[8]),this},setFromMatrix4:function(wo){var Co=wo.elements;return this.set(Co[0],Co[4],Co[8],Co[1],Co[5],Co[9],Co[2],Co[6],Co[10]),this},applyToBufferAttribute:function(){var wo;return function(Do){wo===void 0&&(wo=new E);for(var Uo=0,No=Do.count;Uo<No;Uo++)wo.x=Do.getX(Uo),wo.y=Do.getY(Uo),wo.z=Do.getZ(Uo),wo.applyMatrix3(this),Do.setXYZ(Uo,wo.x,wo.y,wo.z);return Do}}(),multiplyScalar:function(wo){var Co=this.elements;return Co[0]*=wo,Co[3]*=wo,Co[6]*=wo,Co[1]*=wo,Co[4]*=wo,Co[7]*=wo,Co[2]*=wo,Co[5]*=wo,Co[8]*=wo,this},determinant:function(){var wo=this.elements,Co=wo[0],Do=wo[1],Uo=wo[2],No=wo[3],Io=wo[4],zo=wo[5],Fo=wo[6],Bo=wo[7],Oo=wo[8];return Co*Io*Oo-Co*zo*Bo-Do*No*Oo+Do*zo*Fo+Uo*No*Bo-Uo*Io*Fo},getInverse:function(wo,Co){wo&&wo.isMatrix4&&console.error('THREE.Matrix3.getInverse no longer takes a Matrix4 argument.');var Do=wo.elements,Uo=this.elements,No=Do[0],Io=Do[1],zo=Do[2],Fo=Do[3],Bo=Do[4],Oo=Do[5],Go=Do[6],Vo=Do[7],Ho=Do[8],ko=Ho*Bo-Oo*Vo,Wo=Oo*Go-Ho*Fo,Xo=Vo*Fo-Bo*Go,Yo=No*ko+Io*Wo+zo*Xo;if(0===Yo){var jo='THREE.Matrix3.getInverse(): can\'t invert matrix, determinant is 0';if(!0===Co)throw new Error(jo);else console.warn(jo);return this.identity()}var qo=1/Yo;return Uo[0]=ko*qo,Uo[1]=(zo*Vo-Ho*Io)*qo,Uo[2]=(Oo*Io-zo*Bo)*qo,Uo[3]=Wo*qo,Uo[4]=(Ho*No-zo*Go)*qo,Uo[5]=(zo*Fo-Oo*No)*qo,Uo[6]=Xo*qo,Uo[7]=(Io*Go-Vo*No)*qo,Uo[8]=(Bo*No-Io*Fo)*qo,this},transpose:function(){var Co=this.elements,wo;return wo=Co[1],Co[1]=Co[3],Co[3]=wo,wo=Co[2],Co[2]=Co[6],Co[6]=wo,wo=Co[5],Co[5]=Co[7],Co[7]=wo,this},getNormalMatrix:function(wo){return this.setFromMatrix4(wo).getInverse(this).transpose()},transposeIntoArray:function(wo){var Co=this.elements;return wo[0]=Co[0],wo[1]=Co[3],wo[2]=Co[6],wo[3]=Co[1],wo[4]=Co[4],wo[5]=Co[7],wo[6]=Co[2],wo[7]=Co[5],wo[8]=Co[8],this},fromArray:function(wo,Co){Co===void 0&&(Co=0);for(var Do=0;9>Do;Do++)this.elements[Do]=wo[Do+Co];return this},toArray:function(wo,Co){void 0===wo&&(wo=[]),void 0===Co&&(Co=0);var Do=this.elements;return wo[Co]=Do[0],wo[Co+1]=Do[1],wo[Co+2]=Do[2],wo[Co+3]=Do[3],wo[Co+4]=Do[4],wo[Co+5]=Do[5],wo[Co+6]=Do[6],wo[Co+7]=Do[7],wo[Co+8]=Do[8],wo}},Ce.prototype={constructor:Ce,set:function(wo,Co){return this.normal.copy(wo),this.constant=Co,this},setComponents:function(wo,Co,Do,Uo){return this.normal.set(wo,Co,Do),this.constant=Uo,this},setFromNormalAndCoplanarPoint:function(wo,Co){return this.normal.copy(wo),this.constant=-Co.dot(this.normal),this},setFromCoplanarPoints:function(){var wo=new E,Co=new E;return function(Uo,No,Io){var zo=wo.subVectors(Io,No).cross(Co.subVectors(Uo,No)).normalize();return this.setFromNormalAndCoplanarPoint(zo,Uo),this}}(),clone:function(){return new this.constructor().copy(this)},copy:function(wo){return this.normal.copy(wo.normal),this.constant=wo.constant,this},normalize:function(){var wo=1/this.normal.length();return this.normal.multiplyScalar(wo),this.constant*=wo,this},negate:function(){return this.constant*=-1,this.normal.negate(),this},distanceToPoint:function(wo){return this.normal.dot(wo)+this.constant},distanceToSphere:function(wo){return this.distanceToPoint(wo.center)-wo.radius},projectPoint:function(wo,Co){return this.orthoPoint(wo,Co).sub(wo).negate()},orthoPoint:function(wo,Co){var Do=this.distanceToPoint(wo),Uo=Co||new E;return Uo.copy(this.normal).multiplyScalar(Do)},intersectLine:function(){var wo=new E;return function(Do,Uo){var No=Uo||new E,Io=Do.delta(wo),zo=this.normal.dot(Io);if(0===zo)return 0===this.distanceToPoint(Do.start)?No.copy(Do.start):void 0;var Fo=-(Do.start.dot(this.normal)+this.constant)/zo;return 0>Fo||1<Fo?void 0:No.copy(Io).multiplyScalar(Fo).add(Do.start)}}(),intersectsLine:function(wo){var Co=this.distanceToPoint(wo.start),Do=this.distanceToPoint(wo.end);return 0>Co&&0<Do||0>Do&&0<Co},intersectsBox:function(wo){return wo.intersectsPlane(this)},intersectsSphere:function(wo){return wo.intersectsPlane(this)},coplanarPoint:function(wo){var Co=wo||new E;return Co.copy(this.normal).multiplyScalar(-this.constant)},applyMatrix4:function(){var wo=new E,Co=new we;return function(Uo,No){var Io=this.coplanarPoint(wo).applyMatrix4(Uo),zo=No||Co.getNormalMatrix(Uo),Fo=this.normal.applyMatrix3(zo).normalize();return this.constant=-Io.dot(Fo),this}}(),translate:function(wo){return this.constant-=wo.dot(this.normal),this},equals:function(wo){return wo.normal.equals(this.normal)&&wo.constant===this.constant}},De.prototype={constructor:De,set:function(wo,Co,Do,Uo,No,Io){var zo=this.planes;return zo[0].copy(wo),zo[1].copy(Co),zo[2].copy(Do),zo[3].copy(Uo),zo[4].copy(No),zo[5].copy(Io),this},clone:function(){return new this.constructor().copy(this)},copy:function(wo){for(var Co=this.planes,Do=0;6>Do;Do++)Co[Do].copy(wo.planes[Do]);return this},setFromMatrix:function(wo){var Co=this.planes,Do=wo.elements,Uo=Do[0],No=Do[1],Io=Do[2],zo=Do[3],Fo=Do[4],Bo=Do[5],Oo=Do[6],Go=Do[7],Vo=Do[8],Ho=Do[9],ko=Do[10],Wo=Do[11],Xo=Do[12],Yo=Do[13],jo=Do[14],qo=Do[15];return Co[0].setComponents(zo-Uo,Go-Fo,Wo-Vo,qo-Xo).normalize(),Co[1].setComponents(zo+Uo,Go+Fo,Wo+Vo,qo+Xo).normalize(),Co[2].setComponents(zo+No,Go+Bo,Wo+Ho,qo+Yo).normalize(),Co[3].setComponents(zo-No,Go-Bo,Wo-Ho,qo-Yo).normalize(),Co[4].setComponents(zo-Io,Go-Oo,Wo-ko,qo-jo).normalize(),Co[5].setComponents(zo+Io,Go+Oo,Wo+ko,qo+jo).normalize(),this},intersectsObject:function(){var wo=new Pe;return function(Do){var Uo=Do.geometry;return null===Uo.boundingSphere&&Uo.computeBoundingSphere(),wo.copy(Uo.boundingSphere).applyMatrix4(Do.matrixWorld),this.intersectsSphere(wo)}}(),intersectsSprite:function(){var wo=new Pe;return function(Do){return wo.center.set(0,0,0),wo.radius=0.7071067811865476,wo.applyMatrix4(Do.matrixWorld),this.intersectsSphere(wo)}}(),intersectsSphere:function(wo){for(var Co=this.planes,Do=wo.center,Uo=-wo.radius,No=0,Io;6>No;No++)if(Io=Co[No].distanceToPoint(Do),Io<Uo)return!1;return!0},intersectsBox:function(){var wo=new E,Co=new E;return function(Uo){for(var No=this.planes,Io=0,zo;6>Io;Io++){zo=No[Io],wo.x=0<zo.normal.x?Uo.min.x:Uo.max.x,Co.x=0<zo.normal.x?Uo.max.x:Uo.min.x,wo.y=0<zo.normal.y?Uo.min.y:Uo.max.y,Co.y=0<zo.normal.y?Uo.max.y:Uo.min.y,wo.z=0<zo.normal.z?Uo.min.z:Uo.max.z,Co.z=0<zo.normal.z?Uo.max.z:Uo.min.z;var Fo=zo.distanceToPoint(wo),Bo=zo.distanceToPoint(Co);if(0>Fo&&0>Bo)return!1}return!0}}(),containsPoint:function(wo){for(var Co=this.planes,Do=0;6>Do;Do++)if(0>Co[Do].distanceToPoint(wo))return!1;return!0}},Ne.prototype={constructor:Ne,set:function(wo,Co){return this.origin.copy(wo),this.direction.copy(Co),this},clone:function(){return new this.constructor().copy(this)},copy:function(wo){return this.origin.copy(wo.origin),this.direction.copy(wo.direction),this},at:function(wo,Co){var Do=Co||new E;return Do.copy(this.direction).multiplyScalar(wo).add(this.origin)},lookAt:function(wo){return this.direction.copy(wo).sub(this.origin).normalize(),this},recast:function(){var wo=new E;return function(Do){return this.origin.copy(this.at(Do,wo)),this}}(),closestPointToPoint:function(wo,Co){var Do=Co||new E;Do.subVectors(wo,this.origin);var Uo=Do.dot(this.direction);return 0>Uo?Do.copy(this.origin):Do.copy(this.direction).multiplyScalar(Uo).add(this.origin)},distanceToPoint:function(wo){return Math.sqrt(this.distanceSqToPoint(wo))},distanceSqToPoint:function(){var wo=new E;return function(Do){var Uo=wo.subVectors(Do,this.origin).dot(this.direction);return 0>Uo?this.origin.distanceToSquared(Do):(wo.copy(this.direction).multiplyScalar(Uo).add(this.origin),wo.distanceToSquared(Do))}}(),distanceSqToSegment:function(){var wo=new E,Co=new E,Do=new E;return function(No,Io,zo,Fo){wo.copy(No).add(Io).multiplyScalar(0.5),Co.copy(Io).sub(No).normalize(),Do.copy(this.origin).sub(wo);var Bo=0.5*No.distanceTo(Io),Oo=-this.direction.dot(Co),Go=Do.dot(this.direction),Vo=-Do.dot(Co),Ho=Do.lengthSq(),ko=Math.abs(1-Oo*Oo),Wo,Xo,Yo,jo;if(!(0<ko))Xo=0<Oo?-Bo:Bo,Wo=Math.max(0,-(Oo*Xo+Go)),Yo=-Wo*Wo+Xo*(Xo+2*Vo)+Ho;else if(Wo=Oo*Vo-Go,Xo=Oo*Go-Vo,jo=Bo*ko,!(0<=Wo))Xo<=-jo?(Wo=Math.max(0,-(-Oo*Bo+Go)),Xo=0<Wo?-Bo:Math.min(Math.max(-Bo,-Vo),Bo),Yo=-Wo*Wo+Xo*(Xo+2*Vo)+Ho):Xo<=jo?(Wo=0,Xo=Math.min(Math.max(-Bo,-Vo),Bo),Yo=Xo*(Xo+2*Vo)+Ho):(Wo=Math.max(0,-(Oo*Bo+Go)),Xo=0<Wo?Bo:Math.min(Math.max(-Bo,-Vo),Bo),Yo=-Wo*Wo+Xo*(Xo+2*Vo)+Ho);else if(!(Xo>=-jo))Xo=-Bo,Wo=Math.max(0,-(Oo*Xo+Go)),Yo=-Wo*Wo+Xo*(Xo+2*Vo)+Ho;else if(Xo<=jo){var qo=1/ko;Wo*=qo,Xo*=qo,Yo=Wo*(Wo+Oo*Xo+2*Go)+Xo*(Oo*Wo+Xo+2*Vo)+Ho}else Xo=Bo,Wo=Math.max(0,-(Oo*Xo+Go)),Yo=-Wo*Wo+Xo*(Xo+2*Vo)+Ho;return zo&&zo.copy(this.direction).multiplyScalar(Wo).add(this.origin),Fo&&Fo.copy(Co).multiplyScalar(Xo).add(wo),Yo}}(),intersectSphere:function(){var wo=new E;return function(Do,Uo){wo.subVectors(Do.center,this.origin);var No=wo.dot(this.direction),Io=wo.dot(wo)-No*No,zo=Do.radius*Do.radius;if(Io>zo)return null;var Fo=Math.sqrt(zo-Io),Bo=No-Fo,Oo=No+Fo;return 0>Bo&&0>Oo?null:0>Bo?this.at(Oo,Uo):this.at(Bo,Uo)}}(),intersectsSphere:function(wo){return this.distanceToPoint(wo.center)<=wo.radius},distanceToPlane:function(wo){var Co=wo.normal.dot(this.direction);if(0===Co)return 0===wo.distanceToPoint(this.origin)?0:null;var Do=-(this.origin.dot(wo.normal)+wo.constant)/Co;return 0<=Do?Do:null},intersectPlane:function(wo,Co){var Do=this.distanceToPlane(wo);return null===Do?null:this.at(Do,Co)},intersectsPlane:function(wo){var Co=wo.distanceToPoint(this.origin);if(0===Co)return!0;var Do=wo.normal.dot(this.direction);return!!(0>Do*Co)},intersectBox:function(wo,Co){var Bo=1/this.direction.x,Oo=1/this.direction.y,Go=1/this.direction.z,Vo=this.origin,Do,Uo,No,Io,zo,Fo;return(0<=Bo?(Do=(wo.min.x-Vo.x)*Bo,Uo=(wo.max.x-Vo.x)*Bo):(Do=(wo.max.x-Vo.x)*Bo,Uo=(wo.min.x-Vo.x)*Bo),0<=Oo?(No=(wo.min.y-Vo.y)*Oo,Io=(wo.max.y-Vo.y)*Oo):(No=(wo.max.y-Vo.y)*Oo,Io=(wo.min.y-Vo.y)*Oo),Do>Io||No>Uo)?null:((No>Do||Do!==Do)&&(Do=No),(Io<Uo||Uo!==Uo)&&(Uo=Io),0<=Go?(zo=(wo.min.z-Vo.z)*Go,Fo=(wo.max.z-Vo.z)*Go):(zo=(wo.max.z-Vo.z)*Go,Fo=(wo.min.z-Vo.z)*Go),Do>Fo||zo>Uo)?null:((zo>Do||Do!==Do)&&(Do=zo),(Fo<Uo||Uo!==Uo)&&(Uo=Fo),0>Uo?null:this.at(0<=Do?Do:Uo,Co))},intersectsBox:function(){var wo=new E;return function(Do){return null!==this.intersectBox(Do,wo)}}(),intersectTriangle:function(){var wo=new E,Co=new E,Do=new E,Uo=new E;return function(Io,zo,Fo,Bo,Oo){Co.subVectors(zo,Io),Do.subVectors(Fo,Io),Uo.crossVectors(Co,Do);var Go=this.direction.dot(Uo),Vo;if(0<Go){if(Bo)return null;Vo=1}else if(0>Go)Vo=-1,Go=-Go;else return null;wo.subVectors(this.origin,Io);var Ho=Vo*this.direction.dot(Do.crossVectors(wo,Do));if(0>Ho)return null;var ko=Vo*this.direction.dot(Co.cross(wo));if(0>ko)return null;if(Ho+ko>Go)return null;var Wo=-Vo*wo.dot(Uo);return 0>Wo?null:this.at(Wo/Go,Oo)}}(),applyMatrix4:function(wo){return this.direction.add(this.origin).applyMatrix4(wo),this.origin.applyMatrix4(wo),this.direction.sub(this.origin),this.direction.normalize(),this},equals:function(wo){return wo.origin.equals(this.origin)&&wo.direction.equals(this.direction)}},Ie.RotationOrders=['XYZ','YZX','ZXY','XZY','YXZ','ZYX'],Ie.DefaultOrder='XYZ',Ie.prototype={constructor:Ie,isEuler:!0,get x(){return this._x},set x(wo){this._x=wo,this.onChangeCallback()},get y(){return this._y},set y(wo){this._y=wo,this.onChangeCallback()},get z(){return this._z},set z(wo){this._z=wo,this.onChangeCallback()},get order(){return this._order},set order(wo){this._order=wo,this.onChangeCallback()},set:function(wo,Co,Do,Uo){return this._x=wo,this._y=Co,this._z=Do,this._order=Uo||this._order,this.onChangeCallback(),this},clone:function(){return new this.constructor(this._x,this._y,this._z,this._order)},copy:function(wo){return this._x=wo._x,this._y=wo._y,this._z=wo._z,this._order=wo._order,this.onChangeCallback(),this},setFromRotationMatrix:function(wo,Co,Do){var Uo=ci.clamp,No=wo.elements,Io=No[0],zo=No[4],Fo=No[8],Bo=No[1],Oo=No[5],Go=No[9],Vo=No[2],Ho=No[6],ko=No[10];return Co=Co||this._order,'XYZ'===Co?(this._y=Math.asin(Uo(Fo,-1,1)),0.99999>Math.abs(Fo)?(this._x=Math.atan2(-Go,ko),this._z=Math.atan2(-zo,Io)):(this._x=Math.atan2(Ho,Oo),this._z=0)):'YXZ'===Co?(this._x=Math.asin(-Uo(Go,-1,1)),0.99999>Math.abs(Go)?(this._y=Math.atan2(Fo,ko),this._z=Math.atan2(Bo,Oo)):(this._y=Math.atan2(-Vo,Io),this._z=0)):'ZXY'===Co?(this._x=Math.asin(Uo(Ho,-1,1)),0.99999>Math.abs(Ho)?(this._y=Math.atan2(-Vo,ko),this._z=Math.atan2(-zo,Oo)):(this._y=0,this._z=Math.atan2(Bo,Io))):'ZYX'===Co?(this._y=Math.asin(-Uo(Vo,-1,1)),0.99999>Math.abs(Vo)?(this._x=Math.atan2(Ho,ko),this._z=Math.atan2(Bo,Io)):(this._x=0,this._z=Math.atan2(-zo,Oo))):'YZX'===Co?(this._z=Math.asin(Uo(Bo,-1,1)),0.99999>Math.abs(Bo)?(this._x=Math.atan2(-Go,Oo),this._y=Math.atan2(-Vo,Io)):(this._x=0,this._y=Math.atan2(Fo,ko))):'XZY'===Co?(this._z=Math.asin(-Uo(zo,-1,1)),0.99999>Math.abs(zo)?(this._x=Math.atan2(Ho,Oo),this._y=Math.atan2(Fo,Io)):(this._x=Math.atan2(-Go,ko),this._y=0)):console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: '+Co),this._order=Co,!1!==Do&&this.onChangeCallback(),this},setFromQuaternion:function(){var wo;return function(Do,Uo,No){return void 0===wo&&(wo=new S),wo.makeRotationFromQuaternion(Do),this.setFromRotationMatrix(wo,Uo,No)}}(),setFromVector3:function(wo,Co){return this.set(wo.x,wo.y,wo.z,Co||this._order)},reorder:function(){var wo=new _;return function(Do){return wo.setFromEuler(this),this.setFromQuaternion(wo,Do)}}(),equals:function(wo){return wo._x===this._x&&wo._y===this._y&&wo._z===this._z&&wo._order===this._order},fromArray:function(wo){return this._x=wo[0],this._y=wo[1],this._z=wo[2],void 0!==wo[3]&&(this._order=wo[3]),this.onChangeCallback(),this},toArray:function(wo,Co){return void 0===wo&&(wo=[]),void 0===Co&&(Co=0),wo[Co]=this._x,wo[Co+1]=this._y,wo[Co+2]=this._z,wo[Co+3]=this._order,wo},toVector3:function(wo){return wo?wo.set(this._x,this._y,this._z):new E(this._x,this._y,this._z)},onChange:function(wo){return this.onChangeCallback=wo,this},onChangeCallback:function(){}},ze.prototype={constructor:ze,set:function(wo){this.mask=1<<wo},enable:function(wo){this.mask|=1<<wo},toggle:function(wo){this.mask^=1<<wo},disable:function(wo){this.mask&=~(1<<wo)},test:function(wo){return 0!==(this.mask&wo.mask)}};var To=0;Fe.DefaultUp=new E(0,1,0),Fe.DefaultMatrixAutoUpdate=!0,Fe.prototype={constructor:Fe,isObject3D:!0,applyMatrix:function(wo){this.matrix.multiplyMatrices(wo,this.matrix),this.matrix.decompose(this.position,this.quaternion,this.scale)},setRotationFromAxisAngle:function(wo,Co){this.quaternion.setFromAxisAngle(wo,Co)},setRotationFromEuler:function(wo){this.quaternion.setFromEuler(wo,!0)},setRotationFromMatrix:function(wo){this.quaternion.setFromRotationMatrix(wo)},setRotationFromQuaternion:function(wo){this.quaternion.copy(wo)},rotateOnAxis:function(){var wo=new _;return function(Do,Uo){return wo.setFromAxisAngle(Do,Uo),this.quaternion.multiply(wo),this}}(),rotateX:function(){var wo=new E(1,0,0);return function(Do){return this.rotateOnAxis(wo,Do)}}(),rotateY:function(){var wo=new E(0,1,0);return function(Do){return this.rotateOnAxis(wo,Do)}}(),rotateZ:function(){var wo=new E(0,0,1);return function(Do){return this.rotateOnAxis(wo,Do)}}(),translateOnAxis:function(){var wo=new E;return function(Do,Uo){return wo.copy(Do).applyQuaternion(this.quaternion),this.position.add(wo.multiplyScalar(Uo)),this}}(),translateX:function(){var wo=new E(1,0,0);return function(Do){return this.translateOnAxis(wo,Do)}}(),translateY:function(){var wo=new E(0,1,0);return function(Do){return this.translateOnAxis(wo,Do)}}(),translateZ:function(){var wo=new E(0,0,1);return function(Do){return this.translateOnAxis(wo,Do)}}(),localToWorld:function(wo){return wo.applyMatrix4(this.matrixWorld)},worldToLocal:function(){var wo=new S;return function(Do){return Do.applyMatrix4(wo.getInverse(this.matrixWorld))}}(),lookAt:function(){var wo=new S;return function(Do){wo.lookAt(Do,this.position,this.up),this.quaternion.setFromRotationMatrix(wo)}}(),add:function(wo){if(1<arguments.length){for(var Co=0;Co<arguments.length;Co++)this.add(arguments[Co]);return this}return wo===this?(console.error('THREE.Object3D.add: object can\'t be added as a child of itself.',wo),this):(wo&&wo.isObject3D?(null!==wo.parent&&wo.parent.remove(wo),wo.parent=this,wo.dispatchEvent({type:'added'}),this.children.push(wo)):console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.',wo),this)},remove:function(wo){if(1<arguments.length)for(var Co=0;Co<arguments.length;Co++)this.remove(arguments[Co]);var Do=this.children.indexOf(wo);-1!==Do&&(wo.parent=null,wo.dispatchEvent({type:'removed'}),this.children.splice(Do,1))},getObjectById:function(wo){return this.getObjectByProperty('id',wo)},getObjectByName:function(wo){return this.getObjectByProperty('name',wo)},getObjectByProperty:function(wo,Co){if(this[wo]===Co)return this;for(var Do=0,Uo=this.children.length;Do<Uo;Do++){var No=this.children[Do],Io=No.getObjectByProperty(wo,Co);if(Io!==void 0)return Io}},getWorldPosition:function(wo){var Co=wo||new E;return this.updateMatrixWorld(!0),Co.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(){var wo=new E,Co=new E;return function(Uo){var No=Uo||new _;return this.updateMatrixWorld(!0),this.matrixWorld.decompose(wo,No,Co),No}}(),getWorldRotation:function(){var wo=new _;return function(Do){var Uo=Do||new Ie;return this.getWorldQuaternion(wo),Uo.setFromQuaternion(wo,this.rotation.order,!1)}}(),getWorldScale:function(){var wo=new E,Co=new _;return function(Uo){var No=Uo||new E;return this.updateMatrixWorld(!0),this.matrixWorld.decompose(wo,Co,No),No}}(),getWorldDirection:function(){var wo=new _;return function(Do){var Uo=Do||new E;return this.getWorldQuaternion(wo),Uo.set(0,0,1).applyQuaternion(wo)}}(),raycast:function(){},traverse:function(wo){wo(this);for(var Co=this.children,Do=0,Uo=Co.length;Do<Uo;Do++)Co[Do].traverse(wo)},traverseVisible:function(wo){if(!1!==this.visible){wo(this);for(var Co=this.children,Do=0,Uo=Co.length;Do<Uo;Do++)Co[Do].traverseVisible(wo)}},traverseAncestors:function(wo){var Co=this.parent;null!==Co&&(wo(Co),Co.traverseAncestors(wo))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(wo){!0===this.matrixAutoUpdate&&this.updateMatrix(),(!0===this.matrixWorldNeedsUpdate||!0===wo)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,wo=!0);for(var Co=this.children,Do=0,Uo=Co.length;Do<Uo;Do++)Co[Do].updateMatrixWorld(wo)},toJSON:function(wo){function Co(Go){var Vo=[];for(var Ho in Go){var ko=Go[Ho];delete ko.metadata,Vo.push(ko)}return Vo}var Do=void 0===wo||''===wo,Uo={};Do&&(wo={geometries:{},materials:{},textures:{},images:{}},Uo.metadata={version:4.4,type:'Object',generator:'Object3D.toJSON'});var No={};if(No.uuid=this.uuid,No.type=this.type,''!==this.name&&(No.name=this.name),'{}'!==JSON.stringify(this.userData)&&(No.userData=this.userData),!0===this.castShadow&&(No.castShadow=!0),!0===this.receiveShadow&&(No.receiveShadow=!0),!1===this.visible&&(No.visible=!1),No.matrix=this.matrix.toArray(),void 0!==this.geometry&&(void 0===wo.geometries[this.geometry.uuid]&&(wo.geometries[this.geometry.uuid]=this.geometry.toJSON(wo)),No.geometry=this.geometry.uuid),void 0!==this.material&&(void 0===wo.materials[this.material.uuid]&&(wo.materials[this.material.uuid]=this.material.toJSON(wo)),No.material=this.material.uuid),0<this.children.length){No.children=[];for(var Io=0;Io<this.children.length;Io++)No.children.push(this.children[Io].toJSON(wo).object)}if(Do){var zo=Co(wo.geometries),Fo=Co(wo.materials),Bo=Co(wo.textures),Oo=Co(wo.images);0<zo.length&&(Uo.geometries=zo),0<Fo.length&&(Uo.materials=Fo),0<Bo.length&&(Uo.textures=Bo),0<Oo.length&&(Uo.images=Oo)}return Uo.object=No,Uo},clone:function(wo){return new this.constructor().copy(this,wo)},copy:function(wo,Co){if(void 0===Co&&(Co=!0),this.name=wo.name,this.up.copy(wo.up),this.position.copy(wo.position),this.quaternion.copy(wo.quaternion),this.scale.copy(wo.scale),this.matrix.copy(wo.matrix),this.matrixWorld.copy(wo.matrixWorld),this.matrixAutoUpdate=wo.matrixAutoUpdate,this.matrixWorldNeedsUpdate=wo.matrixWorldNeedsUpdate,this.layers.mask=wo.layers.mask,this.visible=wo.visible,this.castShadow=wo.castShadow,this.receiveShadow=wo.receiveShadow,this.frustumCulled=wo.frustumCulled,this.renderOrder=wo.renderOrder,this.userData=JSON.parse(JSON.stringify(wo.userData)),!0===Co)for(var Do=0,Uo;Do<wo.children.length;Do++)Uo=wo.children[Do],this.add(Uo.clone());return this}},Object.assign(Fe.prototype,M.prototype),Be.prototype={constructor:Be,set:function(wo,Co){return this.start.copy(wo),this.end.copy(Co),this},clone:function(){return new this.constructor().copy(this)},copy:function(wo){return this.start.copy(wo.start),this.end.copy(wo.end),this},getCenter:function(wo){var Co=wo||new E;return Co.addVectors(this.start,this.end).multiplyScalar(0.5)},delta:function(wo){var Co=wo||new E;return Co.subVectors(this.end,this.start)},distanceSq:function(){return this.start.distanceToSquared(this.end)},distance:function(){return this.start.distanceTo(this.end)},at:function(wo,Co){var Do=Co||new E;return this.delta(Do).multiplyScalar(wo).add(this.start)},closestPointToPointParameter:function(){var wo=new E,Co=new E;return function(Uo,No){wo.subVectors(Uo,this.start),Co.subVectors(this.end,this.start);var Io=Co.dot(Co),zo=Co.dot(wo),Fo=zo/Io;return No&&(Fo=ci.clamp(Fo,0,1)),Fo}}(),closestPointToPoint:function(wo,Co,Do){var Uo=this.closestPointToPointParameter(wo,Co),No=Do||new E;return this.delta(No).multiplyScalar(Uo).add(this.start)},applyMatrix4:function(wo){return this.start.applyMatrix4(wo),this.end.applyMatrix4(wo),this},equals:function(wo){return wo.start.equals(this.start)&&wo.end.equals(this.end)}},Oe.normal=function(){var wo=new E;return function(Do,Uo,No,Io){var zo=Io||new E;zo.subVectors(No,Uo),wo.subVectors(Do,Uo),zo.cross(wo);var Fo=zo.lengthSq();return 0<Fo?zo.multiplyScalar(1/Math.sqrt(Fo)):zo.set(0,0,0)}}(),Oe.barycoordFromPoint=function(){var wo=new E,Co=new E,Do=new E;return function(No,Io,zo,Fo,Bo){wo.subVectors(Fo,Io),Co.subVectors(zo,Io),Do.subVectors(No,Io);var Oo=wo.dot(wo),Go=wo.dot(Co),Vo=wo.dot(Do),Ho=Co.dot(Co),ko=Co.dot(Do),Wo=Oo*Ho-Go*Go,Xo=Bo||new E;if(0===Wo)return Xo.set(-2,-1,-1);var Yo=1/Wo,jo=(Ho*Vo-Go*ko)*Yo,qo=(Oo*ko-Go*Vo)*Yo;return Xo.set(1-jo-qo,qo,jo)}}(),Oe.containsPoint=function(){var wo=new E;return function(Do,Uo,No,Io){var zo=Oe.barycoordFromPoint(Do,Uo,No,Io,wo);return 0<=zo.x&&0<=zo.y&&1>=zo.x+zo.y}}(),Oe.prototype={constructor:Oe,set:function(wo,Co,Do){return this.a.copy(wo),this.b.copy(Co),this.c.copy(Do),this},setFromPointsAndIndices:function(wo,Co,Do,Uo){return this.a.copy(wo[Co]),this.b.copy(wo[Do]),this.c.copy(wo[Uo]),this},clone:function(){return new this.constructor().copy(this)},copy:function(wo){return this.a.copy(wo.a),this.b.copy(wo.b),this.c.copy(wo.c),this},area:function(){var wo=new E,Co=new E;return function(){return wo.subVectors(this.c,this.b),Co.subVectors(this.a,this.b),0.5*wo.cross(Co).length()}}(),midpoint:function(wo){var Co=wo||new E;return Co.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)},normal:function(wo){return Oe.normal(this.a,this.b,this.c,wo)},plane:function(wo){var Co=wo||new Ce;return Co.setFromCoplanarPoints(this.a,this.b,this.c)},barycoordFromPoint:function(wo,Co){return Oe.barycoordFromPoint(wo,this.a,this.b,this.c,Co)},containsPoint:function(wo){return Oe.containsPoint(wo,this.a,this.b,this.c)},closestPointToPoint:function(){var wo,Co,Do,Uo;return function(Io,zo){void 0===wo&&(wo=new Ce,Co=[new Be,new Be,new Be],Do=new E,Uo=new E);var Fo=zo||new E,Bo=Infinity;if(wo.setFromCoplanarPoints(this.a,this.b,this.c),wo.projectPoint(Io,Do),!0===this.containsPoint(Do))Fo.copy(Do);else{Co[0].set(this.a,this.b),Co[1].set(this.b,this.c),Co[2].set(this.c,this.a);for(var Oo=0;Oo<Co.length;Oo++){Co[Oo].closestPointToPoint(Do,!0,Uo);var Go=Do.distanceToSquared(Uo);Go<Bo&&(Bo=Go,Fo.copy(Uo))}}return Fo}}(),equals:function(wo){return wo.a.equals(this.a)&&wo.b.equals(this.b)&&wo.c.equals(this.c)}},Ge.prototype={constructor:Ge,clone:function(){return new this.constructor().copy(this)},copy:function(wo){this.a=wo.a,this.b=wo.b,this.c=wo.c,this.normal.copy(wo.normal),this.color.copy(wo.color),this.materialIndex=wo.materialIndex;for(var Co=0,Do=wo.vertexNormals.length;Co<Do;Co++)this.vertexNormals[Co]=wo.vertexNormals[Co].clone();for(var Co=0,Do=wo.vertexColors.length;Co<Do;Co++)this.vertexColors[Co]=wo.vertexColors[Co].clone();return this}},Ve.prototype=Object.create(Te.prototype),Ve.prototype.constructor=Ve,Ve.prototype.isMeshBasicMaterial=!0,Ve.prototype.copy=function(wo){return Te.prototype.copy.call(this,wo),this.color.copy(wo.color),this.map=wo.map,this.lightMap=wo.lightMap,this.lightMapIntensity=wo.lightMapIntensity,this.aoMap=wo.aoMap,this.aoMapIntensity=wo.aoMapIntensity,this.specularMap=wo.specularMap,this.alphaMap=wo.alphaMap,this.envMap=wo.envMap,this.combine=wo.combine,this.reflectivity=wo.reflectivity,this.refractionRatio=wo.refractionRatio,this.wireframe=wo.wireframe,this.wireframeLinewidth=wo.wireframeLinewidth,this.wireframeLinecap=wo.wireframeLinecap,this.wireframeLinejoin=wo.wireframeLinejoin,this.skinning=wo.skinning,this.morphTargets=wo.morphTargets,this},He.prototype={constructor:He,isBufferAttribute:!0,set needsUpdate(wo){!0===wo&&this.version++},setArray:function(wo){if(Array.isArray(wo))throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');this.count=wo===void 0?0:wo.length/this.itemSize,this.array=wo},setDynamic:function(wo){return this.dynamic=wo,this},copy:function(wo){return this.array=new wo.array.constructor(wo.array),this.itemSize=wo.itemSize,this.count=wo.count,this.normalized=wo.normalized,this.dynamic=wo.dynamic,this},copyAt:function(wo,Co,Do){wo*=this.itemSize,Do*=Co.itemSize;for(var Uo=0,No=this.itemSize;Uo<No;Uo++)this.array[wo+Uo]=Co.array[Do+Uo];return this},copyArray:function(wo){return this.array.set(wo),this},copyColorsArray:function(wo){for(var Co=this.array,Do=0,Uo=0,No=wo.length,Io;Uo<No;Uo++)Io=wo[Uo],void 0===Io&&(console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined',Uo),Io=new ve),Co[Do++]=Io.r,Co[Do++]=Io.g,Co[Do++]=Io.b;return this},copyIndicesArray:function(wo){for(var Co=this.array,Do=0,Uo=0,No=wo.length,Io;Uo<No;Uo++)Io=wo[Uo],Co[Do++]=Io.a,Co[Do++]=Io.b,Co[Do++]=Io.c;return this},copyVector2sArray:function(wo){for(var Co=this.array,Do=0,Uo=0,No=wo.length,Io;Uo<No;Uo++)Io=wo[Uo],void 0===Io&&(console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined',Uo),Io=new T),Co[Do++]=Io.x,Co[Do++]=Io.y;return this},copyVector3sArray:function(wo){for(var Co=this.array,Do=0,Uo=0,No=wo.length,Io;Uo<No;Uo++)Io=wo[Uo],void 0===Io&&(console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined',Uo),Io=new E),Co[Do++]=Io.x,Co[Do++]=Io.y,Co[Do++]=Io.z;return this},copyVector4sArray:function(wo){for(var Co=this.array,Do=0,Uo=0,No=wo.length,Io;Uo<No;Uo++)Io=wo[Uo],void 0===Io&&(console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined',Uo),Io=new _e),Co[Do++]=Io.x,Co[Do++]=Io.y,Co[Do++]=Io.z,Co[Do++]=Io.w;return this},set:function(wo,Co){return void 0===Co&&(Co=0),this.array.set(wo,Co),this},getX:function(wo){return this.array[wo*this.itemSize]},setX:function(wo,Co){return this.array[wo*this.itemSize]=Co,this},getY:function(wo){return this.array[wo*this.itemSize+1]},setY:function(wo,Co){return this.array[wo*this.itemSize+1]=Co,this},getZ:function(wo){return this.array[wo*this.itemSize+2]},setZ:function(wo,Co){return this.array[wo*this.itemSize+2]=Co,this},getW:function(wo){return this.array[wo*this.itemSize+3]},setW:function(wo,Co){return this.array[wo*this.itemSize+3]=Co,this},setXY:function(wo,Co,Do){return wo*=this.itemSize,this.array[wo+0]=Co,this.array[wo+1]=Do,this},setXYZ:function(wo,Co,Do,Uo){return wo*=this.itemSize,this.array[wo+0]=Co,this.array[wo+1]=Do,this.array[wo+2]=Uo,this},setXYZW:function(wo,Co,Do,Uo,No){return wo*=this.itemSize,this.array[wo+0]=Co,this.array[wo+1]=Do,this.array[wo+2]=Uo,this.array[wo+3]=No,this},onUpload:function(wo){return this.onUploadCallback=wo,this},clone:function(){return new this.constructor(this.array,this.itemSize).copy(this)}},ke.prototype=Object.create(He.prototype),ke.prototype.constructor=ke,We.prototype=Object.create(He.prototype),We.prototype.constructor=We,Xe.prototype=Object.create(He.prototype),Xe.prototype.constructor=Xe,Object.assign(Ye.prototype,{computeGroups:function(wo){for(var Do=[],Uo=void 0,No=wo.faces,Io=0,Co,zo;Io<No.length;Io++)zo=No[Io],zo.materialIndex!==Uo&&(Uo=zo.materialIndex,void 0!==Co&&(Co.count=3*Io-Co.start,Do.push(Co)),Co={start:3*Io,materialIndex:Uo});Co!==void 0&&(Co.count=3*Io-Co.start,Do.push(Co)),this.groups=Do},fromGeometry:function(wo){var Co=wo.faces,Do=wo.vertices,Uo=wo.faceVertexUvs,No=Uo[0]&&0<Uo[0].length,Io=Uo[1]&&0<Uo[1].length,zo=wo.morphTargets,Fo=zo.length,Bo;if(0<Fo){Bo=[];for(var Oo=0;Oo<Fo;Oo++)Bo[Oo]=[];this.morphTargets.position=Bo}var Go=wo.morphNormals,Vo=Go.length,Ho;if(0<Vo){Ho=[];for(var Oo=0;Oo<Vo;Oo++)Ho[Oo]=[];this.morphTargets.normal=Ho}for(var ko=wo.skinIndices,Wo=wo.skinWeights,Xo=ko.length===Do.length,Yo=Wo.length===Do.length,Oo=0,jo;Oo<Co.length;Oo++){jo=Co[Oo],this.vertices.push(Do[jo.a],Do[jo.b],Do[jo.c]);var qo=jo.vertexNormals;if(3===qo.length)this.normals.push(qo[0],qo[1],qo[2]);else{var Zo=jo.normal;this.normals.push(Zo,Zo,Zo)}var Qo=jo.vertexColors;if(3===Qo.length)this.colors.push(Qo[0],Qo[1],Qo[2]);else{var Jo=jo.color;this.colors.push(Jo,Jo,Jo)}if(!0===No){var Ko=Uo[0][Oo];void 0===Ko?(console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ',Oo),this.uvs.push(new T,new T,new T)):this.uvs.push(Ko[0],Ko[1],Ko[2])}if(!0===Io){var Ko=Uo[1][Oo];void 0===Ko?(console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ',Oo),this.uvs2.push(new T,new T,new T)):this.uvs2.push(Ko[0],Ko[1],Ko[2])}for(var $o=0,es;$o<Fo;$o++)es=zo[$o].vertices,Bo[$o].push(es[jo.a],es[jo.b],es[jo.c]);for(var $o=0,ts;$o<Vo;$o++)ts=Go[$o].vertexNormals[Oo],Ho[$o].push(ts.a,ts.b,ts.c);Xo&&this.skinIndices.push(ko[jo.a],ko[jo.b],ko[jo.c]),Yo&&this.skinWeights.push(Wo[jo.a],Wo[jo.b],Wo[jo.c])}return this.computeGroups(wo),this.verticesNeedUpdate=wo.verticesNeedUpdate,this.normalsNeedUpdate=wo.normalsNeedUpdate,this.colorsNeedUpdate=wo.colorsNeedUpdate,this.uvsNeedUpdate=wo.uvsNeedUpdate,this.groupsNeedUpdate=wo.groupsNeedUpdate,this}});var Lo=0;Ze.prototype={constructor:Ze,isGeometry:!0,applyMatrix:function(wo){for(var Co=new we().getNormalMatrix(wo),Do=0,Uo=this.vertices.length,No;Do<Uo;Do++)No=this.vertices[Do],No.applyMatrix4(wo);for(var Do=0,Uo=this.faces.length,Io;Do<Uo;Do++){Io=this.faces[Do],Io.normal.applyMatrix3(Co).normalize();for(var zo=0,Fo=Io.vertexNormals.length;zo<Fo;zo++)Io.vertexNormals[zo].applyMatrix3(Co).normalize()}return null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this.verticesNeedUpdate=!0,this.normalsNeedUpdate=!0,this},rotateX:function(){var wo;return function(Do){return void 0===wo&&(wo=new S),wo.makeRotationX(Do),this.applyMatrix(wo),this}}(),rotateY:function(){var wo;return function(Do){return void 0===wo&&(wo=new S),wo.makeRotationY(Do),this.applyMatrix(wo),this}}(),rotateZ:function(){var wo;return function(Do){return void 0===wo&&(wo=new S),wo.makeRotationZ(Do),this.applyMatrix(wo),this}}(),translate:function(){var wo;return function(Do,Uo,No){return void 0===wo&&(wo=new S),wo.makeTranslation(Do,Uo,No),this.applyMatrix(wo),this}}(),scale:function(){var wo;return function(Do,Uo,No){return void 0===wo&&(wo=new S),wo.makeScale(Do,Uo,No),this.applyMatrix(wo),this}}(),lookAt:function(){var wo;return function(Do){wo===void 0&&(wo=new Fe),wo.lookAt(Do),wo.updateMatrix(),this.applyMatrix(wo.matrix)}}(),fromBufferGeometry:function(wo){function Co(Qo,Jo,Ko,$o){var es=void 0===zo?[]:[Go[Qo].clone(),Go[Jo].clone(),Go[Ko].clone()],ts=void 0===Fo?[]:[Do.colors[Qo].clone(),Do.colors[Jo].clone(),Do.colors[Ko].clone()],rs=new Ge(Qo,Jo,Ko,es,ts,$o);Do.faces.push(rs),void 0!==Bo&&Do.faceVertexUvs[0].push([Vo[Qo].clone(),Vo[Jo].clone(),Vo[Ko].clone()]),void 0!==Oo&&Do.faceVertexUvs[1].push([Ho[Qo].clone(),Ho[Jo].clone(),Ho[Ko].clone()])}var Do=this,Uo=null===wo.index?void 0:wo.index.array,No=wo.attributes,Io=No.position.array,zo=void 0===No.normal?void 0:No.normal.array,Fo=void 0===No.color?void 0:No.color.array,Bo=void 0===No.uv?void 0:No.uv.array,Oo=void 0===No.uv2?void 0:No.uv2.array;void 0!==Oo&&(this.faceVertexUvs[1]=[]);for(var Go=[],Vo=[],Ho=[],ko=0,Wo=0;ko<Io.length;ko+=3,Wo+=2)Do.vertices.push(new E(Io[ko],Io[ko+1],Io[ko+2])),void 0!==zo&&Go.push(new E(zo[ko],zo[ko+1],zo[ko+2])),void 0!==Fo&&Do.colors.push(new ve(Fo[ko],Fo[ko+1],Fo[ko+2])),void 0!==Bo&&Vo.push(new T(Bo[Wo],Bo[Wo+1])),void 0!==Oo&&Ho.push(new T(Oo[Wo],Oo[Wo+1]));if(void 0!==Uo){var Xo=wo.groups;if(0<Xo.length)for(var ko=0;ko<Xo.length;ko++)for(var Yo=Xo[ko],jo=Yo.start,qo=Yo.count,Wo=jo;Wo<jo+qo;Wo+=3)Co(Uo[Wo],Uo[Wo+1],Uo[Wo+2],Yo.materialIndex);else for(var ko=0;ko<Uo.length;ko+=3)Co(Uo[ko],Uo[ko+1],Uo[ko+2])}else for(var ko=0;ko<Io.length/3;ko+=3)Co(ko,ko+1,ko+2);return this.computeFaceNormals(),null!==wo.boundingBox&&(this.boundingBox=wo.boundingBox.clone()),null!==wo.boundingSphere&&(this.boundingSphere=wo.boundingSphere.clone()),this},center:function(){this.computeBoundingBox();var wo=this.boundingBox.getCenter().negate();return this.translate(wo.x,wo.y,wo.z),wo},normalize:function(){this.computeBoundingSphere();var wo=this.boundingSphere.center,Co=this.boundingSphere.radius,Do=0===Co?1:1/Co,Uo=new S;return Uo.set(Do,0,0,-Do*wo.x,0,Do,0,-Do*wo.y,0,0,Do,-Do*wo.z,0,0,0,1),this.applyMatrix(Uo),this},computeFaceNormals:function(){for(var wo=new E,Co=new E,Do=0,Uo=this.faces.length;Do<Uo;Do++){var No=this.faces[Do],Io=this.vertices[No.a],zo=this.vertices[No.b],Fo=this.vertices[No.c];wo.subVectors(Fo,zo),Co.subVectors(Io,zo),wo.cross(Co),wo.normalize(),No.normal.copy(wo)}},computeVertexNormals:function(wo){wo===void 0&&(wo=!0);var Co,Do,Uo,No,Io,zo;for(zo=Array(this.vertices.length),Co=0,Do=this.vertices.length;Co<Do;Co++)zo[Co]=new E;if(wo){var Fo,Bo,Oo,Go=new E,Vo=new E;for(Uo=0,No=this.faces.length;Uo<No;Uo++)Io=this.faces[Uo],Fo=this.vertices[Io.a],Bo=this.vertices[Io.b],Oo=this.vertices[Io.c],Go.subVectors(Oo,Bo),Vo.subVectors(Fo,Bo),Go.cross(Vo),zo[Io.a].add(Go),zo[Io.b].add(Go),zo[Io.c].add(Go)}else for(this.computeFaceNormals(),Uo=0,No=this.faces.length;Uo<No;Uo++)Io=this.faces[Uo],zo[Io.a].add(Io.normal),zo[Io.b].add(Io.normal),zo[Io.c].add(Io.normal);for(Co=0,Do=this.vertices.length;Co<Do;Co++)zo[Co].normalize();for(Uo=0,No=this.faces.length;Uo<No;Uo++){Io=this.faces[Uo];var Ho=Io.vertexNormals;3===Ho.length?(Ho[0].copy(zo[Io.a]),Ho[1].copy(zo[Io.b]),Ho[2].copy(zo[Io.c])):(Ho[0]=zo[Io.a].clone(),Ho[1]=zo[Io.b].clone(),Ho[2]=zo[Io.c].clone())}0<this.faces.length&&(this.normalsNeedUpdate=!0)},computeFlatVertexNormals:function(){var wo,Co,Do;for(this.computeFaceNormals(),wo=0,Co=this.faces.length;wo<Co;wo++){Do=this.faces[wo];var Uo=Do.vertexNormals;3===Uo.length?(Uo[0].copy(Do.normal),Uo[1].copy(Do.normal),Uo[2].copy(Do.normal)):(Uo[0]=Do.normal.clone(),Uo[1]=Do.normal.clone(),Uo[2]=Do.normal.clone())}0<this.faces.length&&(this.normalsNeedUpdate=!0)},computeMorphNormals:function(){var wo,Co,Do,Uo,No;for(Do=0,Uo=this.faces.length;Do<Uo;Do++)for(No=this.faces[Do],No.__originalFaceNormal?No.__originalFaceNormal.copy(No.normal):No.__originalFaceNormal=No.normal.clone(),No.__originalVertexNormals||(No.__originalVertexNormals=[]),(wo=0,Co=No.vertexNormals.length);wo<Co;wo++)No.__originalVertexNormals[wo]?No.__originalVertexNormals[wo].copy(No.vertexNormals[wo]):No.__originalVertexNormals[wo]=No.vertexNormals[wo].clone();var Io=new Ze;for(Io.faces=this.faces,wo=0,Co=this.morphTargets.length;wo<Co;wo++){if(!this.morphNormals[wo]){this.morphNormals[wo]={},this.morphNormals[wo].faceNormals=[],this.morphNormals[wo].vertexNormals=[];var zo=this.morphNormals[wo].faceNormals,Fo=this.morphNormals[wo].vertexNormals,Bo,Oo;for(Do=0,Uo=this.faces.length;Do<Uo;Do++)Bo=new E,Oo={a:new E,b:new E,c:new E},zo.push(Bo),Fo.push(Oo)}var Go=this.morphNormals[wo];Io.vertices=this.morphTargets[wo].vertices,Io.computeFaceNormals(),Io.computeVertexNormals();var Bo,Oo;for(Do=0,Uo=this.faces.length;Do<Uo;Do++)No=this.faces[Do],Bo=Go.faceNormals[Do],Oo=Go.vertexNormals[Do],Bo.copy(No.normal),Oo.a.copy(No.vertexNormals[0]),Oo.b.copy(No.vertexNormals[1]),Oo.c.copy(No.vertexNormals[2])}for(Do=0,Uo=this.faces.length;Do<Uo;Do++)No=this.faces[Do],No.normal=No.__originalFaceNormal,No.vertexNormals=No.__originalVertexNormals},computeLineDistances:function(){for(var wo=0,Co=this.vertices,Do=0,Uo=Co.length;Do<Uo;Do++)0<Do&&(wo+=Co[Do].distanceTo(Co[Do-1])),this.lineDistances[Do]=wo},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new Re),this.boundingBox.setFromPoints(this.vertices)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new Pe),this.boundingSphere.setFromPoints(this.vertices)},merge:function(wo,Co,Do){if(!1===(wo&&wo.isGeometry))return void console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.',wo);var No=this.vertices.length,Io=this.vertices,zo=wo.vertices,Fo=this.faces,Bo=wo.faces,Oo=this.faceVertexUvs[0],Go=wo.faceVertexUvs[0],Vo=this.colors,Ho=wo.colors,Uo;Do===void 0&&(Do=0),Co!==void 0&&(Uo=new we().getNormalMatrix(Co));for(var ko=0,Wo=zo.length;ko<Wo;ko++){var Xo=zo[ko],Yo=Xo.clone();Co!==void 0&&Yo.applyMatrix4(Co),Io.push(Yo)}for(var ko=0,Wo=Ho.length;ko<Wo;ko++)Vo.push(Ho[ko].clone());for(ko=0,Wo=Bo.length;ko<Wo;ko++){var jo=Bo[ko],Jo=jo.vertexNormals,Ko=jo.vertexColors,qo,Zo,Qo;qo=new Ge(jo.a+No,jo.b+No,jo.c+No),qo.normal.copy(jo.normal),Uo!==void 0&&qo.normal.applyMatrix3(Uo).normalize();for(var $o=0,es=Jo.length;$o<es;$o++)Zo=Jo[$o].clone(),void 0!==Uo&&Zo.applyMatrix3(Uo).normalize(),qo.vertexNormals.push(Zo);qo.color.copy(jo.color);for(var $o=0,es=Ko.length;$o<es;$o++)Qo=Ko[$o],qo.vertexColors.push(Qo.clone());qo.materialIndex=jo.materialIndex+Do,Fo.push(qo)}for(ko=0,Wo=Go.length;ko<Wo;ko++){var ts=Go[ko],rs=[];if(void 0!==ts){for(var $o=0,es=ts.length;$o<es;$o++)rs.push(ts[$o].clone());Oo.push(rs)}}},mergeMesh:function(wo){return!1===(wo&&wo.isMesh)?void console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.',wo):void(wo.matrixAutoUpdate&&wo.updateMatrix(),this.merge(wo.geometry,wo.matrix))},mergeVertices:function(){var wo={},Co=[],Do=[],zo=Math.pow(10,4),Uo,No,Fo,Bo,Oo,Go,Vo,Ho;for(Fo=0,Bo=this.vertices.length;Fo<Bo;Fo++)Uo=this.vertices[Fo],No=Math.round(Uo.x*zo)+'_'+Math.round(Uo.y*zo)+'_'+Math.round(Uo.z*zo),void 0===wo[No]?(wo[No]=Fo,Co.push(this.vertices[Fo]),Do[Fo]=Co.length-1):Do[Fo]=Do[wo[No]];var ko=[];for(Fo=0,Bo=this.faces.length;Fo<Bo;Fo++){Oo=this.faces[Fo],Oo.a=Do[Oo.a],Oo.b=Do[Oo.b],Oo.c=Do[Oo.c],Go=[Oo.a,Oo.b,Oo.c];for(var Wo=0;3>Wo;Wo++)if(Go[Wo]===Go[(Wo+1)%3]){ko.push(Fo);break}}for(Fo=ko.length-1;0<=Fo;Fo--){var Xo=ko[Fo];for(this.faces.splice(Xo,1),Vo=0,Ho=this.faceVertexUvs.length;Vo<Ho;Vo++)this.faceVertexUvs[Vo].splice(Xo,1)}var Yo=this.vertices.length-Co.length;return this.vertices=Co,Yo},sortFacesByMaterialIndex:function(){for(var Co=this.faces,Do=Co.length,Uo=0;Uo<Do;Uo++)Co[Uo]._id=Uo;Co.sort(function(Oo,Go){return Oo.materialIndex-Go.materialIndex});var No=this.faceVertexUvs[0],Io=this.faceVertexUvs[1],zo,Fo;No&&No.length===Do&&(zo=[]),Io&&Io.length===Do&&(Fo=[]);for(var Uo=0,Bo;Uo<Do;Uo++)Bo=Co[Uo]._id,zo&&zo.push(No[Bo]),Fo&&Fo.push(Io[Bo]);zo&&(this.faceVertexUvs[0]=zo),Fo&&(this.faceVertexUvs[1]=Fo)},toJSON:function(){function wo(ns,os,ss){return ss?ns|1<<os:ns&~(1<<os)}function Co(ns){var os=ns.x.toString()+ns.y.toString()+ns.z.toString();return void 0===Ho[os]?(Ho[os]=Vo.length/3,Vo.push(ns.x,ns.y,ns.z),Ho[os]):Ho[os]}function Do(ns){var os=ns.r.toString()+ns.g.toString()+ns.b.toString();return void 0===Wo[os]?(Wo[os]=ko.length,ko.push(ns.getHex()),Wo[os]):Wo[os]}function Uo(ns){var os=ns.x.toString()+ns.y.toString();return void 0===Yo[os]?(Yo[os]=Xo.length/2,Xo.push(ns.x,ns.y),Yo[os]):Yo[os]}var No={metadata:{version:4.4,type:'Geometry',generator:'Geometry.toJSON'}};if(No.uuid=this.uuid,No.type=this.type,''!==this.name&&(No.name=this.name),void 0!==this.parameters){var Io=this.parameters;for(var zo in Io)void 0!==Io[zo]&&(No[zo]=Io[zo]);return No}for(var Fo=[],Bo=0,Oo;Bo<this.vertices.length;Bo++)Oo=this.vertices[Bo],Fo.push(Oo.x,Oo.y,Oo.z);for(var Go=[],Vo=[],Ho={},ko=[],Wo={},Xo=[],Yo={},Bo=0;Bo<this.faces.length;Bo++){var jo=this.faces[Bo],Qo=void 0!==this.faceVertexUvs[0][Bo],Jo=0<jo.normal.length(),Ko=0<jo.vertexNormals.length,$o=1!==jo.color.r||1!==jo.color.g||1!==jo.color.b,es=0<jo.vertexColors.length,ts=0;if(ts=wo(ts,0,0),ts=wo(ts,1,!0),ts=wo(ts,2,!1),ts=wo(ts,3,Qo),ts=wo(ts,4,Jo),ts=wo(ts,5,Ko),ts=wo(ts,6,$o),ts=wo(ts,7,es),Go.push(ts),Go.push(jo.a,jo.b,jo.c),Go.push(jo.materialIndex),Qo){var rs=this.faceVertexUvs[0][Bo];Go.push(Uo(rs[0]),Uo(rs[1]),Uo(rs[2]))}if(Jo&&Go.push(Co(jo.normal)),Ko){var as=jo.vertexNormals;Go.push(Co(as[0]),Co(as[1]),Co(as[2]))}if($o&&Go.push(Do(jo.color)),es){var is=jo.vertexColors;Go.push(Do(is[0]),Do(is[1]),Do(is[2]))}}return No.data={},No.data.vertices=Fo,No.data.normals=Vo,0<ko.length&&(No.data.colors=ko),0<Xo.length&&(No.data.uvs=[Xo]),No.data.faces=Go,No},clone:function(){return new Ze().copy(this)},copy:function(wo){var Co,Do,Uo,No,Io,zo;this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.name=wo.name;var Fo=wo.vertices;for(Co=0,Do=Fo.length;Co<Do;Co++)this.vertices.push(Fo[Co].clone());var Bo=wo.colors;for(Co=0,Do=Bo.length;Co<Do;Co++)this.colors.push(Bo[Co].clone());var Oo=wo.faces;for(Co=0,Do=Oo.length;Co<Do;Co++)this.faces.push(Oo[Co].clone());for(Co=0,Do=wo.faceVertexUvs.length;Co<Do;Co++){var Go=wo.faceVertexUvs[Co];for(void 0===this.faceVertexUvs[Co]&&(this.faceVertexUvs[Co]=[]),Uo=0,No=Go.length;Uo<No;Uo++){var Vo=Go[Uo],Ho=[];for(Io=0,zo=Vo.length;Io<zo;Io++){var ko=Vo[Io];Ho.push(ko.clone())}this.faceVertexUvs[Co].push(Ho)}}var Wo=wo.morphTargets;for(Co=0,Do=Wo.length;Co<Do;Co++){var Xo={name:Wo[Co].name};if(void 0!==Wo[Co].vertices)for(Xo.vertices=[],Uo=0,No=Wo[Co].vertices.length;Uo<No;Uo++)Xo.vertices.push(Wo[Co].vertices[Uo].clone());if(void 0!==Wo[Co].normals)for(Xo.normals=[],Uo=0,No=Wo[Co].normals.length;Uo<No;Uo++)Xo.normals.push(Wo[Co].normals[Uo].clone());this.morphTargets.push(Xo)}var Yo=wo.morphNormals;for(Co=0,Do=Yo.length;Co<Do;Co++){var jo={};if(void 0!==Yo[Co].vertexNormals)for(jo.vertexNormals=[],Uo=0,No=Yo[Co].vertexNormals.length;Uo<No;Uo++){var qo=Yo[Co].vertexNormals[Uo],Zo={};Zo.a=qo.a.clone(),Zo.b=qo.b.clone(),Zo.c=qo.c.clone(),jo.vertexNormals.push(Zo)}if(void 0!==Yo[Co].faceNormals)for(jo.faceNormals=[],Uo=0,No=Yo[Co].faceNormals.length;Uo<No;Uo++)jo.faceNormals.push(Yo[Co].faceNormals[Uo].clone());this.morphNormals.push(jo)}var Qo=wo.skinWeights;for(Co=0,Do=Qo.length;Co<Do;Co++)this.skinWeights.push(Qo[Co].clone());var Jo=wo.skinIndices;for(Co=0,Do=Jo.length;Co<Do;Co++)this.skinIndices.push(Jo[Co].clone());var Ko=wo.lineDistances;for(Co=0,Do=Ko.length;Co<Do;Co++)this.lineDistances.push(Ko[Co]);var $o=wo.boundingBox;null!==$o&&(this.boundingBox=$o.clone());var es=wo.boundingSphere;return null!==es&&(this.boundingSphere=es.clone()),this.elementsNeedUpdate=wo.elementsNeedUpdate,this.verticesNeedUpdate=wo.verticesNeedUpdate,this.uvsNeedUpdate=wo.uvsNeedUpdate,this.normalsNeedUpdate=wo.normalsNeedUpdate,this.colorsNeedUpdate=wo.colorsNeedUpdate,this.lineDistancesNeedUpdate=wo.lineDistancesNeedUpdate,this.groupsNeedUpdate=wo.groupsNeedUpdate,this},dispose:function(){this.dispatchEvent({type:'dispose'})}},Object.assign(Ze.prototype,M.prototype),Qe.prototype={constructor:Qe,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(wo){this.index=Array.isArray(wo)?new(65535<je(wo)?We:ke)(wo,1):wo},addAttribute:function(wo,Co){return!1===(Co&&Co.isBufferAttribute)&&!1===(Co&&Co.isInterleavedBufferAttribute)?(console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).'),void this.addAttribute(wo,new He(arguments[1],arguments[2]))):'index'===wo?(console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.'),void this.setIndex(Co)):(this.attributes[wo]=Co,this)},getAttribute:function(wo){return this.attributes[wo]},removeAttribute:function(wo){return delete this.attributes[wo],this},addGroup:function(wo,Co,Do){this.groups.push({start:wo,count:Co,materialIndex:Do===void 0?0:Do})},clearGroups:function(){this.groups=[]},setDrawRange:function(wo,Co){this.drawRange.start=wo,this.drawRange.count=Co},applyMatrix:function(wo){var Co=this.attributes.position;void 0!==Co&&(wo.applyToBufferAttribute(Co),Co.needsUpdate=!0);var Do=this.attributes.normal;if(void 0!==Do){var Uo=new we().getNormalMatrix(wo);Uo.applyToBufferAttribute(Do),Do.needsUpdate=!0}return null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this},rotateX:function(){var wo;return function(Do){return void 0===wo&&(wo=new S),wo.makeRotationX(Do),this.applyMatrix(wo),this}}(),rotateY:function(){var wo;return function(Do){return void 0===wo&&(wo=new S),wo.makeRotationY(Do),this.applyMatrix(wo),this}}(),rotateZ:function(){var wo;return function(Do){return void 0===wo&&(wo=new S),wo.makeRotationZ(Do),this.applyMatrix(wo),this}}(),translate:function(){var wo;return function(Do,Uo,No){return void 0===wo&&(wo=new S),wo.makeTranslation(Do,Uo,No),this.applyMatrix(wo),this}}(),scale:function(){var wo;return function(Do,Uo,No){return void 0===wo&&(wo=new S),wo.makeScale(Do,Uo,No),this.applyMatrix(wo),this}}(),lookAt:function(){var wo;return function(Do){wo===void 0&&(wo=new Fe),wo.lookAt(Do),wo.updateMatrix(),this.applyMatrix(wo.matrix)}}(),center:function(){this.computeBoundingBox();var wo=this.boundingBox.getCenter().negate();return this.translate(wo.x,wo.y,wo.z),wo},setFromObject:function(wo){var Co=wo.geometry;if(wo.isPoints||wo.isLine){var Do=new Xe(3*Co.vertices.length,3),Uo=new Xe(3*Co.colors.length,3);if(this.addAttribute('position',Do.copyVector3sArray(Co.vertices)),this.addAttribute('color',Uo.copyColorsArray(Co.colors)),Co.lineDistances&&Co.lineDistances.length===Co.vertices.length){var No=new Xe(Co.lineDistances.length,1);this.addAttribute('lineDistance',No.copyArray(Co.lineDistances))}null!==Co.boundingSphere&&(this.boundingSphere=Co.boundingSphere.clone()),null!==Co.boundingBox&&(this.boundingBox=Co.boundingBox.clone())}else wo.isMesh&&Co&&Co.isGeometry&&this.fromGeometry(Co);return this},updateFromObject:function(wo){var Co=wo.geometry;if(wo.isMesh){var Do=Co.__directGeometry;if(!0===Co.elementsNeedUpdate&&(Do=void 0,Co.elementsNeedUpdate=!1),void 0===Do)return this.fromGeometry(Co);Do.verticesNeedUpdate=Co.verticesNeedUpdate,Do.normalsNeedUpdate=Co.normalsNeedUpdate,Do.colorsNeedUpdate=Co.colorsNeedUpdate,Do.uvsNeedUpdate=Co.uvsNeedUpdate,Do.groupsNeedUpdate=Co.groupsNeedUpdate,Co.verticesNeedUpdate=!1,Co.normalsNeedUpdate=!1,Co.colorsNeedUpdate=!1,Co.uvsNeedUpdate=!1,Co.groupsNeedUpdate=!1,Co=Do}var Uo;return!0===Co.verticesNeedUpdate&&(Uo=this.attributes.position,void 0!==Uo&&(Uo.copyVector3sArray(Co.vertices),Uo.needsUpdate=!0),Co.verticesNeedUpdate=!1),!0===Co.normalsNeedUpdate&&(Uo=this.attributes.normal,void 0!==Uo&&(Uo.copyVector3sArray(Co.normals),Uo.needsUpdate=!0),Co.normalsNeedUpdate=!1),!0===Co.colorsNeedUpdate&&(Uo=this.attributes.color,void 0!==Uo&&(Uo.copyColorsArray(Co.colors),Uo.needsUpdate=!0),Co.colorsNeedUpdate=!1),Co.uvsNeedUpdate&&(Uo=this.attributes.uv,void 0!==Uo&&(Uo.copyVector2sArray(Co.uvs),Uo.needsUpdate=!0),Co.uvsNeedUpdate=!1),Co.lineDistancesNeedUpdate&&(Uo=this.attributes.lineDistance,void 0!==Uo&&(Uo.copyArray(Co.lineDistances),Uo.needsUpdate=!0),Co.lineDistancesNeedUpdate=!1),Co.groupsNeedUpdate&&(Co.computeGroups(wo.geometry),this.groups=Co.groups,Co.groupsNeedUpdate=!1),this},fromGeometry:function(wo){return wo.__directGeometry=new Ye().fromGeometry(wo),this.fromDirectGeometry(wo.__directGeometry)},fromDirectGeometry:function(wo){var Co=new Float32Array(3*wo.vertices.length);if(this.addAttribute('position',new He(Co,3).copyVector3sArray(wo.vertices)),0<wo.normals.length){var Do=new Float32Array(3*wo.normals.length);this.addAttribute('normal',new He(Do,3).copyVector3sArray(wo.normals))}if(0<wo.colors.length){var Uo=new Float32Array(3*wo.colors.length);this.addAttribute('color',new He(Uo,3).copyColorsArray(wo.colors))}if(0<wo.uvs.length){var No=new Float32Array(2*wo.uvs.length);this.addAttribute('uv',new He(No,2).copyVector2sArray(wo.uvs))}if(0<wo.uvs2.length){var Io=new Float32Array(2*wo.uvs2.length);this.addAttribute('uv2',new He(Io,2).copyVector2sArray(wo.uvs2))}if(0<wo.indices.length){var zo=65535<je(wo.indices)?Uint32Array:Uint16Array,Fo=new zo(3*wo.indices.length);this.setIndex(new He(Fo,1).copyIndicesArray(wo.indices))}for(var Bo in this.groups=wo.groups,wo.morphTargets){for(var Oo=[],Go=wo.morphTargets[Bo],Vo=0,Ho=Go.length;Vo<Ho;Vo++){var ko=Go[Vo],Wo=new Xe(3*ko.length,3);Oo.push(Wo.copyVector3sArray(ko))}this.morphAttributes[Bo]=Oo}if(0<wo.skinIndices.length){var Xo=new Xe(4*wo.skinIndices.length,4);this.addAttribute('skinIndex',Xo.copyVector4sArray(wo.skinIndices))}if(0<wo.skinWeights.length){var Yo=new Xe(4*wo.skinWeights.length,4);this.addAttribute('skinWeight',Yo.copyVector4sArray(wo.skinWeights))}return null!==wo.boundingSphere&&(this.boundingSphere=wo.boundingSphere.clone()),null!==wo.boundingBox&&(this.boundingBox=wo.boundingBox.clone()),this},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new Re);var wo=this.attributes.position;wo===void 0?this.boundingBox.makeEmpty():this.boundingBox.setFromBufferAttribute(wo),(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){var wo=new Re,Co=new E;return function(){null===this.boundingSphere&&(this.boundingSphere=new Pe);var Uo=this.attributes.position;if(Uo){var No=this.boundingSphere.center;wo.setFromBufferAttribute(Uo),wo.getCenter(No);for(var Io=0,zo=0,Fo=Uo.count;zo<Fo;zo++)Co.x=Uo.getX(zo),Co.y=Uo.getY(zo),Co.z=Uo.getZ(zo),Io=Math.max(Io,No.distanceToSquared(Co));this.boundingSphere.radius=Math.sqrt(Io),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}}(),computeFaceNormals:function(){},computeVertexNormals:function(){var wo=this.index,Co=this.attributes,Do=this.groups;if(Co.position){var Uo=Co.position.array;if(Co.normal===void 0)this.addAttribute('normal',new He(new Float32Array(Uo.length),3));else for(var No=Co.normal.array,Io=0,zo=No.length;Io<zo;Io++)No[Io]=0;var Fo=Co.normal.array,Bo,Oo,Go,Vo=new E,Ho=new E,ko=new E,Wo=new E,Xo=new E;if(wo){var Yo=wo.array;0===Do.length&&this.addGroup(0,Yo.length);for(var jo=0,qo=Do.length;jo<qo;++jo)for(var Zo=Do[jo],Qo=Zo.start,Jo=Zo.count,Io=Qo,zo=Qo+Jo;Io<zo;Io+=3)Bo=3*Yo[Io+0],Oo=3*Yo[Io+1],Go=3*Yo[Io+2],Vo.fromArray(Uo,Bo),Ho.fromArray(Uo,Oo),ko.fromArray(Uo,Go),Wo.subVectors(ko,Ho),Xo.subVectors(Vo,Ho),Wo.cross(Xo),Fo[Bo]+=Wo.x,Fo[Bo+1]+=Wo.y,Fo[Bo+2]+=Wo.z,Fo[Oo]+=Wo.x,Fo[Oo+1]+=Wo.y,Fo[Oo+2]+=Wo.z,Fo[Go]+=Wo.x,Fo[Go+1]+=Wo.y,Fo[Go+2]+=Wo.z}else for(var Io=0,zo=Uo.length;Io<zo;Io+=9)Vo.fromArray(Uo,Io),Ho.fromArray(Uo,Io+3),ko.fromArray(Uo,Io+6),Wo.subVectors(ko,Ho),Xo.subVectors(Vo,Ho),Wo.cross(Xo),Fo[Io]=Wo.x,Fo[Io+1]=Wo.y,Fo[Io+2]=Wo.z,Fo[Io+3]=Wo.x,Fo[Io+4]=Wo.y,Fo[Io+5]=Wo.z,Fo[Io+6]=Wo.x,Fo[Io+7]=Wo.y,Fo[Io+8]=Wo.z;this.normalizeNormals(),Co.normal.needsUpdate=!0}},merge:function(wo,Co){if(!1===(wo&&wo.isBufferGeometry))return void console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',wo);Co===void 0&&(Co=0);var Do=this.attributes;for(var Uo in Do)if(wo.attributes[Uo]!==void 0)for(var No=Do[Uo],Io=No.array,zo=wo.attributes[Uo],Fo=zo.array,Bo=zo.itemSize,Oo=0,Go=Bo*Co;Oo<Fo.length;Oo++,Go++)Io[Go]=Fo[Oo];return this},normalizeNormals:function(){for(var wo=this.attributes.normal.array,Io=0,zo=wo.length,Co,Do,Uo,No;Io<zo;Io+=3)Co=wo[Io],Do=wo[Io+1],Uo=wo[Io+2],No=1/Math.sqrt(Co*Co+Do*Do+Uo*Uo),wo[Io]*=No,wo[Io+1]*=No,wo[Io+2]*=No},toNonIndexed:function(){if(null===this.index)return console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.'),this;var wo=new Qe,Co=this.index.array,Do=this.attributes;for(var Uo in Do){for(var No=Do[Uo],Io=No.array,zo=No.itemSize,Fo=new Io.constructor(Co.length*zo),Bo=0,Oo=0,Go=0,Vo=Co.length;Go<Vo;Go++){Bo=Co[Go]*zo;for(var Ho=0;Ho<zo;Ho++)Fo[Oo++]=Io[Bo++]}wo.addAttribute(Uo,new He(Fo,zo))}return wo},toJSON:function(){var wo={metadata:{version:4.4,type:'BufferGeometry',generator:'BufferGeometry.toJSON'}};if(wo.uuid=this.uuid,wo.type=this.type,''!==this.name&&(wo.name=this.name),void 0!==this.parameters){var Co=this.parameters;for(var Do in Co)void 0!==Co[Do]&&(wo[Do]=Co[Do]);return wo}wo.data={attributes:{}};var Uo=this.index;if(null!==Uo){var No=Array.prototype.slice.call(Uo.array);wo.data.index={type:Uo.array.constructor.name,array:No}}var Io=this.attributes;for(var Do in Io){var zo=Io[Do],No=Array.prototype.slice.call(zo.array);wo.data.attributes[Do]={itemSize:zo.itemSize,type:zo.array.constructor.name,array:No,normalized:zo.normalized}}var Fo=this.groups;0<Fo.length&&(wo.data.groups=JSON.parse(JSON.stringify(Fo)));var Bo=this.boundingSphere;return null!==Bo&&(wo.data.boundingSphere={center:Bo.center.toArray(),radius:Bo.radius}),wo},clone:function(){return new Qe().copy(this)},copy:function(wo){var Co,Do,Uo;this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.name=wo.name;var No=wo.index;null!==No&&this.setIndex(No.clone());var Io=wo.attributes;for(Co in Io){var zo=Io[Co];this.addAttribute(Co,zo.clone())}var Fo=wo.morphAttributes;for(Co in Fo){var Bo=[],Oo=Fo[Co];for(Do=0,Uo=Oo.length;Do<Uo;Do++)Bo.push(Oo[Do].clone());this.morphAttributes[Co]=Bo}var Go=wo.groups;for(Do=0,Uo=Go.length;Do<Uo;Do++){var Vo=Go[Do];this.addGroup(Vo.start,Vo.count,Vo.materialIndex)}var Ho=wo.boundingBox;null!==Ho&&(this.boundingBox=Ho.clone());var ko=wo.boundingSphere;return null!==ko&&(this.boundingSphere=ko.clone()),this.drawRange.start=wo.drawRange.start,this.drawRange.count=wo.drawRange.count,this},dispose:function(){this.dispatchEvent({type:'dispose'})}},Qe.MaxIndex=65535,Object.assign(Qe.prototype,M.prototype),Je.prototype=Object.assign(Object.create(Fe.prototype),{constructor:Je,isMesh:!0,setDrawMode:function(wo){this.drawMode=wo},copy:function(wo){return Fe.prototype.copy.call(this,wo),this.drawMode=wo.drawMode,this},updateMorphTargets:function(){var wo=this.geometry.morphTargets;if(wo!==void 0&&0<wo.length){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(var Co=0,Do=wo.length;Co<Do;Co++)this.morphTargetInfluences.push(0),this.morphTargetDictionary[wo[Co].name]=Co}},raycast:function(){function wo(qo,Zo,Qo,Jo,Ko,$o,es){return Oe.barycoordFromPoint(qo,Zo,Qo,Jo,Xo),Ko.multiplyScalar(Xo.x),$o.multiplyScalar(Xo.y),es.multiplyScalar(Xo.z),Ko.add($o).add(es),Ko.clone()}function Co(qo,Zo,Qo,Jo,Ko,$o,es){var rs=qo.material,ts;if(ts=rs.side===ir?Qo.intersectTriangle($o,Ko,Jo,!0,es):Qo.intersectTriangle(Jo,Ko,$o,rs.side!==nr,es),null===ts)return null;jo.copy(es),jo.applyMatrix4(qo.matrixWorld);var as=Zo.ray.origin.distanceTo(jo);return as<Zo.near||as>Zo.far?null:{distance:as,point:jo.clone(),object:qo}}function Do(qo,Zo,Qo,Jo,Ko,$o,es,ts){zo.fromBufferAttribute(Jo,$o),Fo.fromBufferAttribute(Jo,es),Bo.fromBufferAttribute(Jo,ts);var rs=Co(qo,Zo,Qo,zo,Fo,Bo,Yo);return rs&&(Ko&&(Ho.fromBufferAttribute(Ko,$o),ko.fromBufferAttribute(Ko,es),Wo.fromBufferAttribute(Ko,ts),rs.uv=wo(Yo,zo,Fo,Bo,Ho,ko,Wo)),rs.face=new Ge($o,es,ts,Oe.normal(zo,Fo,Bo)),rs.faceIndex=$o),rs}var Uo=new S,No=new Ne,Io=new Pe,zo=new E,Fo=new E,Bo=new E,Oo=new E,Go=new E,Vo=new E,Ho=new T,ko=new T,Wo=new T,Xo=new E,Yo=new E,jo=new E;return function(Zo,Qo){var Jo=this.geometry,Ko=this.material,$o=this.matrixWorld;if(void 0!==Ko&&(null===Jo.boundingSphere&&Jo.computeBoundingSphere(),Io.copy(Jo.boundingSphere),Io.applyMatrix4($o),!1!==Zo.ray.intersectsSphere(Io))&&(Uo.getInverse($o),No.copy(Zo.ray).applyMatrix4(Uo),null===Jo.boundingBox||!1!==No.intersectsBox(Jo.boundingBox))){var es;if(Jo.isBufferGeometry){var is=Jo.index,ns=Jo.attributes.position,os=Jo.attributes.uv,ts,rs,as,ss,ls;if(null!==is)for(ss=0,ls=is.count;ss<ls;ss+=3)ts=is.getX(ss),rs=is.getX(ss+1),as=is.getX(ss+2),es=Do(this,Zo,No,ns,os,ts,rs,as),es&&(es.faceIndex=Math.floor(ss/3),Qo.push(es));else for(ss=0,ls=ns.count;ss<ls;ss+=3)ts=ss,rs=ss+1,as=ss+2,es=Do(this,Zo,No,ns,os,ts,rs,as),es&&(es.index=ts,Qo.push(es))}else if(Jo.isGeometry){var us=Ko&&Ko.isMultiMaterial,ms=!0===us?Ko.materials:null,fs=Jo.vertices,gs=Jo.faces,xs=Jo.faceVertexUvs[0],ds,cs,ps,hs;0<xs.length&&(hs=xs);for(var _s=0,vs=gs.length;_s<vs;_s++){var ys=gs[_s],Es=!0===us?ms[ys.materialIndex]:Ko;if(void 0!==Es){if(ds=fs[ys.a],cs=fs[ys.b],ps=fs[ys.c],!0===Es.morphTargets){var bs=Jo.morphTargets,Ss=this.morphTargetInfluences;zo.set(0,0,0),Fo.set(0,0,0),Bo.set(0,0,0);for(var Ms=0,Ts=bs.length,Ls;Ms<Ts;Ms++)if(Ls=Ss[Ms],0!==Ls){var As=bs[Ms].vertices;zo.addScaledVector(Oo.subVectors(As[ys.a],ds),Ls),Fo.addScaledVector(Go.subVectors(As[ys.b],cs),Ls),Bo.addScaledVector(Vo.subVectors(As[ys.c],ps),Ls)}zo.add(ds),Fo.add(cs),Bo.add(ps),ds=zo,cs=Fo,ps=Bo}if(es=Co(this,Zo,No,ds,cs,ps,Yo),es){if(hs){var Rs=hs[_s];Ho.copy(Rs[0]),ko.copy(Rs[1]),Wo.copy(Rs[2]),es.uv=wo(Yo,ds,cs,ps,Ho,ko,Wo)}es.face=ys,es.faceIndex=_s,Qo.push(es)}}}}}}}(),clone:function(){return new this.constructor(this.geometry,this.material).copy(this)}}),Ke.prototype=Object.create(Qe.prototype),Ke.prototype.constructor=Ke,$e.prototype=Object.create(Qe.prototype),$e.prototype.constructor=$e,et.prototype=Object.create(Fe.prototype),et.prototype.constructor=et,et.prototype.isCamera=!0,et.prototype.getWorldDirection=function(){var wo=new _;return function(Do){var Uo=Do||new E;return this.getWorldQuaternion(wo),Uo.set(0,0,-1).applyQuaternion(wo)}}(),et.prototype.lookAt=function(){var wo=new S;return function(Do){wo.lookAt(this.position,Do,this.up),this.quaternion.setFromRotationMatrix(wo)}}(),et.prototype.clone=function(){return new this.constructor().copy(this)},et.prototype.copy=function(wo){return Fe.prototype.copy.call(this,wo),this.matrixWorldInverse.copy(wo.matrixWorldInverse),this.projectionMatrix.copy(wo.projectionMatrix),this},tt.prototype=Object.assign(Object.create(et.prototype),{constructor:tt,isPerspectiveCamera:!0,copy:function(wo){return et.prototype.copy.call(this,wo),this.fov=wo.fov,this.zoom=wo.zoom,this.near=wo.near,this.far=wo.far,this.focus=wo.focus,this.aspect=wo.aspect,this.view=null===wo.view?null:Object.assign({},wo.view),this.filmGauge=wo.filmGauge,this.filmOffset=wo.filmOffset,this},setFocalLength:function(wo){var Co=0.5*this.getFilmHeight()/wo;this.fov=2*ci.RAD2DEG*Math.atan(Co),this.updateProjectionMatrix()},getFocalLength:function(){var wo=Math.tan(0.5*ci.DEG2RAD*this.fov);return 0.5*this.getFilmHeight()/wo},getEffectiveFOV:function(){return 2*ci.RAD2DEG*Math.atan(Math.tan(0.5*ci.DEG2RAD*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(wo,Co,Do,Uo,No,Io){this.aspect=wo/Co,this.view={fullWidth:wo,fullHeight:Co,offsetX:Do,offsetY:Uo,width:No,height:Io},this.updateProjectionMatrix()},clearViewOffset:function(){this.view=null,this.updateProjectionMatrix()},updateProjectionMatrix:function(){var wo=this.near,Co=wo*Math.tan(0.5*ci.DEG2RAD*this.fov)/this.zoom,Do=2*Co,Uo=this.aspect*Do,No=-0.5*Uo,Io=this.view;if(null!==Io){var zo=Io.fullWidth,Fo=Io.fullHeight;No+=Io.offsetX*Uo/zo,Co-=Io.offsetY*Do/Fo,Uo*=Io.width/zo,Do*=Io.height/Fo}var Bo=this.filmOffset;0!==Bo&&(No+=wo*Bo/this.getFilmWidth()),this.projectionMatrix.makePerspective(No,No+Uo,Co,Co-Do,wo,this.far)},toJSON:function(wo){var Co=Fe.prototype.toJSON.call(this,wo);return Co.object.fov=this.fov,Co.object.zoom=this.zoom,Co.object.near=this.near,Co.object.far=this.far,Co.object.focus=this.focus,Co.object.aspect=this.aspect,null!==this.view&&(Co.object.view=Object.assign({},this.view)),Co.object.filmGauge=this.filmGauge,Co.object.filmOffset=this.filmOffset,Co}}),rt.prototype=Object.assign(Object.create(et.prototype),{constructor:rt,isOrthographicCamera:!0,copy:function(wo){return et.prototype.copy.call(this,wo),this.left=wo.left,this.right=wo.right,this.top=wo.top,this.bottom=wo.bottom,this.near=wo.near,this.far=wo.far,this.zoom=wo.zoom,this.view=null===wo.view?null:Object.assign({},wo.view),this},setViewOffset:function(wo,Co,Do,Uo,No,Io){this.view={fullWidth:wo,fullHeight:Co,offsetX:Do,offsetY:Uo,width:No,height:Io},this.updateProjectionMatrix()},clearViewOffset:function(){this.view=null,this.updateProjectionMatrix()},updateProjectionMatrix:function(){var wo=(this.right-this.left)/(2*this.zoom),Co=(this.top-this.bottom)/(2*this.zoom),Do=(this.right+this.left)/2,Uo=(this.top+this.bottom)/2,No=Do-wo,Io=Do+wo,zo=Uo+Co,Fo=Uo-Co;if(null!==this.view){var Bo=this.zoom/(this.view.width/this.view.fullWidth),Oo=this.zoom/(this.view.height/this.view.fullHeight),Go=(this.right-this.left)/this.view.width,Vo=(this.top-this.bottom)/this.view.height;No+=Go*(this.view.offsetX/Bo),Io=No+Go*(this.view.width/Bo),zo-=Vo*(this.view.offsetY/Oo),Fo=zo-Vo*(this.view.height/Oo)}this.projectionMatrix.makeOrthographic(No,Io,zo,Fo,this.near,this.far)},toJSON:function(wo){var Co=Fe.prototype.toJSON.call(this,wo);return Co.object.zoom=this.zoom,Co.object.left=this.left,Co.object.right=this.right,Co.object.top=this.top,Co.object.bottom=this.bottom,Co.object.near=this.near,Co.object.far=this.far,null!==this.view&&(Co.object.view=Object.assign({},this.view)),Co}});var Ao=0;wt.prototype=Object.create(Fe.prototype),wt.prototype.constructor=wt,wt.prototype.copy=function(wo,Co){return Fe.prototype.copy.call(this,wo,Co),null!==wo.background&&(this.background=wo.background.clone()),null!==wo.fog&&(this.fog=wo.fog.clone()),null!==wo.overrideMaterial&&(this.overrideMaterial=wo.overrideMaterial.clone()),this.autoUpdate=wo.autoUpdate,this.matrixAutoUpdate=wo.matrixAutoUpdate,this},wt.prototype.toJSON=function(wo){var Co=Fe.prototype.toJSON.call(this,wo);return null!==this.background&&(Co.object.background=this.background.toJSON(wo)),null!==this.fog&&(Co.object.fog=this.fog.toJSON()),Co},Ct.prototype=Object.create(L.prototype),Ct.prototype.constructor=Ct;var Ro={enabled:!1,files:{},add:function(wo,Co){!1===this.enabled||(this.files[wo]=Co)},get:function(wo){return!1===this.enabled?void 0:this.files[wo]},remove:function(wo){delete this.files[wo]},clear:function(){this.files={}}},Po=new function(wo,Co,Do){var Uo=this,No=!1,Io=0,zo=0;this.onStart=void 0,this.onLoad=wo,this.onProgress=Co,this.onError=Do,this.itemStart=function(Fo){zo++,!1===No&&Uo.onStart!==void 0&&Uo.onStart(Fo,Io,zo),No=!0},this.itemEnd=function(Fo){Io++,Uo.onProgress!==void 0&&Uo.onProgress(Fo,Io,zo),Io===zo&&(No=!1,Uo.onLoad!==void 0&&Uo.onLoad())},this.itemError=function(Fo){Uo.onError!==void 0&&Uo.onError(Fo)}};Object.assign(Ut.prototype,{load:function(wo,Co,Do,Uo){void 0===wo&&(wo=''),void 0!==this.path&&(wo=this.path+wo);var No=this,Io=Ro.get(wo);if(void 0!==Io)return No.manager.itemStart(wo),setTimeout(function(){Co&&Co(Io),No.manager.itemEnd(wo)},0),Io;var zo=document.createElementNS('http://www.w3.org/1999/xhtml','img');return zo.addEventListener('load',function(){Ro.add(wo,this),Co&&Co(this),No.manager.itemEnd(wo)},!1),zo.addEventListener('error',function(Fo){Uo&&Uo(Fo),No.manager.itemError(wo)},!1),void 0!==this.crossOrigin&&(zo.crossOrigin=this.crossOrigin),No.manager.itemStart(wo),zo.src=wo,zo},setCrossOrigin:function(wo){return this.crossOrigin=wo,this},setPath:function(wo){return this.path=wo,this}}),Object.assign(Nt.prototype,{load:function(wo,Co,Do,Uo){var No=new L,Io=new Ut(this.manager);return Io.setCrossOrigin(this.crossOrigin),Io.setPath(this.path),Io.load(wo,function(zo){var Fo=0<wo.search(/\.(jpg|jpeg)$/)||0===wo.search(/^data\:image\/jpeg/);No.format=Fo?Ta:La,No.image=zo,No.needsUpdate=!0,void 0!==Co&&Co(No)},Do,Uo),No},setCrossOrigin:function(wo){return this.crossOrigin=wo,this},setPath:function(wo){return this.path=wo,this}}),It.prototype={constructor:It,linePrecision:1,set:function(wo,Co){this.ray.set(wo,Co)},setFromCamera:function(wo,Co){Co&&Co.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(Co.matrixWorld),this.ray.direction.set(wo.x,wo.y,0.5).unproject(Co).sub(this.ray.origin).normalize()):Co&&Co.isOrthographicCamera?(this.ray.origin.set(wo.x,wo.y,(Co.near+Co.far)/(Co.near-Co.far)).unproject(Co),this.ray.direction.set(0,0,-1).transformDirection(Co.matrixWorld)):console.error('THREE.Raycaster: Unsupported camera type.')},intersectObject:function(wo,Co){var Do=[];return Ft(wo,this,Do,Co),Do.sort(zt),Do},intersectObjects:function(wo,Co){var Do=[];if(!1===Array.isArray(wo))return console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.'),Do;for(var Uo=0,No=wo.length;Uo<No;Uo++)Ft(wo[Uo],this,Do,Co);return Do.sort(zt),Do}},Bt.prototype=Object.create(Ze.prototype),Bt.prototype.constructor=Bt,Ot.prototype=Object.create(Qe.prototype),Ot.prototype.constructor=Ot,Gt.prototype=Object.create(Ze.prototype),Gt.prototype.constructor=Gt,Vt.prototype=Object.create(Qe.prototype),Vt.prototype.constructor=Vt,Ht.prototype=Object.create(Ze.prototype),Ht.prototype.constructor=Ht,kt.prototype=Object.create(Qe.prototype),kt.prototype.constructor=kt,Wt.prototype=Object.create(Ze.prototype),Wt.prototype.constructor=Wt,Xt.prototype=Object.create(Qe.prototype),Xt.prototype.constructor=Xt,THREE.VRControls=function(wo,Co){var Uo=this,No,Io,zo=new THREE.Matrix4,Fo=null;'VRFrameData'in window&&(Fo=new VRFrameData),navigator.getVRDisplays&&navigator.getVRDisplays().then(function(Bo){Io=Bo,0<Bo.length?No=Bo[0]:Co&&Co('VR input not available.')}).catch(function(){console.warn('THREE.VRControls: Unable to get VR Displays')}),this.scale=1,this.standing=!1,this.userHeight=1.6,this.getVRDisplay=function(){return No},this.setVRDisplay=function(Bo){No=Bo},this.getVRDisplays=function(){return console.warn('THREE.VRControls: getVRDisplays() is being deprecated.'),Io},this.getStandingMatrix=function(){return zo},this.update=function(){if(No){var Bo;No.getFrameData?(No.getFrameData(Fo),Bo=Fo.pose):No.getPose&&(Bo=No.getPose()),null!==Bo.orientation&&wo.quaternion.fromArray(Bo.orientation),null===Bo.position?wo.position.set(0,0,0):wo.position.fromArray(Bo.position),this.standing&&(No.stageParameters?(wo.updateMatrix(),zo.fromArray(No.stageParameters.sittingToStandingTransform),wo.applyMatrix(zo)):wo.position.setY(wo.position.y+this.userHeight)),wo.position.multiplyScalar(Uo.scale)}},this.resetPose=function(){No&&No.resetPose()},this.resetSensor=function(){console.warn('THREE.VRControls: .resetSensor() is now .resetPose().'),this.resetPose()},this.zeroSensor=function(){console.warn('THREE.VRControls: .zeroSensor() is now .resetPose().'),this.resetPose()},this.dispose=function(){No=null}},THREE.VREffect=function(wo,Co){function Uo(){var $o=Wo.isPresenting;if(Wo.isPresenting=void 0!==Fo&&Fo.isPresenting,Wo.isPresenting){var es=Fo.getEyeParameters('left'),ts=es.renderWidth,rs=es.renderHeight;$o||(jo=wo.getPixelRatio(),Xo=wo.getSize(),wo.setPixelRatio(1),wo.setSize(2*ts,rs,!1))}else $o&&(wo.setPixelRatio(jo),wo.setSize(Xo.width,Xo.height,Yo))}function No($o){var es=2/($o.leftTan+$o.rightTan),ts=0.5*(($o.leftTan-$o.rightTan)*es),rs=2/($o.upTan+$o.downTan),as=0.5*(($o.upTan-$o.downTan)*rs);return{scale:[es,rs],offset:[ts,as]}}function Io($o,es,ts,rs){es=void 0===es||es,ts=void 0===ts?0.01:ts,rs=void 0===rs?1e4:rs;var as=es?-1:1,is=new THREE.Matrix4,ns=is.elements,os=No($o);return ns[0]=os.scale[0],ns[1]=0,ns[2]=os.offset[0]*as,ns[3]=0,ns[4]=0,ns[5]=os.scale[1],ns[6]=-os.offset[1]*as,ns[7]=0,ns[8]=0,ns[9]=0,ns[10]=rs/(ts-rs)*-as,ns[11]=rs*ts/(ts-rs),ns[12]=0,ns[13]=0,ns[14]=as,ns[15]=0,is.transpose(),is}function zo($o,es,ts,rs){var as=Math.PI/180,is={upTan:Math.tan($o.upDegrees*as),downTan:Math.tan($o.downDegrees*as),leftTan:Math.tan($o.leftDegrees*as),rightTan:Math.tan($o.rightDegrees*as)};return Io(is,es,ts,rs)}var Fo,Bo,Oo=new THREE.Vector3,Go=new THREE.Vector3,Vo,Ho,ko=null;'VRFrameData'in window&&(ko=new window.VRFrameData),navigator.getVRDisplays&&navigator.getVRDisplays().then(function($o){Bo=$o,0<$o.length?Fo=$o[0]:Co&&Co('HMD not available')}).catch(function(){console.warn('THREE.VREffect: Unable to get VR Displays')}),this.isPresenting=!1,this.scale=1;var Wo=this,Xo=wo.getSize(),Yo=!1,jo=wo.getPixelRatio();this.getVRDisplay=function(){return Fo},this.setVRDisplay=function($o){Fo=$o},this.getVRDisplays=function(){return console.warn('THREE.VREffect: getVRDisplays() is being deprecated.'),Bo},this.setSize=function($o,es,ts){if(Xo={width:$o,height:es},Yo=ts,Wo.isPresenting){var rs=Fo.getEyeParameters('left');wo.setPixelRatio(1),wo.setSize(2*rs.renderWidth,rs.renderHeight,!1)}else wo.setPixelRatio(jo),wo.setSize($o,es,ts)};var qo=wo.domElement,Zo=[0,0,0.5,1],Qo=[0.5,0,0.5,1];window.addEventListener('vrdisplaypresentchange',Uo,!1),this.setFullScreen=function($o){return new Promise(function(es,ts){return void 0===Fo?void ts(new Error('No VR hardware found.')):Wo.isPresenting===$o?void es():void($o?es(Fo.requestPresent([{source:qo}])):es(Fo.exitPresent()))})},this.requestPresent=function(){return this.setFullScreen(!0)},this.exitPresent=function(){return this.setFullScreen(!1)},this.requestAnimationFrame=function($o){return void 0===Fo?window.requestAnimationFrame($o):Fo.requestAnimationFrame($o)},this.cancelAnimationFrame=function($o){Fo===void 0?window.cancelAnimationFrame($o):Fo.cancelAnimationFrame($o)},this.submitFrame=function(){Fo!==void 0&&Wo.isPresenting&&Fo.submitFrame()},this.autoSubmitFrame=!0;var Jo=new THREE.PerspectiveCamera;Jo.layers.enable(1);var Ko=new THREE.PerspectiveCamera;Ko.layers.enable(2),this.render=function($o,es,ts,rs){if(Fo&&Wo.isPresenting){var as=$o.autoUpdate;as&&($o.updateMatrixWorld(),$o.autoUpdate=!1);var is=Fo.getEyeParameters('left'),ns=Fo.getEyeParameters('right');Oo.fromArray(is.offset),Go.fromArray(ns.offset),Array.isArray($o)&&(console.warn('THREE.VREffect.render() no longer supports arrays. Use object.layers instead.'),$o=$o[0]);var os=wo.getSize(),ss=Fo.getLayers(),ls,ds;if(ss.length){var cs=ss[0];ls=null!==cs.leftBounds&&4===cs.leftBounds.length?cs.leftBounds:Zo,ds=null!==cs.rightBounds&&4===cs.rightBounds.length?cs.rightBounds:Qo}else ls=Zo,ds=Qo;Vo={x:Math.round(os.width*ls[0]),y:Math.round(os.height*ls[1]),width:Math.round(os.width*ls[2]),height:Math.round(os.height*ls[3])},Ho={x:Math.round(os.width*ds[0]),y:Math.round(os.height*ds[1]),width:Math.round(os.width*ds[2]),height:Math.round(os.height*ds[3])},ts?(wo.setRenderTarget(ts),ts.scissorTest=!0):(wo.setRenderTarget(null),wo.setScissorTest(!0)),(wo.autoClear||rs)&&wo.clear(),null===es.parent&&es.updateMatrixWorld(),es.matrixWorld.decompose(Jo.position,Jo.quaternion,Jo.scale),es.matrixWorld.decompose(Ko.position,Ko.quaternion,Ko.scale);var ps=this.scale;return Jo.translateOnAxis(Oo,ps),Ko.translateOnAxis(Go,ps),Fo.getFrameData?(Fo.depthNear=es.near,Fo.depthFar=es.far,Fo.getFrameData(ko),Jo.projectionMatrix.elements=ko.leftProjectionMatrix,Ko.projectionMatrix.elements=ko.rightProjectionMatrix):(Jo.projectionMatrix=zo(is.fieldOfView,!0,es.near,es.far),Ko.projectionMatrix=zo(ns.fieldOfView,!0,es.near,es.far)),ts?(ts.viewport.set(Vo.x,Vo.y,Vo.width,Vo.height),ts.scissor.set(Vo.x,Vo.y,Vo.width,Vo.height)):(wo.setViewport(Vo.x,Vo.y,Vo.width,Vo.height),wo.setScissor(Vo.x,Vo.y,Vo.width,Vo.height)),wo.render($o,Jo,ts,rs),ts?(ts.viewport.set(Ho.x,Ho.y,Ho.width,Ho.height),ts.scissor.set(Ho.x,Ho.y,Ho.width,Ho.height)):(wo.setViewport(Ho.x,Ho.y,Ho.width,Ho.height),wo.setScissor(Ho.x,Ho.y,Ho.width,Ho.height)),wo.render($o,Ko,ts,rs),ts?(ts.viewport.set(0,0,os.width,os.height),ts.scissor.set(0,0,os.width,os.height),ts.scissorTest=!1,wo.setRenderTarget(null)):(wo.setViewport(0,0,os.width,os.height),wo.setScissorTest(!1)),as&&($o.autoUpdate=!0),void(Wo.autoSubmitFrame&&Wo.submitFrame())}wo.render($o,es,ts,rs)},this.dispose=function(){window.removeEventListener('vrdisplaypresentchange',Uo,!1)}},o.WebGLRenderer=function(wo){function Co(){return null===Cs?Ws:1}function Do(){hl.init(),hl.scissor(zs.copy(Xs).multiplyScalar(Ws)),hl.viewport(Bs.copy(js).multiplyScalar(Ws)),hl.buffers.color.setClear(Gs.r,Gs.g,Gs.b,Vs,vs)}function Uo(){ws=null,Is=null,Ns='',Us=-1,hl.reset()}function No(Dl){Dl.preventDefault(),Uo(),Do(),xl.clear()}function Io(Dl){var Ul=Dl.target;Ul.removeEventListener('dispose',Io),zo(Ul)}function zo(Dl){Fo(Dl),xl.delete(Dl)}function Fo(Dl){var Ul=xl.get(Dl).program;Dl.program=void 0,Ul!==void 0&&El.releaseProgram(Ul)}function Bo(Dl,Ul,Nl,Il){var zl;if(Nl&&Nl.isInstancedBufferGeometry&&(zl=cl.get('ANGLE_instanced_arrays'),null===zl))return void console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');Il===void 0&&(Il=0),hl.initAttributes();var Fl=Nl.attributes,Bl=Ul.getAttributes(),Ol=Dl.defaultAttributeValues;for(var Gl in Bl){var Vl=Bl[Gl];if(0<=Vl){var Hl=Fl[Gl];if(Hl!==void 0){var Wl=Hl.normalized,Xl=Hl.itemSize,Yl=yl.getAttributeProperties(Hl),ql=Yl.__webglBuffer,Zl=Yl.type,Ql=Yl.bytesPerElement;if(Hl.isInterleavedBufferAttribute){var Jl=Hl.data,Kl=Jl.stride,$l=Hl.offset;Jl&&Jl.isInstancedInterleavedBuffer?(hl.enableAttributeAndDivisor(Vl,Jl.meshPerAttribute,zl),Nl.maxInstancedCount===void 0&&(Nl.maxInstancedCount=Jl.meshPerAttribute*Jl.count)):hl.enableAttribute(Vl),sl.bindBuffer(sl.ARRAY_BUFFER,ql),sl.vertexAttribPointer(Vl,Xl,Zl,Wl,Kl*Ql,(Il*Kl+$l)*Ql)}else Hl.isInstancedBufferAttribute?(hl.enableAttributeAndDivisor(Vl,Hl.meshPerAttribute,zl),void 0===Nl.maxInstancedCount&&(Nl.maxInstancedCount=Hl.meshPerAttribute*Hl.count)):hl.enableAttribute(Vl),sl.bindBuffer(sl.ARRAY_BUFFER,ql),sl.vertexAttribPointer(Vl,Xl,Zl,Wl,0,Il*Xl*Ql)}else if(Ol!==void 0){var ed=Ol[Gl];if(ed!==void 0)switch(ed.length){case 2:sl.vertexAttrib2fv(Vl,ed);break;case 3:sl.vertexAttrib3fv(Vl,ed);break;case 4:sl.vertexAttrib4fv(Vl,ed);break;default:sl.vertexAttrib1fv(Vl,ed);}}}}hl.disableUnusedAttributes()}function Oo(Dl,Ul){return Math.abs(Ul[0])-Math.abs(Dl[0])}function Go(Dl,Ul){return Dl.object.renderOrder===Ul.object.renderOrder?Dl.material.program&&Ul.material.program&&Dl.material.program!==Ul.material.program?Dl.material.program.id-Ul.material.program.id:Dl.material.id===Ul.material.id?Dl.z===Ul.z?Dl.id-Ul.id:Dl.z-Ul.z:Dl.material.id-Ul.material.id:Dl.object.renderOrder-Ul.object.renderOrder}function Vo(Dl,Ul){return Dl.object.renderOrder===Ul.object.renderOrder?Dl.z===Ul.z?Dl.id-Ul.id:Ul.z-Dl.z:Dl.object.renderOrder-Ul.object.renderOrder}function Ho(Dl,Ul,Nl,Il,zl){var Fl,Bl;Nl.transparent?(Fl=Ms,Bl=++Ts):(Fl=bs,Bl=++Ss);var Ol=Fl[Bl];Ol===void 0?(Ol={id:Dl.id,object:Dl,geometry:Ul,material:Nl,z:el.z,group:zl},Fl.push(Ol)):(Ol.id=Dl.id,Ol.object=Dl,Ol.geometry=Ul,Ol.material=Nl,Ol.z=el.z,Ol.group=zl)}function ko(Dl){var Ul=Dl.geometry;return null===Ul.boundingSphere&&Ul.computeBoundingSphere(),Ks.copy(Ul.boundingSphere).applyMatrix4(Dl.matrixWorld),Xo(Ks)}function Wo(Dl){return Ks.center.set(0,0,0),Ks.radius=0.7071067811865476,Ks.applyMatrix4(Dl.matrixWorld),Xo(Ks)}function Xo(Dl){if(!qs.intersectsSphere(Dl))return!1;var Ul=Zs.numPlanes;if(0===Ul)return!0;var Nl=Ps.clippingPlanes,Il=Dl.center,zl=-Dl.radius,Fl=0;do if(Nl[Fl].distanceToPoint(Il)<zl)return!1;while(++Fl!==Ul);return!0}function Yo(Dl,Ul){if(!1!==Dl.visible){var Nl=0!==(Dl.layers.mask&Ul.layers.mask);if(Nl)if(Dl.isLight)Es.push(Dl);else if(Dl.isSprite)(!1===Dl.frustumCulled||!0===Wo(Dl))&&As.push(Dl);else if(Dl.isLensFlare)Rs.push(Dl);else if(Dl.isImmediateRenderObject)!0===Ps.sortObjects&&(el.setFromMatrixPosition(Dl.matrixWorld),el.applyMatrix4($s)),Ho(Dl,null,Dl.material,el.z,null);else if((Dl.isMesh||Dl.isLine||Dl.isPoints)&&(Dl.isSkinnedMesh&&Dl.skeleton.update(),!1===Dl.frustumCulled||!0===ko(Dl))){var Il=Dl.material;if(!0===Il.visible){!0===Ps.sortObjects&&(el.setFromMatrixPosition(Dl.matrixWorld),el.applyMatrix4($s));var zl=yl.update(Dl);if(Il.isMultiMaterial)for(var Fl=zl.groups,Bl=Il.materials,Ol=0,Gl=Fl.length;Ol<Gl;Ol++){var Vl=Fl[Ol],Hl=Bl[Vl.materialIndex];!0===Hl.visible&&Ho(Dl,zl,Hl,el.z,Vl)}else Ho(Dl,zl,Il,el.z,null)}}for(var Wl=Dl.children,Ol=0,Gl=Wl.length;Ol<Gl;Ol++)Yo(Wl[Ol],Ul)}}function jo(Dl,Ul,Nl,Il){for(var zl=0,Fl=Dl.length;zl<Fl;zl++){var Bl=Dl[zl],Ol=Bl.object,Gl=Bl.geometry,Vl=void 0===Il?Bl.material:Il,Hl=Bl.group;if(Ol.modelViewMatrix.multiplyMatrices(Nl.matrixWorldInverse,Ol.matrixWorld),Ol.normalMatrix.getNormalMatrix(Ol.modelViewMatrix),Ol.onBeforeRender(Ps,Ul,Nl,Gl,Vl,Hl),Ol.isImmediateRenderObject){Zo(Vl);var Wl=Qo(Nl,Ul.fog,Vl,Ol);Ns='',Ol.render(function(Xl){Ps.renderBufferImmediate(Xl,Wl,Vl)})}else Ps.renderBufferDirect(Nl,Ul.fog,Gl,Vl,Ol,Hl);Ol.onAfterRender(Ps,Ul,Nl,Gl,Vl,Hl)}}function qo(Dl,Ul,Nl){var Il=xl.get(Dl),zl=El.getParameters(Dl,nl,Ul,Zs.numPlanes,Zs.numIntersection,Nl),Fl=El.getProgramCode(Dl,zl),Bl=Il.program,Ol=!0;if(Bl===void 0)Dl.addEventListener('dispose',Io);else if(Bl.code!==Fl)Fo(Dl);else{if(zl.shaderID!==void 0)return;Ol=!1}if(Ol){if(zl.shaderID){var Gl=So[zl.shaderID];Il.__webglShader={name:Dl.type,uniforms:xi.clone(Gl.uniforms),vertexShader:Gl.vertexShader,fragmentShader:Gl.fragmentShader}}else Il.__webglShader={name:Dl.type,uniforms:Dl.uniforms,vertexShader:Dl.vertexShader,fragmentShader:Dl.fragmentShader};Dl.__webglShader=Il.__webglShader,Bl=El.acquireProgram(Dl,zl,Fl),Il.program=Bl,Dl.program=Bl}var Vl=Bl.getAttributes();if(Dl.morphTargets){Dl.numSupportedMorphTargets=0;for(var Hl=0;Hl<Ps.maxMorphTargets;Hl++)0<=Vl['morphTarget'+Hl]&&Dl.numSupportedMorphTargets++}if(Dl.morphNormals){Dl.numSupportedMorphNormals=0;for(var Hl=0;Hl<Ps.maxMorphNormals;Hl++)0<=Vl['morphNormal'+Hl]&&Dl.numSupportedMorphNormals++}var Wl=Il.__webglShader.uniforms;(Dl.isShaderMaterial||Dl.isRawShaderMaterial)&&!0!==Dl.clipping||(Il.numClippingPlanes=Zs.numPlanes,Il.numIntersection=Zs.numIntersection,Wl.clippingPlanes=Zs.uniform),Il.fog=Ul,Il.lightsHash=nl.hash,Dl.lights&&(Wl.ambientLightColor.value=nl.ambient,Wl.directionalLights.value=nl.directional,Wl.spotLights.value=nl.spot,Wl.rectAreaLights.value=nl.rectArea,Wl.pointLights.value=nl.point,Wl.hemisphereLights.value=nl.hemi,Wl.directionalShadowMap.value=nl.directionalShadowMap,Wl.directionalShadowMatrix.value=nl.directionalShadowMatrix,Wl.spotShadowMap.value=nl.spotShadowMap,Wl.spotShadowMatrix.value=nl.spotShadowMatrix,Wl.pointShadowMap.value=nl.pointShadowMap,Wl.pointShadowMatrix.value=nl.pointShadowMatrix);var Xl=Il.program.getUniforms(),Yl=xe.seqWithValue(Xl.seq,Wl);Il.uniformsList=Yl}function Zo(Dl){Dl.side===nr?hl.disable(sl.CULL_FACE):hl.enable(sl.CULL_FACE),hl.setFlipSided(Dl.side===ir),!0===Dl.transparent?hl.setBlending(Dl.blending,Dl.blendEquation,Dl.blendSrc,Dl.blendDst,Dl.blendEquationAlpha,Dl.blendSrcAlpha,Dl.blendDstAlpha,Dl.premultipliedAlpha):hl.setBlending(pr),hl.setDepthFunc(Dl.depthFunc),hl.setDepthTest(Dl.depthTest),hl.setDepthWrite(Dl.depthWrite),hl.setColorWrite(Dl.colorWrite),hl.setPolygonOffset(Dl.polygonOffset,Dl.polygonOffsetFactor,Dl.polygonOffsetUnits)}function Qo(Dl,Ul,Nl,Il){Os=0;var zl=xl.get(Nl);if(Qs&&(Js||Dl!==Is)){var Fl=Dl===Is&&Nl.id===Us;Zs.setState(Nl.clippingPlanes,Nl.clipIntersection,Nl.clipShadows,Dl,zl,Fl)}!1===Nl.needsUpdate&&(void 0===zl.program?Nl.needsUpdate=!0:Nl.fog&&zl.fog!==Ul?Nl.needsUpdate=!0:Nl.lights&&zl.lightsHash!==nl.hash?Nl.needsUpdate=!0:void 0!==zl.numClippingPlanes&&(zl.numClippingPlanes!==Zs.numPlanes||zl.numIntersection!==Zs.numIntersection)&&(Nl.needsUpdate=!0)),Nl.needsUpdate&&(qo(Nl,Ul,Il),Nl.needsUpdate=!1);var Bl=!1,Ol=!1,Gl=!1,Vl=zl.program,Hl=Vl.getUniforms(),Wl=zl.__webglShader.uniforms;if(Vl.id!==ws&&(sl.useProgram(Vl.program),ws=Vl.id,Bl=!0,Ol=!0,Gl=!0),Nl.id!==Us&&(Us=Nl.id,Ol=!0),Bl||Dl!==Is){if(Hl.set(sl,Dl,'projectionMatrix'),ul.logarithmicDepthBuffer&&Hl.setValue(sl,'logDepthBufFC',2/(Math.log(Dl.far+1)/Math.LN2)),Dl!==Is&&(Is=Dl,Ol=!0,Gl=!0),Nl.isShaderMaterial||Nl.isMeshPhongMaterial||Nl.isMeshStandardMaterial||Nl.envMap){var Xl=Hl.map.cameraPosition;void 0!==Xl&&Xl.setValue(sl,el.setFromMatrixPosition(Dl.matrixWorld))}(Nl.isMeshPhongMaterial||Nl.isMeshLambertMaterial||Nl.isMeshBasicMaterial||Nl.isMeshStandardMaterial||Nl.isShaderMaterial||Nl.skinning)&&Hl.setValue(sl,'viewMatrix',Dl.matrixWorldInverse),Hl.set(sl,Ps,'toneMappingExposure'),Hl.set(sl,Ps,'toneMappingWhitePoint')}if(Nl.skinning){Hl.setOptional(sl,Il,'bindMatrix'),Hl.setOptional(sl,Il,'bindMatrixInverse');var Yl=Il.skeleton;Yl&&(ul.floatVertexTextures&&Yl.useVertexTexture?(Hl.set(sl,Yl,'boneTexture'),Hl.set(sl,Yl,'boneTextureWidth'),Hl.set(sl,Yl,'boneTextureHeight')):Hl.setOptional(sl,Yl,'boneMatrices'))}return Ol&&(Nl.lights&&ls(Wl,Gl),Ul&&Nl.fog&&ts(Wl,Ul),(Nl.isMeshBasicMaterial||Nl.isMeshLambertMaterial||Nl.isMeshPhongMaterial||Nl.isMeshStandardMaterial||Nl.isMeshNormalMaterial||Nl.isMeshDepthMaterial)&&Jo(Wl,Nl),Nl.isLineBasicMaterial?Ko(Wl,Nl):Nl.isLineDashedMaterial?(Ko(Wl,Nl),$o(Wl,Nl)):Nl.isPointsMaterial?es(Wl,Nl):Nl.isMeshLambertMaterial?rs(Wl,Nl):Nl.isMeshToonMaterial?is(Wl,Nl):Nl.isMeshPhongMaterial?as(Wl,Nl):Nl.isMeshPhysicalMaterial?os(Wl,Nl):Nl.isMeshStandardMaterial?ns(Wl,Nl):Nl.isMeshDepthMaterial?Nl.displacementMap&&(Wl.displacementMap.value=Nl.displacementMap,Wl.displacementScale.value=Nl.displacementScale,Wl.displacementBias.value=Nl.displacementBias):Nl.isMeshNormalMaterial&&ss(Wl,Nl),void 0!==Wl.ltcMat&&(Wl.ltcMat.value=THREE.UniformsLib.LTC_MAT_TEXTURE),void 0!==Wl.ltcMag&&(Wl.ltcMag.value=THREE.UniformsLib.LTC_MAG_TEXTURE),xe.upload(sl,zl.uniformsList,Wl,Ps)),Hl.set(sl,Il,'modelViewMatrix'),Hl.set(sl,Il,'normalMatrix'),Hl.setValue(sl,'modelMatrix',Il.matrixWorld),Vl}function Jo(Dl,Ul){Dl.opacity.value=Ul.opacity,Dl.diffuse.value=Ul.color,Ul.emissive&&Dl.emissive.value.copy(Ul.emissive).multiplyScalar(Ul.emissiveIntensity),Dl.map.value=Ul.map,Dl.specularMap.value=Ul.specularMap,Dl.alphaMap.value=Ul.alphaMap,Ul.lightMap&&(Dl.lightMap.value=Ul.lightMap,Dl.lightMapIntensity.value=Ul.lightMapIntensity),Ul.aoMap&&(Dl.aoMap.value=Ul.aoMap,Dl.aoMapIntensity.value=Ul.aoMapIntensity);var Nl;if(Ul.map?Nl=Ul.map:Ul.specularMap?Nl=Ul.specularMap:Ul.displacementMap?Nl=Ul.displacementMap:Ul.normalMap?Nl=Ul.normalMap:Ul.bumpMap?Nl=Ul.bumpMap:Ul.roughnessMap?Nl=Ul.roughnessMap:Ul.metalnessMap?Nl=Ul.metalnessMap:Ul.alphaMap?Nl=Ul.alphaMap:Ul.emissiveMap&&(Nl=Ul.emissiveMap),void 0!==Nl){Nl.isWebGLRenderTarget&&(Nl=Nl.texture);var Il=Nl.offset,zl=Nl.repeat;Dl.offsetRepeat.value.set(Il.x,Il.y,zl.x,zl.y)}Dl.envMap.value=Ul.envMap,Dl.flipEnvMap.value=Ul.envMap&&Ul.envMap.isCubeTexture?-1:1,Dl.reflectivity.value=Ul.reflectivity,Dl.refractionRatio.value=Ul.refractionRatio}function Ko(Dl,Ul){Dl.diffuse.value=Ul.color,Dl.opacity.value=Ul.opacity}function $o(Dl,Ul){Dl.dashSize.value=Ul.dashSize,Dl.totalSize.value=Ul.dashSize+Ul.gapSize,Dl.scale.value=Ul.scale}function es(Dl,Ul){if(Dl.diffuse.value=Ul.color,Dl.opacity.value=Ul.opacity,Dl.size.value=Ul.size*Ws,Dl.scale.value=0.5*ks,Dl.map.value=Ul.map,null!==Ul.map){var Nl=Ul.map.offset,Il=Ul.map.repeat;Dl.offsetRepeat.value.set(Nl.x,Nl.y,Il.x,Il.y)}}function ts(Dl,Ul){Dl.fogColor.value=Ul.color,Ul.isFog?(Dl.fogNear.value=Ul.near,Dl.fogFar.value=Ul.far):Ul.isFogExp2&&(Dl.fogDensity.value=Ul.density)}function rs(Dl,Ul){Ul.emissiveMap&&(Dl.emissiveMap.value=Ul.emissiveMap)}function as(Dl,Ul){Dl.specular.value=Ul.specular,Dl.shininess.value=Math.max(Ul.shininess,1e-4),Ul.emissiveMap&&(Dl.emissiveMap.value=Ul.emissiveMap),Ul.bumpMap&&(Dl.bumpMap.value=Ul.bumpMap,Dl.bumpScale.value=Ul.bumpScale),Ul.normalMap&&(Dl.normalMap.value=Ul.normalMap,Dl.normalScale.value.copy(Ul.normalScale)),Ul.displacementMap&&(Dl.displacementMap.value=Ul.displacementMap,Dl.displacementScale.value=Ul.displacementScale,Dl.displacementBias.value=Ul.displacementBias)}function is(Dl,Ul){as(Dl,Ul),Ul.gradientMap&&(Dl.gradientMap.value=Ul.gradientMap)}function ns(Dl,Ul){Dl.roughness.value=Ul.roughness,Dl.metalness.value=Ul.metalness,Ul.roughnessMap&&(Dl.roughnessMap.value=Ul.roughnessMap),Ul.metalnessMap&&(Dl.metalnessMap.value=Ul.metalnessMap),Ul.emissiveMap&&(Dl.emissiveMap.value=Ul.emissiveMap),Ul.bumpMap&&(Dl.bumpMap.value=Ul.bumpMap,Dl.bumpScale.value=Ul.bumpScale),Ul.normalMap&&(Dl.normalMap.value=Ul.normalMap,Dl.normalScale.value.copy(Ul.normalScale)),Ul.displacementMap&&(Dl.displacementMap.value=Ul.displacementMap,Dl.displacementScale.value=Ul.displacementScale,Dl.displacementBias.value=Ul.displacementBias),Ul.envMap&&(Dl.envMapIntensity.value=Ul.envMapIntensity)}function os(Dl,Ul){Dl.clearCoat.value=Ul.clearCoat,Dl.clearCoatRoughness.value=Ul.clearCoatRoughness,ns(Dl,Ul)}function ss(Dl,Ul){Ul.bumpMap&&(Dl.bumpMap.value=Ul.bumpMap,Dl.bumpScale.value=Ul.bumpScale),Ul.normalMap&&(Dl.normalMap.value=Ul.normalMap,Dl.normalScale.value.copy(Ul.normalScale)),Ul.displacementMap&&(Dl.displacementMap.value=Ul.displacementMap,Dl.displacementScale.value=Ul.displacementScale,Dl.displacementBias.value=Ul.displacementBias)}function ls(Dl,Ul){Dl.ambientLightColor.needsUpdate=Ul,Dl.directionalLights.needsUpdate=Ul,Dl.pointLights.needsUpdate=Ul,Dl.spotLights.needsUpdate=Ul,Dl.rectAreaLights.needsUpdate=Ul,Dl.hemisphereLights.needsUpdate=Ul}function ds(Dl){for(var Ul=0,Nl=0,Il=Dl.length,zl;Nl<Il;Nl++)zl=Dl[Nl],zl.castShadow&&(nl.shadows[Ul++]=zl);nl.shadows.length=Ul}function cs(Dl,Ul){var Fl=0,Bl=0,Ol=0,Xl=Ul.matrixWorldInverse,Yl=0,ql=0,Zl=0,Ql=0,Jl=0,Nl,Il,zl,Gl,Vl,Hl,Wl;for(Nl=0,Il=Dl.length;Nl<Il;Nl++)if(zl=Dl[Nl],Gl=zl.color,Vl=zl.intensity,Hl=zl.distance,Wl=zl.shadow&&zl.shadow.map?zl.shadow.map.texture:null,zl.isAmbientLight)Fl+=Gl.r*Vl,Bl+=Gl.g*Vl,Ol+=Gl.b*Vl;else if(zl.isDirectionalLight){var Kl=bl.get(zl);Kl.color.copy(zl.color).multiplyScalar(zl.intensity),Kl.direction.setFromMatrixPosition(zl.matrixWorld),el.setFromMatrixPosition(zl.target.matrixWorld),Kl.direction.sub(el),Kl.direction.transformDirection(Xl),Kl.shadow=zl.castShadow,zl.castShadow&&(Kl.shadowBias=zl.shadow.bias,Kl.shadowRadius=zl.shadow.radius,Kl.shadowMapSize=zl.shadow.mapSize),nl.directionalShadowMap[Yl]=Wl,nl.directionalShadowMatrix[Yl]=zl.shadow.matrix,nl.directional[Yl++]=Kl}else if(zl.isSpotLight){var Kl=bl.get(zl);Kl.position.setFromMatrixPosition(zl.matrixWorld),Kl.position.applyMatrix4(Xl),Kl.color.copy(Gl).multiplyScalar(Vl),Kl.distance=Hl,Kl.direction.setFromMatrixPosition(zl.matrixWorld),el.setFromMatrixPosition(zl.target.matrixWorld),Kl.direction.sub(el),Kl.direction.transformDirection(Xl),Kl.coneCos=Math.cos(zl.angle),Kl.penumbraCos=Math.cos(zl.angle*(1-zl.penumbra)),Kl.decay=0===zl.distance?0:zl.decay,Kl.shadow=zl.castShadow,zl.castShadow&&(Kl.shadowBias=zl.shadow.bias,Kl.shadowRadius=zl.shadow.radius,Kl.shadowMapSize=zl.shadow.mapSize),nl.spotShadowMap[Zl]=Wl,nl.spotShadowMatrix[Zl]=zl.shadow.matrix,nl.spot[Zl++]=Kl}else if(zl.isRectAreaLight){var Kl=bl.get(zl);Kl.color.copy(Gl).multiplyScalar(Vl/(zl.width*zl.height)),Kl.position.setFromMatrixPosition(zl.matrixWorld),Kl.position.applyMatrix4(Xl),al.identity(),rl.copy(zl.matrixWorld),rl.premultiply(Xl),al.extractRotation(rl),Kl.halfWidth.set(0.5*zl.width,0,0),Kl.halfHeight.set(0,0.5*zl.height,0),Kl.halfWidth.applyMatrix4(al),Kl.halfHeight.applyMatrix4(al),nl.rectArea[Ql++]=Kl}else if(zl.isPointLight){var Kl=bl.get(zl);Kl.position.setFromMatrixPosition(zl.matrixWorld),Kl.position.applyMatrix4(Xl),Kl.color.copy(zl.color).multiplyScalar(zl.intensity),Kl.distance=zl.distance,Kl.decay=0===zl.distance?0:zl.decay,Kl.shadow=zl.castShadow,zl.castShadow&&(Kl.shadowBias=zl.shadow.bias,Kl.shadowRadius=zl.shadow.radius,Kl.shadowMapSize=zl.shadow.mapSize),nl.pointShadowMap[ql]=Wl,void 0===nl.pointShadowMatrix[ql]&&(nl.pointShadowMatrix[ql]=new S),el.setFromMatrixPosition(zl.matrixWorld).negate(),nl.pointShadowMatrix[ql].identity().setPosition(el),nl.point[ql++]=Kl}else if(zl.isHemisphereLight){var Kl=bl.get(zl);Kl.direction.setFromMatrixPosition(zl.matrixWorld),Kl.direction.transformDirection(Xl),Kl.direction.normalize(),Kl.skyColor.copy(zl.color).multiplyScalar(Vl),Kl.groundColor.copy(zl.groundColor).multiplyScalar(Vl),nl.hemi[Jl++]=Kl}nl.ambient[0]=Fl,nl.ambient[1]=Bl,nl.ambient[2]=Ol,nl.directional.length=Yl,nl.spot.length=Zl,nl.rectArea.length=Ql,nl.point.length=ql,nl.hemi.length=Jl,nl.hash=Yl+','+ql+','+Zl+','+Ql+','+Jl+','+nl.shadows.length}function us(Dl){var Ul;if(Dl===aa)return sl.REPEAT;if(Dl===ia)return sl.CLAMP_TO_EDGE;if(Dl===na)return sl.MIRRORED_REPEAT;if(Dl===oa)return sl.NEAREST;if(Dl===sa)return sl.NEAREST_MIPMAP_NEAREST;if(Dl===la)return sl.NEAREST_MIPMAP_LINEAR;if(Dl===da)return sl.LINEAR;if(Dl===ca)return sl.LINEAR_MIPMAP_NEAREST;if(Dl===pa)return sl.LINEAR_MIPMAP_LINEAR;if(Dl===ua)return sl.UNSIGNED_BYTE;if(Dl===ya)return sl.UNSIGNED_SHORT_4_4_4_4;if(Dl===Ea)return sl.UNSIGNED_SHORT_5_5_5_1;if(Dl===ba)return sl.UNSIGNED_SHORT_5_6_5;if(Dl===ma)return sl.BYTE;if(Dl===fa)return sl.SHORT;if(Dl===ga)return sl.UNSIGNED_SHORT;if(Dl===ha)return sl.INT;if(Dl===xa)return sl.UNSIGNED_INT;if(Dl===_a)return sl.FLOAT;if(Dl===va&&(Ul=cl.get('OES_texture_half_float'),null!==Ul))return Ul.HALF_FLOAT_OES;if(Dl===Ma)return sl.ALPHA;if(Dl===Ta)return sl.RGB;if(Dl===La)return sl.RGBA;if(Dl===Aa)return sl.LUMINANCE;if(Dl===Ra)return sl.LUMINANCE_ALPHA;if(Dl===wa)return sl.DEPTH_COMPONENT;if(Dl===Ca)return sl.DEPTH_STENCIL;if(Dl===xr)return sl.FUNC_ADD;if(Dl===_r)return sl.FUNC_SUBTRACT;if(Dl===vr)return sl.FUNC_REVERSE_SUBTRACT;if(Dl===br)return sl.ZERO;if(Dl===Sr)return sl.ONE;if(Dl===Mr)return sl.SRC_COLOR;if(Dl===Tr)return sl.ONE_MINUS_SRC_COLOR;if(Dl===Lr)return sl.SRC_ALPHA;if(Dl===Ar)return sl.ONE_MINUS_SRC_ALPHA;if(Dl===Rr)return sl.DST_ALPHA;if(Dl===Pr)return sl.ONE_MINUS_DST_ALPHA;if(Dl===wr)return sl.DST_COLOR;if(Dl===Cr)return sl.ONE_MINUS_DST_COLOR;if(Dl===Dr)return sl.SRC_ALPHA_SATURATE;if((Dl===Da||Dl===Ua||Dl===Na||Dl===Ia)&&(Ul=cl.get('WEBGL_compressed_texture_s3tc'),null!==Ul)){if(Dl===Da)return Ul.COMPRESSED_RGB_S3TC_DXT1_EXT;if(Dl===Ua)return Ul.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(Dl===Na)return Ul.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(Dl===Ia)return Ul.COMPRESSED_RGBA_S3TC_DXT5_EXT}if((Dl===za||Dl===Fa||Dl===Ba||Dl===Oa)&&(Ul=cl.get('WEBGL_compressed_texture_pvrtc'),null!==Ul)){if(Dl===za)return Ul.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(Dl===Fa)return Ul.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(Dl===Ba)return Ul.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(Dl===Oa)return Ul.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(Dl===Ga&&(Ul=cl.get('WEBGL_compressed_texture_etc1'),null!==Ul))return Ul.COMPRESSED_RGB_ETC1_WEBGL;if((Dl===yr||Dl===Er)&&(Ul=cl.get('EXT_blend_minmax'),null!==Ul)){if(Dl===yr)return Ul.MIN_EXT;if(Dl===Er)return Ul.MAX_EXT}return Dl===Sa&&(Ul=cl.get('WEBGL_depth_texture'),null!==Ul)?Ul.UNSIGNED_INT_24_8_WEBGL:0}console.log('THREE.WebGLRenderer',Yt),wo=wo||{};var ms=wo.canvas===void 0?document.createElementNS('http://www.w3.org/1999/xhtml','canvas'):wo.canvas,fs=wo.context===void 0?null:wo.context,gs=wo.alpha!==void 0&&wo.alpha,hs=!(wo.depth!==void 0)||wo.depth,xs=!(wo.stencil!==void 0)||wo.stencil,_s=wo.antialias!==void 0&&wo.antialias,vs=!(wo.premultipliedAlpha!==void 0)||wo.premultipliedAlpha,ys=wo.preserveDrawingBuffer!==void 0&&wo.preserveDrawingBuffer,Es=[],bs=[],Ss=-1,Ms=[],Ts=-1,Ls=new Float32Array(8),As=[],Rs=[];this.domElement=ms,this.context=null,this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.gammaInput=!1,this.gammaOutput=!1,this.physicallyCorrectLights=!1,this.toneMapping=Xr,this.toneMappingExposure=1,this.toneMappingWhitePoint=1,this.maxMorphTargets=8,this.maxMorphNormals=4;var Ps=this,ws=null,Cs=null,Ds=null,Us=-1,Ns='',Is=null,zs=new _e,Fs=null,Bs=new _e,Os=0,Gs=new ve(0),Vs=0,Hs=ms.width,ks=ms.height,Ws=1,Xs=new _e(0,0,Hs,ks),Ys=!1,js=new _e(0,0,Hs,ks),qs=new De,Zs=new Rt,Qs=!1,Js=!1,Ks=new Pe,$s=new S,el=new E,rl=new S,al=new S,nl={hash:'',ambient:[0,0,0],directional:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],point:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],shadows:[]},ol={calls:0,vertices:0,faces:0,points:0};this.info={render:ol,memory:{geometries:0,textures:0},programs:null};var sl;try{var dl={alpha:gs,depth:hs,stencil:xs,antialias:_s,premultipliedAlpha:vs,preserveDrawingBuffer:ys};if(sl=fs||ms.getContext('webgl',dl)||ms.getContext('experimental-webgl',dl),null===sl)if(null!==ms.getContext('webgl'))throw'Error creating WebGL context with your selected attributes.';else throw'Error creating WebGL context.';void 0===sl.getShaderPrecisionFormat&&(sl.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}}),ms.addEventListener('webglcontextlost',No,!1)}catch(Dl){console.error('THREE.WebGLRenderer: '+Dl)}var cl=new At(sl);cl.get('WEBGL_depth_texture'),cl.get('OES_texture_float'),cl.get('OES_texture_float_linear'),cl.get('OES_texture_half_float'),cl.get('OES_texture_half_float_linear'),cl.get('OES_standard_derivatives'),cl.get('ANGLE_instanced_arrays'),cl.get('OES_element_index_uint')&&(Qe.MaxIndex=4294967296);var ul=new Lt(sl,cl,wo),hl=new Tt(sl,cl,us),xl=new Mt,_l=new St(sl,cl,hl,xl,ul,us,this.info),yl=new bt(sl,xl,this.info),El=new yt(this,ul),bl=new nt;this.info.programs=El.programs;var Sl=new it(sl,cl,ol),Ml=new at(sl,cl,ol),Tl,Ll,Al,Rl;Do(),this.context=sl,this.capabilities=ul,this.extensions=cl,this.properties=xl,this.state=hl;var Pl=new Ue(this,nl,yl,ul);this.shadowMap=Pl;var wl=new Se(this,As),Cl=new Ee(this,Rs);this.getContext=function(){return sl},this.getContextAttributes=function(){return sl.getContextAttributes()},this.forceContextLoss=function(){cl.get('WEBGL_lose_context').loseContext()},this.getMaxAnisotropy=function(){return ul.getMaxAnisotropy()},this.getPrecision=function(){return ul.precision},this.getPixelRatio=function(){return Ws},this.setPixelRatio=function(Dl){void 0===Dl||(Ws=Dl,this.setSize(js.z,js.w,!1))},this.getSize=function(){return{width:Hs,height:ks}},this.setSize=function(Dl,Ul,Nl){Hs=Dl,ks=Ul,ms.width=Dl*Ws,ms.height=Ul*Ws,!1!==Nl&&(ms.style.width=Dl+'px',ms.style.height=Ul+'px'),this.setViewport(0,0,Dl,Ul)},this.setViewport=function(Dl,Ul,Nl,Il){hl.viewport(js.set(Dl,Ul,Nl,Il))},this.setScissor=function(Dl,Ul,Nl,Il){hl.scissor(Xs.set(Dl,Ul,Nl,Il))},this.setScissorTest=function(Dl){hl.setScissorTest(Ys=Dl)},this.getClearColor=function(){return Gs},this.setClearColor=function(Dl,Ul){Gs.set(Dl),Vs=Ul===void 0?1:Ul,hl.buffers.color.setClear(Gs.r,Gs.g,Gs.b,Vs,vs)},this.getClearAlpha=function(){return Vs},this.setClearAlpha=function(Dl){Vs=Dl,hl.buffers.color.setClear(Gs.r,Gs.g,Gs.b,Vs,vs)},this.clear=function(Dl,Ul,Nl){var Il=0;(Dl===void 0||Dl)&&(Il|=sl.COLOR_BUFFER_BIT),(Ul===void 0||Ul)&&(Il|=sl.DEPTH_BUFFER_BIT),(Nl===void 0||Nl)&&(Il|=sl.STENCIL_BUFFER_BIT),sl.clear(Il)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.clearTarget=function(Dl,Ul,Nl,Il){this.setRenderTarget(Dl),this.clear(Ul,Nl,Il)},this.resetGLState=Uo,this.dispose=function(){Ms=[],Ts=-1,bs=[],Ss=-1,ms.removeEventListener('webglcontextlost',No,!1)},this.renderBufferImmediate=function(Dl,Ul,Nl){hl.initAttributes();var Il=xl.get(Dl);Dl.hasPositions&&!Il.position&&(Il.position=sl.createBuffer()),Dl.hasNormals&&!Il.normal&&(Il.normal=sl.createBuffer()),Dl.hasUvs&&!Il.uv&&(Il.uv=sl.createBuffer()),Dl.hasColors&&!Il.color&&(Il.color=sl.createBuffer());var zl=Ul.getAttributes();if(Dl.hasPositions&&(sl.bindBuffer(sl.ARRAY_BUFFER,Il.position),sl.bufferData(sl.ARRAY_BUFFER,Dl.positionArray,sl.DYNAMIC_DRAW),hl.enableAttribute(zl.position),sl.vertexAttribPointer(zl.position,3,sl.FLOAT,!1,0,0)),Dl.hasNormals){if(sl.bindBuffer(sl.ARRAY_BUFFER,Il.normal),!Nl.isMeshPhongMaterial&&!Nl.isMeshStandardMaterial&&!Nl.isMeshNormalMaterial&&Nl.shading===or)for(var Fl=0,Bl=3*Dl.count;Fl<Bl;Fl+=9){var Ol=Dl.normalArray,Gl=(Ol[Fl+0]+Ol[Fl+3]+Ol[Fl+6])/3,Vl=(Ol[Fl+1]+Ol[Fl+4]+Ol[Fl+7])/3,Hl=(Ol[Fl+2]+Ol[Fl+5]+Ol[Fl+8])/3;Ol[Fl+0]=Gl,Ol[Fl+1]=Vl,Ol[Fl+2]=Hl,Ol[Fl+3]=Gl,Ol[Fl+4]=Vl,Ol[Fl+5]=Hl,Ol[Fl+6]=Gl,Ol[Fl+7]=Vl,Ol[Fl+8]=Hl}sl.bufferData(sl.ARRAY_BUFFER,Dl.normalArray,sl.DYNAMIC_DRAW),hl.enableAttribute(zl.normal),sl.vertexAttribPointer(zl.normal,3,sl.FLOAT,!1,0,0)}Dl.hasUvs&&Nl.map&&(sl.bindBuffer(sl.ARRAY_BUFFER,Il.uv),sl.bufferData(sl.ARRAY_BUFFER,Dl.uvArray,sl.DYNAMIC_DRAW),hl.enableAttribute(zl.uv),sl.vertexAttribPointer(zl.uv,2,sl.FLOAT,!1,0,0)),Dl.hasColors&&Nl.vertexColors!==lr&&(sl.bindBuffer(sl.ARRAY_BUFFER,Il.color),sl.bufferData(sl.ARRAY_BUFFER,Dl.colorArray,sl.DYNAMIC_DRAW),hl.enableAttribute(zl.color),sl.vertexAttribPointer(zl.color,3,sl.FLOAT,!1,0,0)),hl.disableUnusedAttributes(),sl.drawArrays(sl.TRIANGLES,0,Dl.count),Dl.count=0},this.renderBufferDirect=function(Dl,Ul,Nl,Il,zl,Fl){Zo(Il);var Bl=Qo(Dl,Ul,Il,zl),Ol=!1,Gl=Nl.id+'_'+Bl.id+'_'+Il.wireframe;Gl!==Ns&&(Ns=Gl,Ol=!0);var Vl=zl.morphTargetInfluences;if(Vl!==void 0){for(var Hl=[],Wl=0,Xl=Vl.length,Yl;Wl<Xl;Wl++)Yl=Vl[Wl],Hl.push([Yl,Wl]);Hl.sort(Oo),8<Hl.length&&(Hl.length=8);for(var ql=Nl.morphAttributes,Wl=0,Xl=Hl.length,Yl;Wl<Xl;Wl++)if(Yl=Hl[Wl],Ls[Wl]=Yl[0],0!==Yl[0]){var Zl=Yl[1];!0===Il.morphTargets&&ql.position&&Nl.addAttribute('morphTarget'+Wl,ql.position[Zl]),!0===Il.morphNormals&&ql.normal&&Nl.addAttribute('morphNormal'+Wl,ql.normal[Zl])}else!0===Il.morphTargets&&Nl.removeAttribute('morphTarget'+Wl),!0===Il.morphNormals&&Nl.removeAttribute('morphNormal'+Wl);for(var Wl=Hl.length,Ql=Ls.length;Wl<Ql;Wl++)Ls[Wl]=0;Bl.getUniforms().setValue(sl,'morphTargetInfluences',Ls),Ol=!0}var Zl=Nl.index,Jl=Nl.attributes.position,Kl=1;!0===Il.wireframe&&(Zl=yl.getWireframeAttribute(Nl),Kl=2);var $l;null===Zl?$l=Sl:($l=Ml,$l.setIndex(Zl)),Ol&&(Bo(Il,Bl,Nl),null!==Zl&&sl.bindBuffer(sl.ELEMENT_ARRAY_BUFFER,yl.getAttributeBuffer(Zl)));var ed=0;null===Zl?Jl!==void 0&&(ed=Jl.count):ed=Zl.count;var td=Nl.drawRange.start*Kl,rd=Nl.drawRange.count*Kl,nd=null===Fl?0:Fl.start*Kl,od=null===Fl?Infinity:Fl.count*Kl,sd=Math.max(td,nd),ld=Math.min(ed,td+rd,nd+od)-1,dd=Math.max(0,ld-sd+1);if(0!==dd){if(zl.isMesh){if(!0===Il.wireframe)hl.setLineWidth(Il.wireframeLinewidth*Co()),$l.setMode(sl.LINES);else switch(zl.drawMode){case Ja:$l.setMode(sl.TRIANGLES);break;case Ka:$l.setMode(sl.TRIANGLE_STRIP);break;case $a:$l.setMode(sl.TRIANGLE_FAN);}}else if(zl.isLine){var cd=Il.linewidth;void 0===cd&&(cd=1),hl.setLineWidth(cd*Co()),zl.isLineSegments?$l.setMode(sl.LINES):$l.setMode(sl.LINE_STRIP)}else zl.isPoints&&$l.setMode(sl.POINTS);Nl&&Nl.isInstancedBufferGeometry?0<Nl.maxInstancedCount&&$l.renderInstances(Nl,sd,dd):$l.render(sd,dd)}},this.render=function(Dl,Ul,Nl,Il){if(void 0!==Ul&&!0!==Ul.isCamera)return void console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');Ns='',Us=-1,Is=null,!0===Dl.autoUpdate&&Dl.updateMatrixWorld(),null===Ul.parent&&Ul.updateMatrixWorld(),Ul.matrixWorldInverse.getInverse(Ul.matrixWorld),$s.multiplyMatrices(Ul.projectionMatrix,Ul.matrixWorldInverse),qs.setFromMatrix($s),Es.length=0,Ss=-1,Ts=-1,As.length=0,Rs.length=0,Js=this.localClippingEnabled,Qs=Zs.init(this.clippingPlanes,Js,Ul),Yo(Dl,Ul),bs.length=Ss+1,Ms.length=Ts+1,!0===Ps.sortObjects&&(bs.sort(Go),Ms.sort(Vo)),Qs&&Zs.beginShadows(),ds(Es),Pl.render(Dl,Ul),cs(Es,Ul),Qs&&Zs.endShadows(),ol.calls=0,ol.vertices=0,ol.faces=0,ol.points=0,void 0===Nl&&(Nl=null),this.setRenderTarget(Nl);var zl=Dl.background;if(null===zl?hl.buffers.color.setClear(Gs.r,Gs.g,Gs.b,Vs,vs):zl&&zl.isColor&&(hl.buffers.color.setClear(zl.r,zl.g,zl.b,1,vs),Il=!0),(this.autoClear||Il)&&this.clear(this.autoClearColor,this.autoClearDepth,this.autoClearStencil),zl&&zl.isCubeTexture?(void 0===Al&&(Al=new tt,Rl=new Je(new Ke(5,5,5),new Le({uniforms:So.cube.uniforms,vertexShader:So.cube.vertexShader,fragmentShader:So.cube.fragmentShader,side:ir,depthTest:!1,depthWrite:!1,fog:!1}))),Al.projectionMatrix.copy(Ul.projectionMatrix),Al.matrixWorld.extractRotation(Ul.matrixWorld),Al.matrixWorldInverse.getInverse(Al.matrixWorld),Rl.material.uniforms.tCube.value=zl,Rl.modelViewMatrix.multiplyMatrices(Al.matrixWorldInverse,Rl.matrixWorld),yl.update(Rl),Ps.renderBufferDirect(Al,null,Rl.geometry,Rl.material,Rl,null)):zl&&zl.isTexture&&(void 0===Tl&&(Tl=new rt(-1,1,1,-1,0,1),Ll=new Je(new $e(2,2),new Ve({depthTest:!1,depthWrite:!1,fog:!1}))),Ll.material.map=zl,yl.update(Ll),Ps.renderBufferDirect(Tl,null,Ll.geometry,Ll.material,Ll,null)),Dl.overrideMaterial){var Fl=Dl.overrideMaterial;jo(bs,Dl,Ul,Fl),jo(Ms,Dl,Ul,Fl)}else hl.setBlending(pr),jo(bs,Dl,Ul),jo(Ms,Dl,Ul);wl.render(Dl,Ul),Cl.render(Dl,Ul,Bs),Nl&&_l.updateRenderTargetMipmap(Nl),hl.setDepthTest(!0),hl.setDepthWrite(!0),hl.setColorWrite(!0)},this.setFaceCulling=function(Dl,Ul){hl.setCullFace(Dl),hl.setFlipSided(Ul===Kt)},this.allocTextureUnit=function(){var Dl=Os;return Dl>=ul.maxTextures&&console.warn('WebGLRenderer: trying to use '+Dl+' texture units while this GPU supports only '+ul.maxTextures),Os+=1,Dl},this.setTexture2D=function(){var Dl=!1;return function(Nl,Il){Nl&&Nl.isWebGLRenderTarget&&(!Dl&&(console.warn('THREE.WebGLRenderer.setTexture2D: don\'t use render targets as textures. Use their .texture property instead.'),Dl=!0),Nl=Nl.texture),_l.setTexture2D(Nl,Il)}}(),this.setTexture=function(){var Dl=!1;return function(Nl,Il){Dl||(console.warn('THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.'),Dl=!0),_l.setTexture2D(Nl,Il)}}(),this.setTextureCube=function(){var Dl=!1;return function(Nl,Il){Nl&&Nl.isWebGLRenderTargetCube&&(!Dl&&(console.warn('THREE.WebGLRenderer.setTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.'),Dl=!0),Nl=Nl.texture),Nl&&Nl.isCubeTexture||Array.isArray(Nl.image)&&6===Nl.image.length?_l.setTextureCube(Nl,Il):_l.setTextureCubeDynamic(Nl,Il)}}(),this.getCurrentRenderTarget=function(){return Cs},this.setRenderTarget=function(Dl){Cs=Dl,Dl&&void 0===xl.get(Dl).__webglFramebuffer&&_l.setupRenderTarget(Dl);var Ul=Dl&&Dl.isWebGLRenderTargetCube,Nl;if(Dl){var Il=xl.get(Dl);Nl=Ul?Il.__webglFramebuffer[Dl.activeCubeFace]:Il.__webglFramebuffer,zs.copy(Dl.scissor),Fs=Dl.scissorTest,Bs.copy(Dl.viewport)}else Nl=null,zs.copy(Xs).multiplyScalar(Ws),Fs=Ys,Bs.copy(js).multiplyScalar(Ws);if(Ds!==Nl&&(sl.bindFramebuffer(sl.FRAMEBUFFER,Nl),Ds=Nl),hl.scissor(zs),hl.setScissorTest(Fs),hl.viewport(Bs),Ul){var zl=xl.get(Dl.texture);sl.framebufferTexture2D(sl.FRAMEBUFFER,sl.COLOR_ATTACHMENT0,sl.TEXTURE_CUBE_MAP_POSITIVE_X+Dl.activeCubeFace,zl.__webglTexture,Dl.activeMipMapLevel)}},this.readRenderTargetPixels=function(Dl,Ul,Nl,Il,zl,Fl){if(!1===(Dl&&Dl.isWebGLRenderTarget))return void console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');var Bl=xl.get(Dl).__webglFramebuffer;if(Bl){var Ol=!1;Bl!==Ds&&(sl.bindFramebuffer(sl.FRAMEBUFFER,Bl),Ol=!0);try{var Gl=Dl.texture,Vl=Gl.format,Hl=Gl.type;if(Vl!==La&&us(Vl)!==sl.getParameter(sl.IMPLEMENTATION_COLOR_READ_FORMAT))return void console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');if(Hl!==ua&&us(Hl)!==sl.getParameter(sl.IMPLEMENTATION_COLOR_READ_TYPE)&&!(Hl===_a&&(cl.get('OES_texture_float')||cl.get('WEBGL_color_buffer_float')))&&!(Hl===va&&cl.get('EXT_color_buffer_half_float')))return void console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');sl.checkFramebufferStatus(sl.FRAMEBUFFER)===sl.FRAMEBUFFER_COMPLETE?0<=Ul&&Ul<=Dl.width-Il&&0<=Nl&&Nl<=Dl.height-zl&&sl.readPixels(Ul,Nl,Il,zl,us(Vl),us(Hl),Fl):console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.')}finally{Ol&&sl.bindFramebuffer(sl.FRAMEBUFFER,Ds)}}}},o.Scene=wt,o.Mesh=Je,o.VideoTexture=Ct,o.MeshBasicMaterial=Ve,o.ShaderMaterial=Le,o.TextureLoader=Nt,o.PerspectiveCamera=tt,o.Object3D=Fe,o.Raycaster=It,o.Math=ci,o.Quaternion=_,o.Euler=Ie,o.Matrix4=S,o.Matrix3=we,o.Vector4=_e,o.Vector3=E,o.Vector2=T,o.Color=ve,o.TorusGeometry=Bt,o.SphereGeometry=Gt,o.CircleGeometry=Ht,o.RingGeometry=Wt,o.REVISION=Yt,o.MOUSE={LEFT:0,MIDDLE:1,RIGHT:2},o.CullFaceNone=qt,o.CullFaceBack=Zt,o.CullFaceFront=Qt,o.CullFaceFrontBack=3,o.FrontFaceDirectionCW=Kt,o.FrontFaceDirectionCCW=1,o.BasicShadowMap=0,o.PCFShadowMap=tr,o.PCFSoftShadowMap=rr,o.FrontSide=ar,o.BackSide=ir,o.DoubleSide=nr,o.FlatShading=or,o.SmoothShading=sr,o.NoColors=lr,o.FaceColors=1,o.VertexColors=2,o.NoBlending=pr,o.NormalBlending=ur,o.AdditiveBlending=mr,o.SubtractiveBlending=fr,o.MultiplyBlending=gr,o.CustomBlending=hr,o.AddEquation=xr,o.SubtractEquation=_r,o.ReverseSubtractEquation=vr,o.MinEquation=yr,o.MaxEquation=Er,o.ZeroFactor=br,o.OneFactor=Sr,o.SrcColorFactor=Mr,o.OneMinusSrcColorFactor=Tr,o.SrcAlphaFactor=Lr,o.OneMinusSrcAlphaFactor=Ar,o.DstAlphaFactor=Rr,o.OneMinusDstAlphaFactor=Pr,o.DstColorFactor=wr,o.OneMinusDstColorFactor=Cr,o.SrcAlphaSaturateFactor=Dr,o.NeverDepth=Ur,o.AlwaysDepth=Nr,o.LessDepth=Ir,o.LessEqualDepth=zr,o.EqualDepth=Fr,o.GreaterEqualDepth=Br,o.GreaterDepth=Or,o.NotEqualDepth=Gr,o.MultiplyOperation=Vr,o.MixOperation=Hr,o.AddOperation=kr,o.NoToneMapping=Wr,o.LinearToneMapping=Xr,o.ReinhardToneMapping=Yr,o.Uncharted2ToneMapping=jr,o.CineonToneMapping=qr,o.UVMapping=Zr,o.CubeReflectionMapping=Qr,o.CubeRefractionMapping=Jr,o.EquirectangularReflectionMapping=Kr,o.EquirectangularRefractionMapping=$r,o.SphericalReflectionMapping=ea,o.CubeUVReflectionMapping=ta,o.CubeUVRefractionMapping=ra,o.RepeatWrapping=aa,o.ClampToEdgeWrapping=ia,o.MirroredRepeatWrapping=na,o.NearestFilter=oa,o.NearestMipMapNearestFilter=sa,o.NearestMipMapLinearFilter=la,o.LinearFilter=da,o.LinearMipMapNearestFilter=ca,o.LinearMipMapLinearFilter=pa,o.UnsignedByteType=ua,o.ByteType=ma,o.ShortType=fa,o.UnsignedShortType=ga,o.IntType=ha,o.UnsignedIntType=xa,o.FloatType=_a,o.HalfFloatType=va,o.UnsignedShort4444Type=ya,o.UnsignedShort5551Type=Ea,o.UnsignedShort565Type=ba,o.UnsignedInt248Type=Sa,o.AlphaFormat=Ma,o.RGBFormat=Ta,o.RGBAFormat=La,o.LuminanceFormat=Aa,o.LuminanceAlphaFormat=Ra,o.RGBEFormat=La,o.DepthFormat=wa,o.DepthStencilFormat=Ca,o.RGB_S3TC_DXT1_Format=Da,o.RGBA_S3TC_DXT1_Format=Ua,o.RGBA_S3TC_DXT3_Format=Na,o.RGBA_S3TC_DXT5_Format=Ia,o.RGB_PVRTC_4BPPV1_Format=za,o.RGB_PVRTC_2BPPV1_Format=Fa,o.RGBA_PVRTC_4BPPV1_Format=Ba,o.RGBA_PVRTC_2BPPV1_Format=Oa,o.RGB_ETC1_Format=Ga,o.LoopOnce=2200,o.LoopRepeat=2201,o.LoopPingPong=2202,o.InterpolateDiscrete=2300,o.InterpolateLinear=2301,o.InterpolateSmooth=2302,o.ZeroCurvatureEnding=2400,o.ZeroSlopeEnding=2401,o.WrapAroundEnding=2402,o.TrianglesDrawMode=Ja,o.TriangleStripDrawMode=Ka,o.TriangleFanDrawMode=$a,o.LinearEncoding=ei,o.sRGBEncoding=ti,o.GammaEncoding=ri,o.RGBEEncoding=ai,o.LogLuvEncoding=3003,o.RGBM7Encoding=ni,o.RGBM16Encoding=oi,o.RGBDEncoding=si,o.BasicDepthPacking=li,o.RGBADepthPacking=di,Object.defineProperty(o,'__esModule',{value:!0}),Object.defineProperty(o,'AudioContext',{get:function(){return o.getAudioContext()}})});